<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Zach的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Zach的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zach的博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Zach的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zach的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">这个人很懒，都不知道说些什么 :(</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/20/进程控制/" itemprop="url">
                  进程控制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-20T00:00:00+08:00" content="2016-10-20">
              2016-10-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/20/进程控制/" class="leancloud_visitors" data-flag-title="进程控制">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u8FDB_u7A0B_u6807_u8BC6"><a href="#u8FDB_u7A0B_u6807_u8BC6" class="headerlink" title="进程标识"></a>进程标识</h1><p>每一个进程都有一个非负的进程ID来唯一标识自己，虽然ID唯一，但是ID可以复用，如果一个进程被销毁了，那么它的ID就可以被新创建的进程所使用。除了进程ID，进程还有其他一些标识符：</p>
<ul>
<li><code>uid</code>：进程的实际用户ID</li>
<li><code>eid</code>：进程的有效用户ID</li>
<li><code>ppid</code>：进程的父亲进程ID</li>
<li><code>gid</code>：进程的实际组ID</li>
<li><code>egid</code>：进程的有效组ID</li>
</ul>
<p>获得这些标识的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getppid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">uid_t</span> getuid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">uid_t</span> geteuid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">gid_t</span> getgid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">gid_t</span> getegid();</span><br></pre></td></tr></table></figure>
<h3 id="uid_u4E0Eeuid_uFF0Cgid_u4E0Eegid"><a href="#uid_u4E0Eeuid_uFF0Cgid_u4E0Eegid" class="headerlink" title="uid与euid，gid与egid"></a>uid与euid，gid与egid</h3><p>这两组值用来管理进程的访问权限。这里只说明<code>uid</code>和<code>euid</code>，<code>gid</code>和<code>egid</code>作用类似，只不过它们作用于进程组。</p>
<ul>
<li><code>uid</code>指的是登录用户的用户ID</li>
<li><code>euid</code>是进程用来决定我们对资源的访问权限，一般实际用户ID等于有效用户ID，当设置用户ID时，有效用户ID等于文件的所有者。</li>
</ul>
<p>举一个例子，如果一个文件的所有者是root，同时该文件被设置了用户ID，即用<code>ls</code>命令得到了如下的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l system_secure&#10;-rwsrwxr-x 1 root zach41 8720 10&#26376; 20 16:07 system_secure</span><br></pre></td></tr></table></figure>
<p>那么当用户<code>zach41</code>执行这个文件时，在执行期间进程获得了文件拥有者root的权限。</p>
<p>我们可以用<code>setuid</code>来设置实际用户ID和有效用户ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(uid_t uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(gid_t gid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>设置权限的规则如下：</p>
<ol>
<li>如果进程具有超级用户权限，那么<code>setuid</code>讲实际用户ID、有效用户ID、保存的用户ID都设置成uid。</li>
<li>如果进程不具有超级用户权限，但是<code>uid</code>等于实际用户ID或者保存的用户ID，那么<code>setuid</code>讲有效用户ID设置成<code>uid</code>。不更改实际用户ID和保存的用户ID。</li>
<li>如果上述规则都不满足，则<code>errno</code>设置成<strong>EPERM</strong>，并返回-1。</li>
</ol>
<p>另外两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(uid_t uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(gid_t gid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于一个特权用户来说，<code>seteuid</code>可以将有效用户ID设置成<code>uid</code>，而<code>setuid</code>更改所有的3个用户ID。对于一个非特权用户，可以利用该函数讲有效用户ID设置为实际用户ID或者保存的设置用户ID。</p>
<h1 id="u8FDB_u7A0B_u521B_u5EFA_u4E0E_u9500_u6BC1"><a href="#u8FDB_u7A0B_u521B_u5EFA_u4E0E_u9500_u6BC1" class="headerlink" title="进程创建与销毁"></a>进程创建与销毁</h1><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><p>可以用<code>fork</code>来创建一个进程，用<code>exit</code>来销毁一个进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork();</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fork</code>函数返回两次，在父进程中函数返回值为新生成的子进程的<code>pid</code>，在子进程中返回值为0。一个比较典型的<code>fork</code>调用范式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pid = fork) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* fork error*/</span></span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* child process*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* parent process*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fork</code>通常有一下两种用法：</p>
<ol>
<li>一个父进程希望自己复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中比较常见。</li>
<li>一个进程需要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从<code>fork</code>中返回后立即调用<code>exec</code>函数。</li>
</ol>
<p><code>fork</code>的一个特性是，子进程复制父进程所有打开的描述符，这里只是复制文件描述符，父进程和子进程共享文件表项。一个典型的<code>fork</code>之后的文件描述图示：</p>
<img src="/2016/10/20/进程控制/file_shared.png" alt="file_shared.png" title="">
<p>除了打开的文件之外，子进程还继承了父进程的：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标识和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭<code>close-on-exec</code>标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
</ul>
<p>一个<code>fork</code>的演示例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> globalvar = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"a write to stdout\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(STDOUT_FILENO, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>) != <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	globalvar++;</span><br><span class="line">	var++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid = %ld, globalvar = %d, var = %d\n"</span>, (<span class="keyword">long</span>)pid, globalvar, var);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;a write to stdout&#10;before fork&#10;pid = 0, globalvar = 7, var = 89&#10;pid = 11510, globalvar = 6, var = 88&#10;&#10;$ ./a.out &#62; fork_buf.out&#10;&#10;a write to stdout&#10;before fork&#10;pid = 0, globalvar = 7, var = 89&#10;before fork&#10;pid = 11589, globalvar = 6, var = 88</span><br></pre></td></tr></table></figure>
<p>父进程在执行<code>fork</code>后主动睡眠，让子进程先执行（实际上这在有的时候也不能保证，需要用更高级的方法），可以看到子进程输出的<code>globalvar</code>和<code>var</code>都加了1，而父进程没有。</p>
<p>如果我们重定向了标准输出，那么就会看到<code>before fork</code>被输出了两次，这是因为当标准输出和一个文件相关联时它是全缓冲的，在<code>fork</code>之前，字符串被存放到缓冲区中，<code>fork</code>函数导致父进程的数据空间被复制到子进程中，标准输出的缓冲区也同样被复制，这样当进程结束时，缓冲区被清洗，于是就有了两次<code>brefore fork</code>的输出。在第一个例子中，由于标准输出和一个终端相关联，它是行缓冲的，所以只输出了一次<code>before fork</code>。</p>
<h3 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h3><p>进程有5种正常终止以及3种异常终止方式。</p>
<p>正常终止方式：</p>
<ol>
<li>在main函数中调用<code>return</code>语句</li>
<li>调用<code>exit</code>函数，其操作包括调用各个终止函数（由<code>atexit</code>函数注册），然后关闭所有的标准I/O流。在<code>main</code>函数里调用<code>return</code>语句等效于调用<code>exit</code>函数。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>函数。函数不运行各个终止函数，也不冲洗I/O流，但是它关闭所有打开的文件流。</li>
<li>进程的最后一个线程在其启动例程中执行<code>return</code>语句，但是该线程的返回值不用作进程的返回值。当最后一个线程中其启动例程返回时，该进程以终止状态0返回。</li>
<li>进程的最后一个线程调用pthread_exit函数，进程的终止状态为0。</li>
</ol>
<p>异常终止方式：</p>
<ol>
<li>调用<code>abort</code>函数</li>
<li>进程收到信号</li>
<li>最后一个线程对”取消”请求作出响应。</li>
</ol>
<p>进程终止函数由<code>atexit</code>函数注册：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int atexit(void (*func)(void));</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear_onexit1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"On exit1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear_onexit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"On exit2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"At Exit Demo!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atexit(clear_onexit1) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't register `clear_onexit1`"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (atexit(clear_onexit1) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't register `clear_onexit1`"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (atexit(clear_onexit2) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't register `clear_onexit1`"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* _exit(0); */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;At Exit Demo!&#10;On exit2&#10;On exit1&#10;On exit1</span><br></pre></td></tr></table></figure>
<p>可以看到一个函数可以多次被注册，而且执行的顺序和注册的顺序相反。</p>
<p>在一个进程退出后，如果它有子进程，那么它的所有子进程由<code>init</code>进程收养。而如果一个子进程在退出后，父进程没有调用<code>wait</code>或者<code>waitpid</code>去获取子进程的退出状态，那么子进程就会成为僵尸进程。僵尸进程的地址空间被内核收回，所有打开的文件也被关闭，但是内核保存它的终止状态、进程ID以及CPU时间总量。</p>
<h3 id="wait__26amp_3B_waitpid"><a href="#wait__26amp_3B_waitpid" class="headerlink" title="wait &amp; waitpid"></a>wait &amp; waitpid</h3><p>上一小节说到如果子进程的终止状态没有被父进程通过<code>wait</code>或者<code>waitpid</code>得到，那么子进程就会变成僵尸进程。这两个函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p><code>wait</code>等待任意一个子进程终止，如果没有子进程，那么函数出错。子进程的终止状态被存入<code>statloc</code>指向的内存地址。</p>
<p><code>waitpid</code>可以等待特定进程终止。<code>options</code>可以进一步控制函数的行为：</p>
<ul>
<li>WCONTINUED：若实现支持作业控制，那么由<code>pid</code>指定的任一子进程在停止后已经继续，但其状态未报告，则返回其状态</li>
<li>WNOHANG：若由<code>pid</code>指定的子进程不是立即调用，则<code>waitpid</code>不阻塞，返回值为0。</li>
<li>WUNTRACED：若实现支持作业控制，而由<code>pid</code>指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告，则返回其状态。<code>WIFSTOPPED</code>宏确定返回值是否对应于一个停止的子进程。</li>
</ul>
<p>可以利用以下宏来检查返回的状态值：</p>
<ul>
<li>WIFEXITED(status)：若正常终止，返回值为真，此时可执行<code>WEXITSTATUS(status)</code>，获取子进程传送给<code>exit</code>或者<code>_exit</code>参数的低8位。</li>
<li>WIFSIGNALED(status)：若为异常终止子进程，返回真。此时可以执行<code>WTERMSIG(status)</code>获取终止的信号值，而且如果有产生终止进程的core文件，那么<code>WCOREDUMP(status)</code>返回真。</li>
<li>WIFSTOPPED(status)：若为当前暂停子进程的返回的状态，那么为真。此时可以执行<code>WSTOPSIG(status)</code>得到使得子进程暂停的信号。</li>
<li>WIFCONTINUED(status)：若在作业控制暂停后已经继续的子进程返回了状态，那么为真。</li>
</ul>
<p>这里给一个<code>waitpid</code>的例子，同时也说明如何<code>fork</code>两次来让子进程在退出后不会变成僵尸进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"fork error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent process id: %ld\n"</span>, (<span class="keyword">long</span>)getppid());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != pid) &#123;</span><br><span class="line">	perror(<span class="string">"wait error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Zach @ ZachMacbook in ~/Desktop/UNIX_Demos/proc_demos on git:master x [22:26:56] &#10;$ ./a.out &#10;&#10;# Zach @ ZachMacbook in ~/Desktop/UNIX_Demos/proc_demos on git:master x [22:26:59] &#10;$ parent process id: 1&#10;&#10;&#10;# Zach @ ZachMacbook in ~/Desktop/UNIX_Demos/proc_demos on git:master x</span><br></pre></td></tr></table></figure>
<p>可以看到第二个子进程的父进程后来变成了<code>init</code>进程，<code>init</code>进程不断地调用<code>wait</code>来等待其子进程退出，故而第二个子进程不会成为僵尸进程。输出中看到了在<code>./a.out</code>后输出了shell提示符，这是因为父进程首先退出了。</p>
<h1 id="u7ADE_u4E89_u6761_u4EF6"><a href="#u7ADE_u4E89_u6761_u4EF6" class="headerlink" title="竞争条件"></a>竞争条件</h1><p>前面提到过，在<code>fork</code>之后我们特意调用<code>sleep</code>函数然父进程睡眠，从而让子进程首先执行，这个方法是欠妥的，在一个非常繁忙的系统中，子进程不一定会先执行。这种不确定性就是进程的竞争条件。为了让子进程首先执行，我们需要一种特殊的手段。这里给出一种利用管道来实现进程同步的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_wait</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_parent</span><span class="params">(pid_t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_child</span><span class="params">(pid_t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wait_child</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wati_parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    tell_wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	charatatime(<span class="string">"output from child\n"</span>);</span><br><span class="line">	tell_parent(getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	wait_child();</span><br><span class="line">	charatatime(<span class="string">"output from parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (; *ptr != <span class="number">0</span>; ptr++) &#123;</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	putc(*ptr, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"pipe error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_parent</span><span class="params">(pid_t pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], <span class="string">"p"</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wait_child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> ((n = read(pipefd[<span class="number">0</span>], &amp;c, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"read error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">'p'</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"wait child error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tell_wait</code>初始化管道</li>
<li><code>wait_xxx</code>：从管道读端读一个字符，如果写端没有写，那么进程被内核投入睡眠</li>
<li><code>tell_xxx</code>：从管道写端写，唤醒被睡眠的读端进程吗，，从而达到进程同步的目的。</li>
</ul>
<h1 id="exec_u51FD_u6570"><a href="#exec_u51FD_u6570" class="headerlink" title="exec函数"></a>exec函数</h1><p><code>exec</code>函数族将<code>fork</code>的程序完全替换为另外一个程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ececle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0, char *const envp[]*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> agrv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>exec</code>函数族命名规则如下：</p>
<ul>
<li>含有<code>l</code>：程序参数以列表形式<code>arg0, arg1, ... argn, (char *)0</code>形式传入。</li>
<li>含有<code>v</code>：程序参数以向量形式<code>argv[]</code>传入，数组最后一个元素为NULL。</li>
<li>含有<code>p</code>：程序文件的路径名在环境变量<code>PATH</code>指定的路径下寻找</li>
<li>含有<code>e</code>：程序的环境变量由参数<code>envp</code>提供，否则继承父进程的环境变量</li>
<li>含有<code>f</code>：由文件描述符来代表程序文件。</li>
</ul>
<h1 id="u89E3_u91CA_u5668_u6587_u4EF6"><a href="#u89E3_u91CA_u5668_u6587_u4EF6" class="headerlink" title="解释器文件"></a>解释器文件</h1><p>解释器文件是一种文本文件，它的起始行格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! pathname [optional-arguement]</span><br></pre></td></tr></table></figure>
<p><code>pathname</code>一般为绝对路径。对这种文件的识别是由内核作为<code>exec</code>系统调用处理的一部分来完成的。内核使得调用<code>exec</code>函数的进程实际执行的不是这个解释器文件，而是在解释器文件第一行<code>pathname</code>所指定的文件，即解释器为<code>pathname</code>指定的文件，解释器文件为该文件。</p>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (execl(<span class="string">"./testinterp"</span>, <span class="string">"testinterp"</span>, <span class="string">"myarg1"</span>, <span class="string">"MY ARG2"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"execl error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"waitpid error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! /home/ubuntu/Desktop/UNIX-Demos/proc_demos/echoall foo</span><br></pre></td></tr></table></figure>
<p>echoall程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> **ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"argv[%d] : %s\n"</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for (ptr = environ; *ptr != 0; ptr++) &#123; */</span></span><br><span class="line">    <span class="comment">/* 	printf("%s\n", *ptr); */</span></span><br><span class="line">    <span class="comment">/* &#125; */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argv[0] : /home/ubuntu/UNIX-Demos/proc_demos/echoall&#10;argv[1] : foo&#10;argv[2] : ./testinterp&#10;argv[3] : myarg1&#10;argv[4] : MY ARG2&#10;ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$</span><br></pre></td></tr></table></figure>
<p>如一个<code>awk</code>脚本文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/awk -f&#10;# A awk example&#10;BEGIN &#123;&#10;      for (i=0; i&#60;ARGC; i++)&#10;          printf &#34;ARGV[%d] = %s\n&#34;, i, ARGV[i]&#10;      exit&#9;  &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行<code>./awkeample file1 file2</code>时，命令以以下方式被执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/awk -f /path/to/awkexample file1 file2</span><br></pre></td></tr></table></figure>
<p>于是<code>awk</code>程序执行该脚本输出所有参数的值。</p>
<h1 id="u8FDB_u7A0B_u8C03_u5EA6"><a href="#u8FDB_u7A0B_u8C03_u5EA6" class="headerlink" title="进程调度"></a>进程调度</h1><p>可以通过<code>nice</code>值来调控进程优先级，进程的<code>nice</code>值范围在[0, 2*NZERO-1]，<code>nice</code>值高的进程优先级越低（表示越友好）。进程可以通过<code>nice</code>函数接口来获得或者设置<code>nice</code>值，进程只能设置自己的<code>nice</code>值，而无法影响其他进程的<code>nice</code>值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>incr</code>参数被加到进程当前的nice值上，函数返回进程的<code>nice</code>值减去<code>NZERO</code>。所以如果函数返回-1，这时候函数调用可能是出错也可能调用正常，需要检查<code>errno</code>是否为0。<code>incr</code>置为0可以得到进程当前的<code>nice</code>减去<code>NZERO</code>的值。</p>
<p>系统的<code>NZERO</code>值可以通过<code>sysconf</code>函数得到。</p>
<h1 id="u8FDB_u7A0B_u65F6_u95F4"><a href="#u8FDB_u7A0B_u65F6_u95F4" class="headerlink" title="进程时间"></a>进程时间</h1><p>进程有三个时间：</p>
<ul>
<li>墙上时间：进程运行的总时间</li>
<li>用户CPU时间：进程运行用户指令的时间</li>
<li>系统CPU时间：程序调用系统调用后，内核执行系统服务所花去的时间。</li>
</ul>
<p>任何一个进程都可以通过调用<code>times</code>函数获得它自己以及已终止的子进程的上述三个值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> times(<span class="keyword">struct</span> tms *buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tms &#123;</span><br><span class="line">  <span class="keyword">clock_t</span> tms_utime;	<span class="comment">// user cpu time</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_stime;	<span class="comment">// system cpu time</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cutime; 	<span class="comment">// user cpu time, terminated children</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cstime;	<span class="comment">// system cpu time, terminated childrem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>times</code>函数返回进程的墙上时钟。注意这里的所有值都是绝对时间，而我们需要的是相对时间，于是就应该在某一个时刻调用<code>times</code>获得一个初始值，在另外一个时刻调用<code>times</code>获得一个最终值，其差即为我们所需。</p>
<p>所有由此函数返回的<code>clock_t</code>值都用<code>_SC_CLK_CTK</code>（由<code>sysconf</code>函数返回的每秒时钟滴答数）转换成秒数。</p>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(clock_t, <span class="keyword">struct</span> tms *, <span class="keyword">struct</span> tms *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;argc; i++)</span><br><span class="line">	do_cmd(argv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"normal termination, exit status = %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"abnormal termination, signal number = %d%s\n"</span>, WTERMSIG(status),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">	       WCOREDUMP(status) ? <span class="string">"(core file generated)"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span>	</span></span><br><span class="line">	<span class="string">""</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child stopped, signal number = %d\n"</span>, WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">  struct tms &#123;</span><br><span class="line">      clock_t tms_utime;    // user CPU time</span><br><span class="line">      clock_t tms_stime;    // system CPU time</span><br><span class="line">      clock_t tms_cutime;   // user CPU time, terminated children</span><br><span class="line">      clock_t tms_sutime;   // system CPU time, terminated children</span><br><span class="line">  &#125;</span><br><span class="line">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(clock_t real, <span class="keyword">struct</span> tms *tmsstart, <span class="keyword">struct</span> tms *tmsend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> clktck = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (clktck == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((clktck = sysconf(_SC_CLK_TCK)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"sysconf error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  real:  %7.2f\n"</span>, real / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  user:  %7.2f\n"</span>, (tmsend -&gt; tms_utime - tmsstart -&gt; tms_utime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  sys:  %7.2f\n"</span>, (tmsend -&gt; tms_stime - tmsstart -&gt; tms_stime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  child user:  %7.2f\n"</span>, (tmsend -&gt; tms_cutime - tmsstart -&gt; tms_cutime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  child sys:  %7.2f\n"</span>, (tmsend -&gt; tms_cstime - tmsstart -&gt; tms_cstime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> tms tmsstart, tmsend;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nCommand: %s\n"</span>, cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((start = times(&amp;tmsstart)) == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"times error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status = system(cmd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"system() error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((end = times(&amp;tmsend)) == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"times error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_times(end - start, &amp;tmsstart, &amp;tmsend);</span><br><span class="line">    pr_exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入与输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#34;sleep 5&#34; &#34;date&#34; &#34;man bash &#62; /dev/null&#34;&#10;&#10;Command: sleep 5&#10;  real:     5.02&#10;  user:     0.00&#10;  sys:     0.00&#10;  child user:     0.00&#10;  child sys:     0.00&#10;normal termination, exit status = 0&#10;&#10;Command: date&#10;Thu Oct 20 23:58:06 CST 2016&#10;  real:     0.02&#10;  user:     0.00&#10;  sys:     0.00&#10;  child user:     0.00&#10;  child sys:     0.00&#10;normal termination, exit status = 0&#10;&#10;Command: man bash &#62; /dev/null&#10;  real:     0.24&#10;  user:     0.00&#10;  sys:     0.00&#10;  child user:     0.28&#10;  child sys:     0.07&#10;normal termination, exit status = 0</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/12/libev源码浅析/" itemprop="url">
                  libev源码浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-12T00:00:00+08:00" content="2016-10-12">
              2016-10-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/12/libev源码浅析/" class="leancloud_visitors" data-flag-title="libev源码浅析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="libev"><a href="#libev" class="headerlink" title="libev"></a>libev</h1><p><code>libev</code>是一个高效的异步I/O库，采用了事件循环模型。用户向<code>libev</code>注册感兴趣的事件，如文件描述符可读等，当事件发生时，用户注册事件时的回调被调用。</p>
<p><code>libev</code>支持的事件有：</p>
<ol>
<li>文件描述符事件（描述符可读、可写），<code>ev_io</code></li>
<li>Linux的<code>inotify</code>接口，<code>ev_stat</code></li>
<li>信号事件，<code>ev_signal</code></li>
<li>定时事件，<code>ev_timer</code></li>
<li>周期事件，<code>ev_periodic</code></li>
<li>进程状态变化，<code>ev_child</code></li>
<li>事件循环自身的事件，<code>ev_idle</code>，<code>ev_prepare</code>和<code>ev_check</code></li>
</ol>
<h1 id="u4E00_u4E2A_u4F8B_u5B50"><a href="#u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="一个例子"></a>一个例子</h1><p>我们先看一个很简单的例子，然后用这个例子的执行流程去分析<code>libev</code>源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ev_io stdin_watcher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stdin_cb</span><span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (revents &amp; EV_READ) &#123;</span><br><span class="line">	n = read(w -&gt; fd, buf, <span class="number">128</span>);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"End of File\n"</span>);</span><br><span class="line">	    ev_io_stop(EV_A_ w);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"read: %s\n"</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> ev_loop *loop = EV_DEFAULT;</span><br><span class="line"></span><br><span class="line">    ev_io_init(&amp;stdin_watcher, stdin_cb, <span class="number">0</span>, EV_READ);</span><br><span class="line">    ev_io_start(loop, &amp;stdin_watcher);</span><br><span class="line"></span><br><span class="line">    ev_run(loop, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>libev</code>中一个事件有一个<code>watcher</code>表示，一个<code>watcher</code>的类型的格式为<code>ev_TYPE</code>。</p>
<p>每一个<code>watcher</code>有对应的初始化函数<code>ev_TYPE_init</code>，以<code>ev_io</code>为例，它的初始化函数原型为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ev_io_init(ev_io * w, void (*cb)(EV_P int revents), int fd, int events);</span><br><span class="line"></span><br><span class="line">#define EV_P struct ev_loop *loop,</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>注意的一点是，在<code>libev</code>的实现中，<code>ev_io_init</code>实际上是一个宏，但是我们把它理解成一个函数其实区别并不大。</p>
<p><code>ev_io_init</code>内部调用了两个函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ev_init(ev_watcher *w, void (*cb)(EV_P int revents));</span><br><span class="line"></span><br><span class="line">void ev_io_set(ev_io *w, int fd, int events);</span><br></pre></td></tr></table></figure>
<p>在初始化之后就调用<code>ev_io_start</code>在loop中注册事件，最后调用<code>ev_run</code>运行loop。</p>
<p>当标准输入可读时，我们注册的回调模块<code>stdin_watcher</code>会被调用，这时候我们就可以读取标准输入的数据，如果读到了<code>EOF</code>，那么就调用<code>ev_io_stop</code>停止这个监听事件。</p>
<h1 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h1><h3 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h3><p>以下的代码都是以2.0版本为准的。<br>在分析源码之前，我们先来看看<code>libev</code>中几个关键的数据结构。</p>
<h4 id="EV_WATCHER"><a href="#EV_WATCHER" class="headerlink" title="EV_WATCHER"></a>EV_WATCHER</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_watcher &#123;</span><br><span class="line">  <span class="keyword">int</span> active;</span><br><span class="line">  <span class="keyword">int</span> pending;</span><br><span class="line">  <span class="keyword">int</span> priority;</span><br><span class="line">  EV_COMMON				<span class="comment">/* void *data */</span></span><br><span class="line">  <span class="keyword">void</span> (*cb)(EV_P <span class="keyword">struct</span> ev_TYPE *w, <span class="keyword">int</span> revents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ev_watcher</code>相当于所有watcher的父类，它含有所有watcher的通用数据。拿<code>ev_io</code>来说，它的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_io &#123;</span><br><span class="line">  <span class="keyword">int</span> active;</span><br><span class="line">  <span class="keyword">int</span> pending;</span><br><span class="line">  <span class="keyword">int</span> priority;</span><br><span class="line">  <span class="function">EV_COMMON</span><br><span class="line">  <span class="title">void</span> <span class="params">(*cb)</span><span class="params">(EV_P <span class="keyword">struct</span> ev_TYPE *w <span class="keyword">int</span> revents)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个<code>ev_io</code>指针可以转换成一个<code>ev_watcher</code>指针，其他watcher类型也可以这么操作，所以<code>ev_watcher</code>相当于所有watcher的父类。</p>
<h4 id="ANFD"><a href="#ANFD" class="headerlink" title="ANFD"></a>ANFD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANFD &#123;</span><br><span class="line">  WL head;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> events;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> reify;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ev_watcher_list* WL;</span><br></pre></td></tr></table></figure>
<p><code>ANFD</code>表示一个文件描述符对应的事件。一个文件描述符可以有多个watcher，它们以链表的形式被组织起来，<code>head</code>即是链表的头。在<code>ev_loop</code>结构中，有一个<code>anfds</code>数组，每一个数组元素即数组下标对应的文件描述符的<code>ANFD</code>。</p>
<h4 id="ANPENDING"><a href="#ANPENDING" class="headerlink" title="ANPENDING"></a>ANPENDING</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANPENDING &#123;</span><br><span class="line">  W w;</span><br><span class="line">  <span class="keyword">int</span> events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ev_watcher* W;</span><br></pre></td></tr></table></figure>
<p>一个<code>ANPENDING</code>即一个待处理的事件。在<code>ev_loop</code>中，待处理的事件的组织形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pri_max |----|     |----|----|----|----|----|&#10;        |  --|---&#62; |    |    |    |    |    |&#10;   .    |----|     |----|----|----|----|----|&#10;   .    |    |&#9;&#9;&#9;ANPENDINGS&#10;   .    |----|    &#10;        |    |&#10;        |----|&#10;        |    |&#9;&#9;pendings[w-&#62;priority][w-&#62;pending]&#21363;&#23545;&#24212;watcher&#30340;ANPENDING&#10;        |----|&#10;        |    |&#10;        |----|&#10;        |    |&#10;pri_min |----|</span><br></pre></td></tr></table></figure>
<p><code>ev_loop</code>中每一个<code>ANPENDING</code>都有一个优先级，高优先级的事件在一个事件循环中首先被处理，但是低优先级事件也一定会被执行，只不过执行被延后了而已。</p>
<h4 id="EV_LOOP"><a href="#EV_LOOP" class="headerlink" title="EV_LOOP"></a>EV_LOOP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_loop &#123;</span><br><span class="line">  ev_tstamp ev_rt_now;</span><br><span class="line">  <span class="keyword">int</span> activent;</span><br><span class="line">  <span class="keyword">int</span> loop_count;</span><br><span class="line">  <span class="keyword">void</span> (*backend_modify)(EV_P <span class="keyword">int</span> fd, <span class="keyword">int</span> oev, <span class="keyword">int</span> nev);</span><br><span class="line">  <span class="keyword">void</span> (*backend_poll)(EV_P ev_tstamp timeout);</span><br><span class="line">  <span class="keyword">int</span> backend_fd;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> epoll_event *epoll_events;			<span class="comment">/* epoll for example */</span></span><br><span class="line">  <span class="keyword">int</span> epoll_eventmax;</span><br><span class="line">  </span><br><span class="line">  ANFD *anfds;</span><br><span class="line">  <span class="keyword">int</span> anfdmax;</span><br><span class="line">  </span><br><span class="line">  ANPENDING *pendings[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> pendingmax[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> pendingcnt[NUMPRI];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> *fdchanges;</span><br><span class="line">  <span class="keyword">int</span> fdchangemax;</span><br><span class="line">  <span class="keyword">int</span> fdchangecnt;</span><br><span class="line">  </span><br><span class="line">  WT *timers;</span><br><span class="line">  <span class="keyword">int</span> timermax;</span><br><span class="line">  <span class="keyword">int</span> timercnt;</span><br><span class="line">  </span><br><span class="line">  WT *periodics;</span><br><span class="line">  <span class="keyword">int</span> periodicmax;</span><br><span class="line">  <span class="keyword">int</span> periodiccnt;</span><br><span class="line">  </span><br><span class="line">  ev_idle **idles[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> idlemax[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> idlecnt[NUMPRI];</span><br><span class="line">  </span><br><span class="line">  ev_prepare **prepares;</span><br><span class="line">  <span class="keyword">int</span> preparemax;</span><br><span class="line">  <span class="keyword">int</span> preparecnt;</span><br><span class="line">  </span><br><span class="line">  ev_check **checks;</span><br><span class="line">  <span class="keyword">int</span> checkmax;</span><br><span class="line">  <span class="keyword">int</span> checkcnt;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ev_loop</code>显然是<code>libev</code>中最重要的结构，这里只列出部分元素的含义，其余部分等在分析对应源码时再作解释。</p>
<ul>
<li><code>ev_rt_now</code>：用于记录<code>ev_loop</code>的现在时间。<code>libev</code>中的计时器是基于真实时间的，如果你注册了一个超时事件，事件在一小时之后发生，之后你把系统时间设置成去年的某个事件，注册的事件也会在大约一小时后发生。</li>
<li><code>activent</code>：watcher必须保持<code>ev_loop</code>存活，这样每当一个事件发生时，watcher的回调函数才能被执行。为了保持<code>ev_loop</code>存活，watcher必须调用<code>ev_ref</code> 增加<code>activent</code>的个数，若<code>activent</code>值为0，那么这一次事件循环之后，<code>ev_loop</code>就被摧毁了。</li>
<li><code>loop_count</code>：记录了<code>ev_loop</code>事件迭代的次数</li>
<li><code>backend_modify</code>：<code>ev_loop</code>添加或修改事件监听的接口，依平台而定。<code>libev</code>支持的接口有<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
<li>port</li>
</ul>
</li>
<li><code>backend_poll</code>：<code>ev_loop</code>调用平台相关接口监听相关事件的接口。</li>
<li><code>backend_fd</code>：以<code>epoll</code>为例，其值为我们调用<code>epoll_create</code>接口创建的文件句柄。</li>
</ul>
<h3 id="ev_io"><a href="#ev_io" class="headerlink" title="ev_io"></a>ev_io</h3><p>首先来看一下<code>ev_io</code>的执行流程</p>
<h4 id="ev_io_start"><a href="#ev_io_start" class="headerlink" title="ev_io_start"></a>ev_io_start</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> noinline</span><br><span class="line"><span class="title">ev_io_start</span> <span class="params">(EV_P_ ev_io *w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = w-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expect_false (ev_is_active (w)))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  assert ((<span class="string">"ev_io_start called with negative fd"</span>, fd &gt;= <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  ev_start (EV_A_ (W)w, <span class="number">1</span>);</span><br><span class="line">  array_needsize (ANFD, anfds, anfdmax, fd + <span class="number">1</span>, anfds_init);</span><br><span class="line">  wlist_add (&amp;anfds[fd].head, (WL)w);</span><br><span class="line"></span><br><span class="line">  fd_change (EV_A_ fd, w-&gt;events &amp; EV_IOFDSET | <span class="number">1</span>);</span><br><span class="line">  w-&gt;events &amp;= ~EV_IOFDSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_speed</span><br><span class="line"><span class="title">ev_start</span> <span class="params">(EV_P_ W w, <span class="keyword">int</span> active)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  pri_adjust (EV_A_ w);</span><br><span class="line">  w-&gt;active = active;</span><br><span class="line">  ev_ref (EV_A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">wlist_add</span> <span class="params">(WL *head, WL elem)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  elem-&gt;next = *head;</span><br><span class="line">  *head = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">fd_change</span> <span class="params">(EV_P_ <span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> reify = anfds [fd].reify;</span><br><span class="line">  anfds [fd].reify |= flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expect_true (!reify))</span><br><span class="line">    &#123;</span><br><span class="line">      ++fdchangecnt;</span><br><span class="line">      array_needsize (<span class="keyword">int</span>, fdchanges, fdchangemax, fdchangecnt, EMPTY2);</span><br><span class="line">      fdchanges [fdchangecnt - <span class="number">1</span>] = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤为：</p>
<ol>
<li>执行<code>ev_start</code>，调整watcher的优先级，设置watcher的<code>active</code>标志同增加<code>ev_loop</code>的<code>activent</code>。</li>
<li>在文件描述符对应的watcher链表中插入该<code>ev_io</code>。</li>
<li>调用<code>fd_change</code>，它增加<code>fdchangecnt</code>的个数，同时记录发生变化的文件描述符，以便在事件循环的时候处理它。</li>
</ol>
<h4 id="ev_loop"><a href="#ev_loop" class="headerlink" title="ev_loop"></a>ev_loop</h4><p>在最新版本中<code>ev_loop</code>对应的函数为<code>ev_run</code>，由于我看的是2.0版本的，就用<code>ev_loop</code>来说明了。</p>
<h5 id="ev_loop-1"><a href="#ev_loop-1" class="headerlink" title="ev_loop"></a>ev_loop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">ev_loop</span> <span class="params">(EV_P_ <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  loop_done = flags &amp; (EVLOOP_ONESHOT | EVLOOP_NONBLOCK)</span><br><span class="line">            ? EVUNLOOP_ONE</span><br><span class="line">            : EVUNLOOP_CANCEL;</span><br><span class="line"></span><br><span class="line">  call_pending (EV_A); <span class="comment">/* in case we recurse, ensure ordering stays nice and clean */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> _WIN32</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (curpid)) <span class="comment">/* penalise the forking check even more */</span></span><br><span class="line">        <span class="keyword">if</span> (expect_false (getpid () != curpid))</span><br><span class="line">          &#123;</span><br><span class="line">            curpid = getpid ();</span><br><span class="line">            postfork = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_FORK_ENABLE</span></span><br><span class="line">      <span class="comment">/* we might have forked, so queue fork handlers */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (postfork))</span><br><span class="line">        <span class="keyword">if</span> (forkcnt)</span><br><span class="line">          &#123;</span><br><span class="line">            queue_events (EV_A_ (W *)forks, forkcnt, EV_FORK);</span><br><span class="line">            call_pending (EV_A);</span><br><span class="line">          &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue prepare watchers (and execute them) */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (preparecnt))</span><br><span class="line">        &#123;</span><br><span class="line">          queue_events (EV_A_ (W *)prepares, preparecnt, EV_PREPARE);</span><br><span class="line">          call_pending (EV_A);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expect_false (!activecnt))		<span class="comment">/* A */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* we might have forked, so reify kernel state if necessary */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (postfork))</span><br><span class="line">        loop_fork (EV_A);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* update fd-related kernel structures */</span></span><br><span class="line">      fd_reify (EV_A);						<span class="comment">/* B */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* calculate blocking time */</span></span><br><span class="line">      &#123;</span><br><span class="line">        ev_tstamp block;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expect_false (flags &amp; EVLOOP_NONBLOCK || idleall || !activecnt))</span><br><span class="line">          block = <span class="number">0.</span>; <span class="comment">/* do not block at all */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* update time to cancel out callback processing overhead */</span></span><br><span class="line">            time_update (EV_A_ <span class="number">1e100</span>);</span><br><span class="line"></span><br><span class="line">            block = MAX_BLOCKTIME;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timercnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)timers [<span class="number">0</span>])-&gt;at - mn_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">            <span class="keyword">if</span> (periodiccnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)periodics [<span class="number">0</span>])-&gt;at - ev_rt_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expect_false (block &lt; <span class="number">0.</span>)) block = <span class="number">0.</span>;</span><br><span class="line">          &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/* C */</span></span><br><span class="line">        ++loop_count;</span><br><span class="line">        backend_poll (EV_A_ block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update ev_rt_now, do magic */</span></span><br><span class="line">        time_update (EV_A_ block);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue pending timers and reschedule them */</span></span><br><span class="line">      timers_reify (EV_A); <span class="comment">/* relative timers called last */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">      periodics_reify (EV_A); <span class="comment">/* absolute timers called first */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_IDLE_ENABLE</span></span><br><span class="line">      <span class="comment">/* queue idle watchers unless other events are pending */</span></span><br><span class="line">      idle_reify (EV_A);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue check watchers, to be executed first */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (checkcnt))</span><br><span class="line">        queue_events (EV_A_ (W *)checks, checkcnt, EV_CHECK);</span><br><span class="line">	</span><br><span class="line">      call_pending (EV_A);				<span class="comment">/* E */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (expect_true (activecnt &amp;&amp; !loop_done));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop_done == EVUNLOOP_ONE)</span><br><span class="line">    loop_done = EVUNLOOP_CANCEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fd_reify"><a href="#fd_reify" class="headerlink" title="fd_reify"></a>fd_reify</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">fd_reify</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdchangecnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> fd = fdchanges [i];</span><br><span class="line">      ANFD *anfd = anfds + fd;</span><br><span class="line">      ev_io *w;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span> events = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (w = (ev_io *)anfd-&gt;head; w; w = (ev_io *)((WL)w)-&gt;next)</span><br><span class="line">        events |= (<span class="keyword">unsigned</span> <span class="keyword">char</span>)w-&gt;events;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_SELECT_IS_WINSOCKET</span></span><br><span class="line">      <span class="keyword">if</span> (events)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span> argp;</span><br><span class="line">          anfd-&gt;handle = _get_osfhandle (fd);</span><br><span class="line">          assert ((<span class="string">"libev only supports socket fds in this configuration"</span>, ioctlsocket (anfd-&gt;handle, FIONREAD, &amp;argp) == <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> o_events = anfd-&gt;events;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> o_reify  = anfd-&gt;reify;</span><br><span class="line"></span><br><span class="line">        anfd-&gt;reify  = <span class="number">0</span>;</span><br><span class="line">        anfd-&gt;events = events;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o_events != events || o_reify &amp; EV_IOFDSET)</span><br><span class="line">          backend_modify (EV_A_ fd, o_events, events);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fdchangecnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="epoll_poll"><a href="#epoll_poll" class="headerlink" title="epoll_poll"></a>epoll_poll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">epoll_poll</span> <span class="params">(EV_P_ ev_tstamp timeout)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* D */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax, (<span class="keyword">int</span>)<span class="built_in">ceil</span> (timeout * <span class="number">1000.</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expect_false (eventcnt &lt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        syserr (<span class="string">"(libev) epoll_wait"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eventcnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> epoll_event *ev = epoll_events + i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> fd   = ev-&gt;data.u64;</span><br><span class="line">      <span class="keyword">int</span> got  = (ev-&gt;events &amp; (EPOLLOUT | EPOLLERR | EPOLLHUP) ? EV_WRITE : <span class="number">0</span>)</span><br><span class="line">               | (ev-&gt;events &amp; (EPOLLIN  | EPOLLERR | EPOLLHUP) ? EV_READ  : <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">int</span> want = anfds [fd].events;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expect_false (got &amp; ~want))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* we received an event but are not interested in it, try mod or del */</span></span><br><span class="line">          ev-&gt;events = (want &amp; EV_READ  ? EPOLLIN  : <span class="number">0</span>)</span><br><span class="line">                     | (want &amp; EV_WRITE ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          epoll_ctl (backend_fd, want ? EPOLL_CTL_MOD : EPOLL_CTL_DEL, fd, ev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      fd_event (EV_A_ fd, got);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* if the receive array was full, increase its size */</span></span><br><span class="line">  <span class="keyword">if</span> (expect_false (eventcnt == epoll_eventmax))</span><br><span class="line">    &#123;</span><br><span class="line">      ev_free (epoll_events);</span><br><span class="line">      epoll_eventmax = array_nextsize (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> epoll_event), epoll_eventmax, epoll_eventmax + <span class="number">1</span>);</span><br><span class="line">      epoll_events = (<span class="keyword">struct</span> epoll_event *)ev_malloc (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> epoll_event) * epoll_eventmax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="call_pending"><a href="#call_pending" class="headerlink" title="call_pending"></a>call_pending</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_speed</span><br><span class="line"><span class="title">call_pending</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pri;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (pri = NUMPRI; pri--; )</span><br><span class="line">    <span class="keyword">while</span> (pendingcnt [pri])</span><br><span class="line">      &#123;</span><br><span class="line">        ANPENDING *p = pendings [pri] + --pendingcnt [pri];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expect_true (p-&gt;w))</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/*assert (("non-pending watcher on pending list", p-&gt;w-&gt;pending));*/</span></span><br><span class="line"></span><br><span class="line">            p-&gt;w-&gt;pending = <span class="number">0</span>;</span><br><span class="line">            EV_CB_INVOKE (p-&gt;w, p-&gt;events);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体部分就在<code>do {} while</code>这个循环里面。</p>
<p>我们先略过不和<code>ev_io</code>相关的部分，只看代码中标注（[A-E]）位置对应的部分：</p>
<ul>
<li><code>A</code>：检查<code>activent</code>值是否为0，若是，那么loop退出事件循环</li>
<li><code>B</code>：调用<code>fd_reify</code>函数，该函数遍历<code>fdchanges</code>数组，对于每一个描述符，如果其对应的事件有改变或者新增加的描述符，那么就调用<code>backend_modify</code>修改或添加文件描述符的事件。</li>
<li><code>C</code>：增加事件循环的迭代次数，然后调用<code>backend_poll</code>调用相关平台的接口监听文件描述符事件。</li>
<li><code>D</code>：以<code>epoll</code>为例，<code>backend_poll</code>的实现为<code>epoll_poll</code>。<code>epoll_poll</code>调用<code>epoll_wait</code>，发生的事件被存放在<code>epoll_events</code>数组中，对于一个事件，得到的事件不是我们想要的事件，那么就修改或删除文件描述符对应的监听事件。然后调用<code>fd_event</code>函数，把得到文件描述符事件加到<code>ev_loop</code>的对应的<code>pendings</code>列表中。在<code>fd_event</code>之后，如果发现<code>epoll_eventmax == eventcnt</code>，那么就增大<code>epoll_events</code>数组元素的个数，以便下一次能够接收更多发生的文件描述符事件。</li>
<li><code>E</code>：调用<code>call_pending</code>函数:<ol>
<li>按照优先级从大到小，遍历<code>pendings</code>数组</li>
<li>如果对应的<code>pendingcnt[pri]</code>值大于0，即对应优先级有事件待处理，依次去对应<code>ANPENDING</code>列表的元素</li>
<li>对取到的<code>ANPENDING</code>，用<code>EV_CB_INVOKE</code>宏调用其对应watcher的回调函数。</li>
</ol>
</li>
</ul>
<h4 id="ev_io_stop"><a href="#ev_io_stop" class="headerlink" title="ev_io_stop"></a>ev_io_stop</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> noinline</span><br><span class="line"><span class="title">ev_io_stop</span> <span class="params">(EV_P_ ev_io *w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* A */</span></span><br><span class="line">  clear_pending (EV_A_ (W)w);</span><br><span class="line">  <span class="keyword">if</span> (expect_false (!ev_is_active (w)))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  assert ((<span class="string">"ev_io_start called with illegal fd (must stay constant after start!)"</span>, w-&gt;fd &gt;= <span class="number">0</span> &amp;&amp; w-&gt;fd &lt; anfdmax));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* B */</span></span><br><span class="line">  wlist_del (&amp;anfds[w-&gt;fd].head, (WL)w);</span><br><span class="line">  <span class="comment">/* C */</span></span><br><span class="line">  ev_stop (EV_A_ (W)w);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* D */</span></span><br><span class="line">  fd_change (EV_A_ w-&gt;fd, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="clear_pending"><a href="#clear_pending" class="headerlink" title="clear_pending"></a>clear_pending</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_speed</span><br><span class="line"><span class="title">clear_pending</span> <span class="params">(EV_P_ W w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w-&gt;pending)</span><br><span class="line">    &#123;</span><br><span class="line">      pendings [ABSPRI (w)][w-&gt;pending - <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">      w-&gt;pending = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ev_stop"><a href="#ev_stop" class="headerlink" title="ev_stop"></a>ev_stop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">ev_stop</span> <span class="params">(EV_P_ W w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ev_unref (EV_A);</span><br><span class="line">  w-&gt;active = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A</code>：从<code>pendings</code>列表中删除对应的watcher</li>
<li><code>B</code>：从文件描述符对应的watcher链表<code>anfds[w-&gt;fd]</code>中删除将被停止的watcher。</li>
<li><code>C</code>：调用<code>ev_stop</code>，减少<code>ev_loop</code>中<code>activent</code>的个数（通过<code>ev_unref</code>实现），讲watcher的<code>active</code>标志置为０。</li>
<li><code>D</code>：调用<code>fd_change</code>函数修改对应的<code>fdchanges</code>数组和<code>fdchangecnt</code>变量，以便在下一次事件循环中修改文件描述符的监听事件。如果文件描述符没有任何监听事件，那么在文件描述符的epoll事件会在<code>epoll_poll</code>函数中被删除。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expect_false (got &amp; ~want))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* we received an event but are not interested in it, try mod or del */</span></span><br><span class="line">        ev-&gt;events = (want &amp; EV_READ  ? EPOLLIN  : <span class="number">0</span>)</span><br><span class="line">                     | (want &amp; EV_WRITE ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        epoll_ctl (backend_fd, want ? EPOLL_CTL_MOD : EPOLL_CTL_DEL, fd, ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ev_timer__26amp_3B_ev_periodic"><a href="#ev_timer__26amp_3B_ev_periodic" class="headerlink" title="ev_timer &amp; ev_periodic"></a>ev_timer &amp; ev_periodic</h3><p><code>ev_timer</code>和<code>ev_periodic</code>都可以用来设置超时和周期事件，不同的是，<code>ev_periodic</code>可以设置一个回调函数，在每一次周期完成后这个回调函数被调用并返回一个时间节点，该节点是下一次事件被触发的时间。</p>
<p><code>ev_loop</code>结构内有两个元素：</p>
<ul>
<li>timers</li>
<li>periodics</li>
</ul>
<p><code>timer</code>和<code>periodic</code>的结构分别为：</p>
<h5 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_timer &#123;</span><br><span class="line">  EV_WATCHER(ev_timer)</span><br><span class="line">  ev_tstamp at;</span><br><span class="line">  ev_tstamp repeat;			<span class="comment">/* 多少时间后重复执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="periodic"><a href="#periodic" class="headerlink" title="periodic"></a>periodic</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_periodic &#123;</span><br><span class="line">  EV_WATCHER(ev_periodic)</span><br><span class="line">  ev_tstamp offset;</span><br><span class="line">  ev_tstamp interval;</span><br><span class="line">  ev_tstamp (*reschedule_cb)(<span class="keyword">struct</span> ev_periodic *w, ev_tstamp now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们分别存储了在<code>ev_loop</code>中注册的所有<code>ev_timer</code>和<code>ev_periodic</code>。它们都以最小堆的形式被组织，堆顶是离现在最近的timer事件。每一次事件循环，在调用<code>backend_poll</code>之前，首先取两个堆顶的元素，取时间较小的那个作为此次<code>backend_poll</code>的超时事件。在<code>backend_poll</code>返回之后调用<code>timers_reify</code>和<code>periodics_reify</code>调整堆，同时把已经发生的超时和定时事件加入到<code>pendings</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (expect_false (flags &amp; EVLOOP_NONBLOCK || idleall || !activecnt))</span><br><span class="line">          block = <span class="number">0.</span>; <span class="comment">/* do not block at all */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* update time to cancel out callback processing overhead */</span></span><br><span class="line">            time_update (EV_A_ <span class="number">1e100</span>);</span><br><span class="line"></span><br><span class="line">            block = MAX_BLOCKTIME;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timercnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)timers [<span class="number">0</span>])-&gt;at - mn_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">            <span class="keyword">if</span> (periodiccnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)periodics [<span class="number">0</span>])-&gt;at - ev_rt_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expect_false (block &lt; <span class="number">0.</span>)) block = <span class="number">0.</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        ++loop_count;</span><br><span class="line">        backend_poll (EV_A_ block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update ev_rt_now, do magic */</span></span><br><span class="line">        time_update (EV_A_ block);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue pending timers and reschedule them */</span></span><br><span class="line">      timers_reify (EV_A); <span class="comment">/* relative timers called last */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">      periodics_reify (EV_A); <span class="comment">/* absolute timers called first */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>time_update</code>：主要用于更新<code>ev_loop</code>的当前时间。</li>
<li><code>backend_fudge</code>：时间误差变量</li>
</ul>
<p><code>time_reify</code>和<code>periodic_reify</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">timers_reify</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (timercnt &amp;&amp; ((WT)timers [<span class="number">0</span>])-&gt;at &lt;= mn_now)</span><br><span class="line">    &#123;</span><br><span class="line">      ev_timer *w = (ev_timer *)timers [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*assert (("inactive timer on timer heap detected", ev_is_active (w)));*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* first reschedule or stop timer */</span></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;repeat)</span><br><span class="line">        &#123;</span><br><span class="line">          assert ((<span class="string">"negative ev_timer repeat value found while processing timers"</span>, w-&gt;repeat &gt; <span class="number">0.</span>));</span><br><span class="line"></span><br><span class="line">          ((WT)w)-&gt;at += w-&gt;repeat;</span><br><span class="line">          <span class="keyword">if</span> (((WT)w)-&gt;at &lt; mn_now)</span><br><span class="line">            ((WT)w)-&gt;at = mn_now;</span><br><span class="line"></span><br><span class="line">          downheap (timers, timercnt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ev_timer_stop (EV_A_ w); <span class="comment">/* nonrepeating: stop timer */</span></span><br><span class="line"></span><br><span class="line">      ev_feed_event (EV_A_ (W)w, EV_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">periodics_reify</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* A */</span></span><br><span class="line">  <span class="keyword">while</span> (periodiccnt &amp;&amp; ((WT)periodics [<span class="number">0</span>])-&gt;at &lt;= ev_rt_now)</span><br><span class="line">    &#123;</span><br><span class="line">      ev_periodic *w = (ev_periodic *)periodics [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*assert (("inactive timer on periodic heap detected", ev_is_active (w)));*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* first reschedule or stop timer */</span></span><br><span class="line">    <span class="comment">/* B */</span></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;reschedule_cb)</span><br><span class="line">        &#123;</span><br><span class="line">          ((WT)w)-&gt;at = w-&gt;reschedule_cb (w, ev_rt_now + TIME_EPSILON);</span><br><span class="line">          assert ((<span class="string">"ev_periodic reschedule callback returned time in the past"</span>, ((WT)w)-&gt;at &gt; ev_rt_now));</span><br><span class="line">          downheap (periodics, periodiccnt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (w-&gt;interval)</span><br><span class="line">        &#123;</span><br><span class="line">          ((WT)w)-&gt;at = w-&gt;offset + <span class="built_in">ceil</span> ((ev_rt_now - w-&gt;offset) / w-&gt;interval) * w-&gt;interval;</span><br><span class="line">          <span class="keyword">if</span> (((WT)w)-&gt;at - ev_rt_now &lt;= TIME_EPSILON) ((WT)w)-&gt;at += w-&gt;interval;</span><br><span class="line">          assert ((<span class="string">"ev_periodic timeout in the past detected while processing timers, negative interval?"</span>, ((WT)w)-&gt;at &gt; ev_rt_now));</span><br><span class="line">          downheap (periodics, periodiccnt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ev_periodic_stop (EV_A_ w); <span class="comment">/* nonrepeating: stop timer */</span></span><br><span class="line"></span><br><span class="line">      ev_feed_event (EV_A_ (W)w, EV_PERIODIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>periodics_reify</code>例子（<code>timers_reify</code>类似）：</p>
<ol>
<li>如果堆顶的时间比现在的事件小，那么取堆顶，否则函数返回</li>
<li>如果是周期事件，即<code>reschedule_cb</code>不为空或者<code>interval</code>不为0，那么计算出下一次事件触发的事件，调整堆，否则停止这个timer事件。</li>
<li>把这一次触发的事件加入到<code>pendings</code>中，等待<code>call_pending</code>被调用而触发回调函数。</li>
</ol>
<h3 id="ev_signal"><a href="#ev_signal" class="headerlink" title="ev_signal"></a>ev_signal</h3><p><code>libev</code>加入了对信号事件的支持。当一个信号发生时，回调函数不会像在UNIX系统中一样被立刻调用，而是在下一个事件循环中被处理。</p>
<p>先看看信号事件在<code>libev</code>中的组织形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">     |--------|     |----|----|----|----|----|&#10;     | head   |---&#62; |    |    |    |    |    |&#10;.    |        |     |----|----|----|----|----|&#10;.    | gotsig |&#9;&#9;&#9;EV_WATCHERS&#10;.    |--------|    &#10;     |        |&#10;     |        |&#10;     |        |&#9;&#10;     |--------|&#10;     |        |&#10;     |        |&#10;     |        |&#10;     |--------|</span><br></pre></td></tr></table></figure>
<p>相关的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANSIG &#123;</span><br><span class="line">  WL *head;</span><br><span class="line">  <span class="keyword">sig_atomic_t</span> <span class="keyword">volatile</span> gotsig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当某一个信号被触发时，信号对应的<code>WL</code>中所有的回调函数都会被依次执行。</p>
<p><code>libev</code>利用管道实现了异步信号处理。一个loop在调用<code>loop_init</code>初始化之后，调用<code>siginit</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> noinline</span><br><span class="line"><span class="title">siginit</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  fd_intern (sigpipe [<span class="number">0</span>]);</span><br><span class="line">  fd_intern (sigpipe [<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  ev_io_set (&amp;sigev, sigpipe [<span class="number">0</span>], EV_READ);</span><br><span class="line">  ev_io_start (EV_A_ &amp;sigev);</span><br><span class="line">  ev_unref (EV_A); <span class="comment">/* child watcher should not keep loop alive */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看<code>siginit</code>往loop中注册一个<code>ev_io</code>，用于监听管道中<code>pipe[0]</code>的读事件。</p>
<p>用户在注册一个信号事件时，调用<code>ev_signal_init</code>设置信号的回调处理，监听的信号值等。然后调用<code>ev_signal_start</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...  </span><br><span class="line">  ev_start (EV_A_ (W)w, <span class="number">1</span>);</span><br><span class="line">  wlist_add (&amp;signals [w-&gt;signum - <span class="number">1</span>].head, (WL)w);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!((WL)w)-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line">      signal (w-&gt;signum, sighandler);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">struct</span> sigaction sa;</span><br><span class="line">      sa.sa_handler = sighandler;</span><br><span class="line">      sigfillset (&amp;sa.sa_mask);</span><br><span class="line">      sa.sa_flags = SA_RESTART; <span class="comment">/* if restarting works we save one iteration */</span></span><br><span class="line">      sigaction (w-&gt;signum, &amp;sa, <span class="number">0</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>首先讲watcher加入对应信号的链表，然后如果是链头，那么说明对应的信号处理函数未被注册到内核中，于是初始化一个<code>sigaction</code>，注册对应的信号处理函数。<code>sighandler</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">sighandler</span> <span class="params">(<span class="keyword">int</span> signum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line">  signal (signum, sighandler);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  signals [signum - <span class="number">1</span>].gotsig = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!gotsig)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> old_errno = errno;</span><br><span class="line">      gotsig = <span class="number">1</span>;</span><br><span class="line">      write (sigpipe [<span class="number">1</span>], &amp;signum, <span class="number">1</span>);</span><br><span class="line">      errno = old_errno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当一个信号发生时，<code>libev</code>设置信号的对应<code>gosig</code>为1，然后往管道离写信号值，这样先前注册的读管道监视器<code>sigev</code>就被激活，其对应的回调函数被在下一个事件循环被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">sigcb</span> <span class="params">(EV_P_ ev_io *iow, <span class="keyword">int</span> revents)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> signum;</span><br><span class="line"></span><br><span class="line">  read (sigpipe [<span class="number">0</span>], &amp;revents, <span class="number">1</span>);</span><br><span class="line">  gotsig = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (signum = signalmax; signum--; )</span><br><span class="line">    <span class="keyword">if</span> (signals [signum].gotsig)</span><br><span class="line">      ev_feed_signal_event (EV_A_ signum + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这之后所有的信号事件被加入<code>pendings</code>中，当<code>call_pending</code>被调用时，信号事件的回调事件也就得到了处理。</p>
<h3 id="ev_prepare__26amp_3B_ev_check"><a href="#ev_prepare__26amp_3B_ev_check" class="headerlink" title="ev_prepare &amp; ev_check"></a>ev_prepare &amp; ev_check</h3><p><code>ev_prepare</code>和<code>ev_check</code>是<code>ev_loop</code>事件循环自身的事件。<code>ev_prepare</code>在<code>ev_loop</code>收集事件前被调用；<code>ev_check</code>在收集完事件后被调用。他们都能唤醒和休眠任意个监视器，以实现一些特定的事件循环行为。</p>
<p><code>ev_prepare</code>和<code>ev_check</code>的结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_TYPE &#123;</span><br><span class="line">  EV_WATCHER(TYPE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ev_stat"><a href="#ev_stat" class="headerlink" title="ev_stat"></a>ev_stat</h3><p><code>ev_stat</code>相关接口没有看，因为对<code>inotify</code>和<code>kqueue</code>接口还不是很熟悉（逃</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/08/进程/" itemprop="url">
                  进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-08T00:00:00+08:00" content="2016-10-08">
              2016-10-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/08/进程/" class="leancloud_visitors" data-flag-title="进程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u8FDB_u7A0B_u7684_u6982_u5FF5"><a href="#u8FDB_u7A0B_u7684_u6982_u5FF5" class="headerlink" title="进程的概念"></a>进程的概念</h1><p>进程是一个可执行程序的实例。而程序包含了一系列的文件信息，这些信息描述了如何在运行时创建一个进程，其所包括的内容有：</p>
<ul>
<li>二进制格式标识：用于描述可执行文件格式的元信息，内核用它来解释文件中的其他信息。Linux采用<code>ELF文件系统</code>。</li>
<li>机器语言指令</li>
<li>程序入口地址</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面常量值（如字符串）.</li>
<li>符号表及重定位表</li>
<li>共享库和动态链接库的信息</li>
<li>其他信息，用以描述如何创建进程。</li>
</ul>
<p>可以用一个程序创建许多个进程，反过来，许多进程运行的可以是同一个程序。从内核角度来说，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码以及代码所使用的变量，而内核数据结构则用于维护进程状态信息，如进程号、虚拟内存表、进程打开的文件描述符、信号传递及处理的有关信息、当前工作目录、进程资源使用及限制和其他大量信息。</p>
<p>一个进程运行时的信息可以在<code>/proc/{PID}/</code>目录下看到。</p>
<h1 id="u8FDB_u7A0B_u5185_u5B58_u5E03_u5C40"><a href="#u8FDB_u7A0B_u5185_u5B58_u5E03_u5C40" class="headerlink" title="进程内存布局"></a>进程内存布局</h1><p>每个进程所分配的内存由许多部分组成，通常称之为<code>段</code>，各个段如下：</p>
<ul>
<li>文本段：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令；同时，文本段是共享的，从而可以让一份程序代码的拷贝映射到所有共享这份代码的进程中，从而让多个进程运行同一个程序。</li>
<li>初始化数据段：包含显示初始化的全局变量和静态变量。</li>
<li>未初始化的数据段：包含了为进程显示初始化的全局变量和静态变量，程序启动之前，系统将本段内所有内存初始化为0，该段常被成为BSS段。为初始化和初始化的变量分开存放主要是由于没有必要为未初始化的变量在文件中分配存储空间，相反，可执行文件只要记录未初始化数据段的位置及其所需要的大小，知道运行时再由程序加载器来分配空间。</li>
<li>栈是一个动态增长和收缩的段，由<code>栈帧</code>组成。系统为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（即自动变量）、实参和返回值。</li>
<li>堆是可在运行时动态进行内存分配的一块区域。堆顶称为<code>program break</code>。</li>
</ul>
<p>大多数UNIX实现（包括Linux）中C语言编程环境提供了3个全局变量<code>etext</code>、<code>edata</code>、<code>end</code>，它们分别用来标识<code>文本段</code>、<code>初始化数据段</code>、<code>非初始化数据段</code>结尾处的下一个字节位置。在x86-32体系结构进程在内存中的布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#34394;&#25311;&#20869;&#23384;&#22320;&#22336;&#65288;&#20174;&#19979;&#24448;&#19978;&#22686;&#38271;&#65289;&#10;          |----------------------------------------&#10;          |&#9;     Kernel&#26144;&#23556;&#21040;&#36827;&#31243;&#34394;&#25311;&#20869;&#23384;&#65292;&#21306;&#22495;          &#10;          |      &#25552;&#20379;&#20102;&#20869;&#23384;&#31526;&#21495;&#30340;&#22320;&#22336;&#12290;&#65288;/proc/kallsyms) &#65288;&#26080;&#27861;&#20351;&#29992;&#65289;&#10;          |----------------------------------------&#10;          |&#9;&#9;argv, environ&#9;&#9;&#9;    &#10;          |----------------------------------------&#26632;&#39030;&#10;          |&#9;&#9;&#26632;&#65288;&#21521;&#19979;&#22686;&#38271;&#65289;&#10;          |----------------------------------------&#10;          |&#10;          |&#9;&#9;&#26410;&#20998;&#37197;&#30340;&#20869;&#23384;&#65288;&#26080;&#27861;&#20351;&#29992;&#65289;&#10;          |&#10;          |----------------------------------------&#31243;&#24207;&#20013;&#26029;&#10;          |     &#22534;&#65288;&#21521;&#19978;&#22686;&#38271;&#65289;&#10;          |----------------------------------------end&#10;          |     &#26410;&#21021;&#22987;&#21270;&#30340;&#25968;&#25454;&#65288;bss&#65289;&#10;          |----------------------------------------edata&#10;          |     &#21021;&#22987;&#21270;&#30340;&#25968;&#25454;&#10;          |----------------------------------------etext&#10;          |     &#25991;&#26412;&#27573;&#10;          |-----------------------------------------0x08048000&#10;          |     (&#26080;&#27861;&#20351;&#29992;)&#10;          |-----------------------------------------0x00000000</span><br></pre></td></tr></table></figure>
<p>上述布局存在于虚拟内存之中。</p>
<h1 id="u547D_u4EE4_u884C_u53C2_u6570_u548C_u73AF_u5883_u53D8_u91CF"><a href="#u547D_u4EE4_u884C_u53C2_u6570_u548C_u73AF_u5883_u53D8_u91CF" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h1><p>上一节的内存布局图中，<code>argv和eviron</code>那一部分存储了进程启动时用户输入的命令行参数和环境变量，关于命令行参数，即<code>main</code>函数的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv[%d] = %s\n"</span>, i, argv[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于环境变量，每一个进程都有与之相关联的环境变量列表，其结构式字符串数组，每一个字符串以<code>name=value</code>形式定义。新进程在创建之时，会继承其父进程的环境变量副本，这是一种原始的进程间通信方式，却颇为有用。</p>
<p>关于环境变量的几个接口和变量如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;		<span class="comment">// 全局变量，用于访问进程的环境变量，每一个以`name=value`的形式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;			<span class="comment">// 成功返回环境变量字符串，否则返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;			   <span class="comment">// 0表示公共，否则失败。`string`为`name=value`形式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearenv</span><span class="params">()</span></span>;		<span class="comment">// 0表示成功，否则失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意以下函数不用`name=value`形式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;		<span class="comment">// 0表示成功，-1表示失败</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;		<span class="comment">// 0表示成功，-1表示失败。</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>putenv</code>不为字符串分配一个缓冲区，它仅仅改变对应的<code>environ</code>数组中的对应指针，因此<code>string</code>参数应该是一个静态或者全局变量，而不是自动变量。</p>
<p><code>setenv</code>会为字符串分配一个内存缓冲区，并将name和value的字符串复制到该缓冲区中，以此来创建一个新的环境变量。若<code>overwrite</code>值非0，那么<code>setenv</code>总是覆写原来的环境变量；否则，若环境变量已经存在，那么它不会改变。</p>
<p><code>clearenv</code>仅仅是把<code>environ</code>置为NULL，在某些时候可能会导致内存泄漏。</p>
<h3 id="u4E00_u4E2A_u4F8B_u5B50_uFF1A"><a href="#u4E00_u4E2A_u4F8B_u5B50_uFF1A" class="headerlink" title="一个例子："></a>一个例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errExit(fmt, ...) do &#123;fprintf(stderr, fmt, ##__VA_ARGS__); perror(<span class="string">""</span>); exit(-<span class="number">1</span>);&#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    clearenv();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;argc; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (putenv(argv[i]) != <span class="number">0</span>)</span><br><span class="line">	    errExit(<span class="string">"putenv: %s"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">"GREET"</span>, <span class="string">"Hello world"</span>, <span class="number">0</span>) == -<span class="number">1</span>)</span><br><span class="line">	errExit(<span class="string">"setenv"</span>);</span><br><span class="line"></span><br><span class="line">    unsetenv(<span class="string">"BYE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep=environ; *ep!=<span class="literal">NULL</span>; ep++)</span><br><span class="line">	<span class="built_in">puts</span>(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out G=&#34;HAGA&#34;&#10;G=HAGA&#10;GREET=Hello world&#10;&#10;ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out G=&#34;HAGA&#34; GREET=&#34;Hello&#34;&#10;G=HAGA&#10;GREET=Hello</span><br></pre></td></tr></table></figure>
<h1 id="u975E_u5C40_u90E8_u8DF3_u8F6C"><a href="#u975E_u5C40_u90E8_u8DF3_u8F6C" class="headerlink" title="非局部跳转"></a>非局部跳转</h1><p>C语言中的<code>goto</code>语句允许我们进行语句跳转，但是这仅仅局限在同一个函数中。虽然跳转会让我们的代码变得难以维护，看着就头大，但是有时候有这样一个语句还是能解决很大的问题的，前提是不要滥用。为了能够解决非局部跳转的问题，UNIX系统提供了两个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjump</span><span class="params">(jump_buf env)</span></span>;		<span class="comment">// 0表示初始化操作，非0时返回的是`longjmp`设定的`val`值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jump_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>setjmp</code>为后续的<code>longjmp</code>设立了跳转目标，<code>setjmp</code>把当前进程环境的各种信息保存到<code>env</code>参数中，调用<code>longjmp</code>时必须指定相同的<code>env</code>变量，一般将<code>env</code>设定为全局变量。</p>
<h3 id="u4E00_u4E2A_u4F8B_u5B50"><a href="#u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    longjmp(env, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">	longjmp(env, <span class="number">1</span>);</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(env)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Calling f1() after initial setjmp()\n"</span>);</span><br><span class="line">	f1(argc);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We jumped back from f1()\n"</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We jumped back from f2()\n"</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out &#10;Calling f1() after initial setjmp()&#10;We jumped back from f1()&#10;&#10;ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out  ss&#10;Calling f1() after initial setjmp()&#10;We jumped back from f2()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/04/epoll入门/" itemprop="url">
                  epoll入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-04T00:00:00+08:00" content="2016-10-04">
              2016-10-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/10/04/epoll入门/" class="leancloud_visitors" data-flag-title="epoll入门">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p><code>epoll</code>是linux内核的可扩展I/O机制，旨在替代POSIX的<code>select</code>和<code>poll</code>函数，让需要大量文件操作符的程序拥有更佳的性能。</p>
<h3 id="epoll_u63A5_u53E3"><a href="#epoll_u63A5_u53E3" class="headerlink" title="epoll接口"></a>epoll接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>epoll_create</code>创建一个epoll的句柄，参数<code>size</code>告知内核这个epoll需要监听的I/O事件的个数。函数返回一个描述符，在使用完epoll以后，我们需要手动关闭这个描述符，否则可能导致描述符耗尽。</li>
</ul>
<ul>
<li><p><code>epoll_ctl</code>用来操纵epoll所监听的事件，参数<code>op</code>表示这一次操作，其值：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的事件到epoll中</li>
<li>EPOLL_CTL_DEL：从epoll中删除一个事件</li>
<li>EPOLL_CTL_MOD：修改之前注册的一个事件</li>
</ul>
<p><code>epoll_event</code>是对应的描述符的事件的数据结构，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">               <span class="keyword">void</span>    *ptr;</span><br><span class="line">               <span class="keyword">int</span>      fd;</span><br><span class="line">               <span class="keyword">uint32_t</span> u32;</span><br><span class="line">               <span class="keyword">uint64_t</span> u64;</span><br><span class="line">           &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> epoll_event &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>epoll_event</code>中events是以下几个值的按位或的集合：</p>
<ul>
<li>EPOLLIN：对应的描述符可读</li>
<li>EPOLLOUT：对应的描述符可写</li>
<li>EPOLLERR：对应的描述符发生错误</li>
<li>EPOLLRDHUP：TCP套接字对端被关闭或者用<code>shutdown</code>函数关闭了写半部。</li>
<li>EPOLLPRI：有紧急数据可读</li>
<li>EPOLLHUP：对应的文件描述符被挂断</li>
<li>EPOLLET：将EPOLL设为边缘触发</li>
<li>EPOLLONESHOT：只监听一次事件，当事件发生之后如果还要监听则需要再次把事件注册入队列。</li>
</ul>
<p><code>epoll</code>的工作模式有两种：</p>
<ol>
<li>ET（edge trigger）模式：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理，如果不处理，下次调用<code>epoll_wait</code>时，不会再次向应用程序通知此事件。</li>
<li>LT（level trigger）模式：当<code>epoll_wait</code>检测到描述符事件发生并通知此事件时，应用程序不需要立即处理，下次调用<code>epoll_wait</code>时，会再次通知此事件。</li>
</ol>
<p>ET模式很大程序上减少了epoll事件被重复触发的次数，因此效率较LT模式高。epoll工作在ET模式时必须使用非阻塞接口，以避免一个阻塞读/写操作把处理多个文件描述符的任务饿死。</p>
</li>
<li><p><code>epoll_wait</code>等待事件的发生。<code>maxevents</code>参数告诉内核这次返回的事件最多有多少个，返回的事件存放在<code>events</code>参数对应的数组中，<code>timeoout</code>指定超时事件，若为-1则永久阻塞。</p>
</li>
</ul>
<h1 id="u4E00_u4E2Aecho_server/client_u7684_u4F8B_u5B50"><a href="#u4E00_u4E2Aecho_server/client_u7684_u4F8B_u5B50" class="headerlink" title="一个echo server/client的例子"></a>一个echo server/client的例子</h1><h3 id="u670D_u52A1_u5668_u7AEF"><a href="#u670D_u52A1_u5668_u7AEF" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IPADDRESS    <span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT         <span class="number">8080</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE      <span class="number">1024</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LISTENQ      <span class="number">20</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EPOLLEVENTS  <span class="number">100</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FDSIZE       <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> listenfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> listenfd = socket_bind(IPADDRESS, PORT);</span><br><span class="line">    listen(listenfd, LISTENQ);</span><br><span class="line">    do_epoll(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"socket create error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in server_addr;</span><br><span class="line">    bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"bind socket error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event events[EPOLLEVENTS];</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    epollfd = epoll_create(FDSIZE); <span class="comment">/* create a epoll fd which can handles FDSIZE fds */</span></span><br><span class="line">    <span class="keyword">if</span> (epollfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"create epoll error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add_event(epollfd, listenfd, EPOLLIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	ret = epoll_wait(epollfd, events, EPOLLEVENTS, -<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"epoll wait error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	handle_events(epollfd, events, ret, listenfd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(epollfd);		<span class="comment">/* must close epoll fd */</span>    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> listenfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">	fd = events[i].data.fd;</span><br><span class="line">	<span class="keyword">if</span> (fd == listenfd &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">	    handle_accept(epollfd, listenfd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">	    do_read(epollfd, fd, buf);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">	    do_write(epollfd, fd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in cli_addr;</span><br><span class="line">    <span class="keyword">int</span> cli_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> clifd;</span><br><span class="line">    <span class="keyword">if</span> ((clifd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cli_addr, &amp;cli_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"accept error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	add_event(epollfd, clifd, EPOLLIN);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread = read(fd, buf, MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"read error"</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"client close.\n"</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"read message: %s"</span>, buf);</span><br><span class="line">	modify_event(epollfd, fd, EPOLLOUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nwrite = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (nwrite == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	delete_event(epollfd, fd, EPOLLOUT);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">	modify_event(epollfd, fd, EPOLLIN);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAXSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5BA2_u6237_u7AEF"><a href="#u5BA2_u6237_u7AEF" class="headerlink" title="客户端"></a>客户端</h3><p>客户端代码我们也用epoll来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IPADDRESS    <span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT         <span class="number">8080</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE      <span class="number">1024</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LISTENQ      <span class="number">20</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EPOLLEVENTS  <span class="number">100</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FDSIZE       <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> pollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> conn_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in serv_addr;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"socket create error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port   = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, IPADDRESS, &amp;serv_addr.sin_addr) != <span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"inet_pton error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    </span><br><span class="line">    handle_connection(sockfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event events[EPOLLEVENTS];</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE];</span><br><span class="line"></span><br><span class="line">    epollfd = epoll_create(FDSIZE);</span><br><span class="line">    <span class="keyword">if</span> (epollfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"create epoll error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add_event(epollfd, STDIN_FILENO, EPOLLIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	ret = epoll_wait(epollfd, events, EPOLLEVENTS, -<span class="number">1</span>);</span><br><span class="line">	handle_events(epollfd, events, ret, sockfd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">	fd = events[i].data.fd;</span><br><span class="line">	<span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">	    do_read(epollfd, fd, sockfd, buf);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">	    do_write(epollfd, fd, sockfd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread = read(fd, buf, MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"read error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"server close.\nbye\n"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fd == STDIN_FILENO) &#123;</span><br><span class="line">	    add_event(epollfd, sockfd, EPOLLOUT);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    delete_event(epollfd, sockfd, EPOLLIN);</span><br><span class="line">	    add_event(epollfd, STDOUT_FILENO, EPOLLOUT);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nwrite = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (nwrite &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fd == STDOUT_FILENO) &#123;</span><br><span class="line">	    delete_event(epollfd, fd, EPOLLOUT);	    </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    modify_event(epollfd, fd, EPOLLIN);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAXSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="See_Also"><a href="#See_Also" class="headerlink" title="See Also"></a>See Also</h3><p>文章内容和代码学习自<a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="external">IO多路复用之epoll总结</a></p>
<p><a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="external">epoll manual</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/22/互斥锁和条件变量/" itemprop="url">
                  互斥锁和条件变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-22T00:00:00+08:00" content="2016-09-22">
              2016-09-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/22/互斥锁和条件变量/" class="leancloud_visitors" data-flag-title="互斥锁和条件变量">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u5E76_u53D1_u7F16_u7A0B_u7684_u95EE_u9898"><a href="#u5E76_u53D1_u7F16_u7A0B_u7684_u95EE_u9898" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h1><p>考虑这样一个问题，有两个线程，A和B，他们对同一个全局变量执行递减操作。假设C编译器将递减运算转换成3条机器指令：从内存装载到寄存器、递减寄存器、从寄存器存储到内存。可能会出现以下情形：</p>
<ol>
<li>线程A运行，把变量的值装载到一个寄存器中</li>
<li>系统把运行线程从A切换到B运行。A的寄存器被保存，B的寄存器则恢复。</li>
<li>线程B执行递减的全部操作，把新值存放到变量的变量中</li>
<li>线程A被恢复执行，A的寄存器被恢复，于是A从原来离开的地方开始执行，此时寄存器中保留的变量值是线程B执行递减前的值，这时候就出错了。</li>
</ol>
<p>可以看到这种并发的错误是因为递减操作不是原子操作而造成的，线程的切换会中断某些步骤，从而出现不预期的错误。</p>
<h1 id="u7B80_u5355_u5B9E_u4F8B"><a href="#u7B80_u5355_u5B9E_u4F8B" class="headerlink" title="简单实例"></a>简单实例</h1><p>我们通过一个简单的例子来说明如何利用互斥锁来解决并发。程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NLOOP    <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXP     <span class="number">5</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[MAXP];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> *iptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (iptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"malloc error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*iptr = i;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, doit, iptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread create error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_join(tids[i], <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread join error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NLOOP; i++) &#123;</span><br><span class="line">		val = counter;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, idx, val+<span class="number">1</span>);</span><br><span class="line">		counter = val+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;&#10;2: 1&#10;2: 2&#10;2: 3&#10;2: 4&#10;2: 5&#10;3: 5&#10;3: 6&#10;1: 1&#10;1: 2&#10;0: 1&#10;0: 2&#10;0: 3&#10;0: 4&#10;0: 5&#10;0: 6&#10;0: 7&#10;0: 8&#10;0: 9&#10;0: 10&#10;&#10;...</span><br></pre></td></tr></table></figure>
<p>可以看到当线程切换时，counter的值明显是错误的。</p>
<p>解决这种多个线程共享一个变量的问题是使用互斥锁（mutex，mutual exclusion）保护这个共享变量。互斥锁的作用是在线程访问该变量前必须持有互斥锁，否则线程将进入睡眠知道互斥锁可用。对于能够函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值*/</span></span><br></pre></td></tr></table></figure>
<p>修改之后的程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NLOOP    <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXP     <span class="number">5</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> counter_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[MAXP];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> *iptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (iptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"malloc error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*iptr = i;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, doit, iptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread create error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_join(tids[i], <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread join error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NLOOP; i++) &#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">	val = counter;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, idx, val+<span class="number">1</span>);</span><br><span class="line">	counter = val+<span class="number">1</span>;</span><br><span class="line">	Pthread_mutex_unlock(&amp;counter_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_lock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex lock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_unlock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex unlock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0: 1&#10;4: 2&#10;4: 3&#10;4: 4&#10;4: 5&#10;4: 6&#10;4: 7&#10;4: 8&#10;4: 9&#10;0: 10&#10;4: 11&#10;4: 12&#10;0: 13&#10;2: 14&#10;3: 15&#10;3: 16&#10;3: 17&#10;3: 18&#10;1: 19&#10;1: 20&#10;1: 21&#10;1: 22&#10;1: 23&#10;1: 24&#10;1: 25&#10;1: 26&#10;1: 27&#10;1: 28&#10;0: 29&#10;0: 30&#10;0: 31&#10;0: 32&#10;0: 33&#10;0: 34&#10;0: 35&#10;3: 36&#10;3: 37&#10;3: 38&#10;3: 39&#10;3: 40&#10;3: 41&#10;2: 42&#10;2: 43&#10;2: 44&#10;2: 45&#10;2: 46&#10;2: 47&#10;2: 48&#10;2: 49&#10;2: 50</span><br></pre></td></tr></table></figure>
<p>结果是正确的。</p>
<h1 id="u6761_u4EF6_u53D8_u91CF"><a href="#u6761_u4EF6_u53D8_u91CF" class="headerlink" title="条件变量"></a>条件变量</h1><p>互斥锁适合于防止同时访问某个共享变量，但是有的时候我们需要另外某种在等待某个条件发生期间让我们的进入睡眠的东西，这个就是条件变量。这里有一个例子，pthread函数库并没有等待任意一个线程终止的接口，那么如何实现呢？我们可以利用条件变量来实现这一功能。关于条件变量的函数接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(pthread_cond_t *cptr, pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(pthread_cond_t *cptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值*/</span></span><br></pre></td></tr></table></figure>
<p>先看完整的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NLOOP    <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXP     <span class="number">5</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="keyword">int</span> t_done;</span><br><span class="line"><span class="keyword">int</span> flag[MAXP];</span><br><span class="line"><span class="keyword">int</span> nleft;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> counter_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> tdone_mutex   = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>  tdone_cond    = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_wait</span><span class="params">(pthread_cond_t *cptr, pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_signal</span><span class="params">(pthread_cond_t *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_join</span><span class="params">(pthread_t tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[MAXP];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    nleft = MAXP;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> *iptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (iptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"malloc error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*iptr = i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, doit, iptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread create error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line">	<span class="keyword">while</span> (t_done == <span class="number">0</span>)</span><br><span class="line">	    Pthread_cond_wait(&amp;tdone_cond, &amp;tdone_mutex);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (flag[i] ==  <span class="number">1</span>) &#123;	<span class="comment">/* thread i already done */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread %d done\n"</span>, i);</span><br><span class="line">		Pthread_join(tids[i], <span class="literal">NULL</span>);</span><br><span class="line">		flag[i] = -<span class="number">1</span>;</span><br><span class="line">		nleft--;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Pthread_mutex_unlock(&amp;tdone_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NLOOP; i++) &#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">	val = counter;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, idx, val+<span class="number">1</span>);</span><br><span class="line">	counter = val+<span class="number">1</span>;</span><br><span class="line">	Pthread_mutex_unlock(&amp;counter_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line">    flag[idx] = <span class="number">1</span>;</span><br><span class="line">    t_done++;</span><br><span class="line">    Pthread_cond_signal(&amp;tdone_cond);</span><br><span class="line">    Pthread_mutex_unlock(&amp;tdone_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_lock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex lock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_unlock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex unlock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_wait</span><span class="params">(pthread_cond_t *cptr, pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((error = pthread_cond_wait(cptr, mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread condition wait error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_signal</span><span class="params">(pthread_cond_t *cptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_cond_signal(cptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread condition signal error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_join</span><span class="params">(pthread_t tid, <span class="keyword">void</span> **status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_join(tid, status)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread join error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先我们新建一个全局变量<code>t_done</code>表示当前终止的线程数量。</li>
<li>创建一个<code>tdone_cond</code>条件变量和与之相关联的互斥锁，通过持有该互斥锁期间递增该计数器并发送信号到该条件变量，一个线程通知朱循环自身即将终止。</li>
<li>主循环在持有条件变量相关联的互斥锁期间检查<code>t_done</code>，如果发现无事可做，那么主线程调用pthread_cond_wait等待信号，该函数把调用线程投入睡眠并释放调用线程持有的互斥锁，当调用线程后来从pthread_cond_wait返回时，<br>线程再次只有该互斥锁。</li>
<li>我们用一个flag标志来记录线程的状态，1表示线程已经终止，但未被另外一个线程调用pthread_join，-1表示已经被调用了pthread_join。</li>
</ol>
<p>每一个条件变量都需要关联一个互斥锁，因为<code>条件</code>通常是线程之间共享的某个变量的值。允许不同线程设置和测试该变量要求有一个与该变量相关联的互斥锁。举个栗子，如果之前的代码我们没有互斥锁，那么主循环的就是如下的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (t_done == <span class="number">0</span>)</span><br><span class="line">	Pthread_cond_wait(&amp;tdone_cond, &amp;tdone_mutex);</span><br></pre></td></tr></table></figure>
<p>有这样的可能：主线程外的一个线程在主循环测试t_done == 0之后但是在调用pthread_cond_wait之前调用递增了t_done，那么这个信号就会永远的地丢失了（pthread_cond_wait一定要在pthread_cond_signal前调用）。同样的理由要求<br>pthread_cond_wait被调用时，其所关联的互斥锁是必须上锁的，该函数作为单个原子操作解锁该互斥锁并把调用线程投入睡眠也是出于这个理由。如果函数不先解锁，到返回是再给它上锁，调用线程不得不实现解锁事后上锁，测试t_done的循环就变成了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line"><span class="keyword">while</span> (t_done == <span class="number">0</span>) &#123;</span><br><span class="line">	Pthread_mutex_unlock(&amp;tdone_mutex);</span><br><span class="line">	Pthread_cond_wait(&amp;tdone_cond, &amp;tdone_mutex);</span><br><span class="line">	Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而会有这种情况：在Pthread_mutext_unlock与Pthread_cond_wait之间有另外的一个线程递增了t_done，那么这个信号也就永远消失了。</p>
<p>最后要说明的是，pthread_cond_signal通常唤醒等待相应条件上的单个线程，有时候一个线程需要唤醒多个等待条件的线程，这时候可以调用pthread_cond_broadcast，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(pthread_cond_t *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(pthread_cond_t *cptr, pthread_mutext_t *mptr, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/用线程处理客户请求/" itemprop="url">
                  用线程处理客户请求
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T00:00:00+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/21/用线程处理客户请求/" class="leancloud_visitors" data-flag-title="用线程处理客户请求">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h1><p>传统的UNIX模型中，如果需要异步地完成一个任务，通常我们只要fork一个进程就可以了，但是fork进程存在以下两个问题：</p>
<ol>
<li>fork的代价是昂贵的。fork需要把父进程的内存映像复制到子进程，并在子进程中复制所有的描述符，虽然现在的实现是写时复制，但是fork一样是昂贵的。</li>
<li>fork返回之后父子进程通信需要利用IPC机制，比较费力。</li>
</ol>
<p>线程被称为<code>lightweight process</code>，同一进程可以创建多个线程，这些线程共享进程内的全局内存，这使得线程通信变得容易。同时，线程创建的代码大大小于进程创建。但是线程也存在同步的问题。</p>
<p>同一进程内的所有线程共享全局变量外，还共享：</p>
<ul>
<li>进程指令</li>
<li>大多数数据</li>
<li>打开的文件（描述符）</li>
<li>信号处理函数和信号变量</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
</ul>
<p>每个线程也有各自的：</p>
<ul>
<li>线程ID</li>
<li>寄存器集合，包括程序计数器和栈指针</li>
<li>栈，存放局部变量和返回地址</li>
<li>errno</li>
<li>信号掩码</li>
<li>优先级</li>
</ul>
<h1 id="u7EBF_u7A0B_u64CD_u7EB5_u51FD_u6570"><a href="#u7EBF_u7A0B_u64CD_u7EB5_u51FD_u6570" class="headerlink" title="线程操纵函数"></a>线程操纵函数</h1><h3 id="u521B_u5EFA_u7EBF_u7A0B"><a href="#u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="创建线程"></a>创建线程</h3><p>函数原型为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t *tid, pthread_attr_t *attr, void *(*func)(void *), void *arg);</span><br><span class="line"></span><br><span class="line">/× 成功返回0，否则返回正的Exxx值×/</span><br></pre></td></tr></table></figure>
<p>进程内的线程有一个线程ID标志，由tid返回。每个线程有许多属性：优先级、初始栈大小、是否应该成为一个守护进程等，若attr为NULL，则取默认值。线程的执行逻辑由func函数指针指定，函数接收一个void指针的<br>参数，第四个参数就是我们传递的参数，如果需要传递多个参数，把参数打包进一个结构指针即可。</p>
<h3 id="u7B49_u5F85_u7EBF_u7A0B_u7ED3_u675F"><a href="#u7B49_u5F85_u7EBF_u7A0B_u7ED3_u675F" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>利用pthread_join等待一个给定线程终止（是的，不能等待任意一个线程终止，如果需要，必须利用其他手段）。函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(pthread_t *tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>
<p>status通常是创建线程时func函数的返回值。</p>
<h3 id="u7EBF_u7A0B_u7EC8_u6B62"><a href="#u7EBF_u7A0B_u7EC8_u6B62" class="headerlink" title="线程终止"></a>线程终止</h3><p>让一个线程终止的方法之一是调用pthread_exit，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>
<p>status不能局限于要终止的线程的对象，因为当线程终止时，对象也将消失。如果该线程未曾脱离（下面会说到），它的线程ID和退出状态将一直留存到调用进程内的某个其他线程对它调用pthread_join。</p>
<p>让一个线程终止的另外的两个方法：</p>
<ul>
<li>启动线程的函数可以返回，其返回值就是相应线程的终止状态。</li>
<li>如果进程的main函数返回或者任何线程调用了exit，整个进程就终止，其中包括它的任何线程。</li>
</ul>
<h3 id="pthread_self_u4E0Epthread_detach_u51FD_u6570"><a href="#pthread_self_u4E0Epthread_detach_u51FD_u6570" class="headerlink" title="pthread_self与pthread_detach函数"></a>pthread_self与pthread_detach函数</h3><p>pthread_self返回进程内该线程的ID，pthread_detach后，线程像守护进程一样，当它们终止时，所有的资源都被释放，不需要某个其他进程调用pthread_join。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(pthread_t tid)</span></span>;        <span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，上述函数的调用情况是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure>
<p>以此，线程让自己脱离。</p>
<h1 id="u7EBF_u7A0B_u5B89_u5168_u51FD_u6570"><a href="#u7EBF_u7A0B_u5B89_u5168_u51FD_u6570" class="headerlink" title="线程安全函数"></a>线程安全函数</h1><p>当一个函数修改了全局变量，那么这个函数不是线程安全的，换句话说该函数不可重入。考虑以下的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		len = addrlen;</span><br><span class="line">		connfd = Accept(listenfd, cliaddr, &amp;len);</span><br><span class="line">		Pthread_create(&amp;tid, <span class="literal">NULL</span>, doit, &amp;connfd);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> connfd;</span><br><span class="line">	</span><br><span class="line">	connfd = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来上述代码是没有问题的，但是考虑这样一种情况：</p>
<ol>
<li>accept返回，主线程调用pthread_create创建一个新的线程</li>
<li>调度新创建的线程执行，但是并没有执行到给connfd赋值就被切换了。</li>
<li>另一个连接就绪，accept返回，返回的描述符存入connfd</li>
<li>先前切换的线程被调度执行，这时候它所得到的connfd却并不是第一个连接的描述符了。</li>
</ol>
<p>POSIX要求许多函数是线程安全的，即它们都是可重入的，这个要求通过对我们透明的库函数内部执行某种形式的同步达到，线程安全函数见UNP P542。</p>
<h1 id="u7EBF_u7A0B_u7279_u5B9A_u6570_u636E"><a href="#u7EBF_u7A0B_u7279_u5B9A_u6570_u636E" class="headerlink" title="线程特定数据"></a>线程特定数据</h1><p>把一个未线程化的程序转换成使用线程的版本时，有时会碰到因其中有函数使用静态变量而引起的一个常见变成错误。解决这样的错误有许多方法，这里我们介绍使用<code>线程特定数据</code>的方法。</p>
<p>每个系统支持优先数量的线程特定数据，POSIX要求这个限制不小于128.系统为每个进程维护一个我们称之为Key的结构数据，如图所示：</p>
<img src="/2016/09/21/用线程处理客户请求/key_tsd.png" alt="key_tsd.png" title="">
<p>flag表示该项是否被使用，析构函数用于线程终止时释放线程占用的数据内存，由编程人员指定。</p>
<p>这个Key是进程范围内的，即所有线程共享该数组。除此之外，系统还为每个线程维护特定于线程的Pthread结构，其部分内容是我们称之为pkey数据的128个元素的指针数组。如下所示：</p>
<img src="/2016/09/21/用线程处理客户请求/pkey_tsd.png" alt="pkey_tsd.png" title="">
<p>pkey数组的所有元素都被初始化为空指针，这128个指针和进程内的128个可能的Key是逐一关联的。</p>
<p>举一个例子来说明线程特定的数据如何使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> rl_key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> rl_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_destructor</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Pthread_key_create(&amp;rl_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> thread_readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen) &#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	pthread_once(&amp;rl_once, readline_once);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((ptr = pthread_getspecific(rl_key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ptr = Malloc(...);</span><br><span class="line">		pthread_setspecific(rl_key, ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* use values pointed to by ptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程内第一个线程调用thread_readline时，一个Key被创建，同时注册对应的析构函数。之后进程内线程的状态如下：</p>
<img src="/2016/09/21/用线程处理客户请求/thread_statues1.png" alt="thread_statues1.png" title="">
<p>这时候如果有另外一个线程调用thread_readline，那么pthread_once之前执行过一次，Key已经创建（这两次析构函数是一样的），线程取该Key对应的内存指针，返回为空，于是线程创建一个新的内存区域。进程内线程的状态变为如下所示：</p>
<img src="/2016/09/21/用线程处理客户请求/thread_statues2.png" alt="thread_statues2.png" title="">
<p>可以看到每一个线程有特定于线程自身的缓冲区域，这样就不会发生同步的问题。</p>
<p>可以给出用到的函数原型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include d.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_once(pthread_once_t *onceptr, void (*init)(void));</span><br><span class="line"></span><br><span class="line">int pthread_key_create(pthread_key_t *keyptr, void (*destructor) (void *));</span><br><span class="line"></span><br><span class="line">void *pthread_getspecific(pthread_key_t key);</span><br><span class="line"></span><br><span class="line">void *pthread_setspecific(pthread_key_t key, const void *value);</span><br></pre></td></tr></table></figure>
<p>注意pthread_once_t类型的变量在传入pthread_once函数之前，要初始化为PTHREAD_ONCE_INIT。</p>
<h1 id="u4F7F_u7528_u7EBF_u7A0B_u7279_u5B9A_u6570_u636E_u7684readline_u51FD_u6570"><a href="#u4F7F_u7528_u7EBF_u7A0B_u7279_u5B9A_u6570_u636E_u7684readline_u51FD_u6570" class="headerlink" title="使用线程特定数据的readline函数"></a>使用线程特定数据的readline函数</h1><p>这里给出一个具体的例子，该例子是修改过的readline函数，它是利用了线程的特定数据以做到线程安全。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unp.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unpthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> rl_key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> rl_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_destructor</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Pthread_key_create(&amp;rl_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> rl_cnt;</span><br><span class="line">    <span class="keyword">char</span> *rl_bufptr;</span><br><span class="line">    <span class="keyword">char</span> rl_buf[MAXLINE];</span><br><span class="line">&#125;Rline;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(Rline *tsd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tsd -&gt; rl_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* no data in buffer */</span></span><br><span class="line">    again:</span><br><span class="line">	<span class="keyword">if</span> ((tsd -&gt; rl_cnt = read(fd, tsd -&gt; rl_buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tsd -&gt; rl_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">/* EOF */</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    tsd -&gt; rl_bufptr = tsd -&gt; rl_buf;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tsd -&gt; rl_cnt--;</span><br><span class="line">    *ptr = *tsd -&gt; rl_bufptr++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> thread_readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen) &#123;</span><br><span class="line">    Rline *tsd;</span><br><span class="line">    <span class="keyword">size_t</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;rl_once, readline_once);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tsd = pthread_getspecific(rl_key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* alloc thread specific data */</span></span><br><span class="line">	tsd = Calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(Rline));</span><br><span class="line">	pthread_setspecific(rl_key, tsd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n&lt;maxlen; n++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((rc = my_read(tsd, fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">	    *ptr++ = c;</span><br><span class="line">	    <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">/* end of file */</span></span><br><span class="line">	    *ptr = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">/* error */</span></span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/系统服务——daemon/" itemprop="url">
                  系统服务——daemon
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T00:00:00+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/19/系统服务——daemon/" class="leancloud_visitors" data-flag-title="系统服务——daemon">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h1><h3 id="u4EC0_u4E48_u662Fdaemon"><a href="#u4EC0_u4E48_u662Fdaemon" class="headerlink" title="什么是daemon"></a>什么是daemon</h3><p>简单来说，系统为了某些功能必须提供一些服务，这个服务我们称之为<code>service</code>，但是service的提供需要进程的运行，所以实现这个service的程序我们称之为<code>daemon</code>。我们不必<br>区分daemon与service，或者说可以将他们视为等同的。因为没有daemon在后台运行就不会有这个serivce。daemon没有控制终端，所以当有事发生时，它们需要有消息输出的方法可用。<br><code>syslog</code>函数是输出这些消息的标准方法，它把这些消息发送给<code>syslogd</code>守护进程。</p>
<p>syslogd的函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *message, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>priority</code>由level和facility组成，具体可以查看UNP P288。</p>
<h3 id="daemon_u7684_u4E3B_u8981_u5206_u7C7B"><a href="#daemon_u7684_u4E3B_u8981_u5206_u7C7B" class="headerlink" title="daemon的主要分类"></a>daemon的主要分类</h3><p>如果按照启动与管理方式分类：</p>
<ul>
<li>stand alone：这种类型的daemon不必通过其他机制来管理，可以自行启动，一旦启动就常驻内存。其最大的优点是由于一直在内存内持续的提供服务，因此对于客户的请求响应较快。常见的<br>stand alone的daemon有ftp、httpd等。</li>
<li>super daemon：一个特殊的daemon来统一管理其他的daemon。这一种服务的启动方式通过同一个daemon来负责唤起服务。这个特殊的daemon被称为super daemon。早期的super daemon是inetd，现在<br>Linux下是xinetd。当客户没有请求时，对应的服务未启动，只有当客户有对应的请求来到时，super daemon才会唤醒相应的服务，当请求完成之后，被唤醒的这个服务也会关闭并释放资源。该机制的优点在于：１）super daemon<br>可以具有安全管控机制；２）服务在请求结束后就关闭，不会一直占用资源。缺点在于对于请求的响应较慢。</li>
</ul>
<p>如果按照工作形态分类：</p>
<ul>
<li>signal-control：这种daemon通过信号来管理，只要有任何客户端的请求进来，它就会立即启动取处理。</li>
<li>interval-control：这种daemon每隔一段时间就主动取执行某项工作。</li>
</ul>
<h3 id="u5C06_u4E00_u4E2A_u7A0B_u5E8F_u4F5C_u4E3Adaemon_u8FD0_u884C"><a href="#u5C06_u4E00_u4E2A_u7A0B_u5E8F_u4F5C_u4E3Adaemon_u8FD0_u884C" class="headerlink" title="将一个程序作为daemon运行"></a>将一个程序作为daemon运行</h3><p>Linux提供了<code>daemon</code>函数将一个普通进程转变为守护进程运行。它的原理和这里给出的<code>daemon_init</code>函数大同小异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pname, <span class="keyword">int</span> facility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child continues */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* become session leader */</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 必须忽略SIGHUP，否则当会话头进程终止时，会话中的所有进程都收到SIGHUP信号 */</span></span><br><span class="line">    Signal(SIGHUP, SIG_IGN);</span><br><span class="line">    <span class="comment">/* 再次Fork，使得进程不再是会话头 */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid)</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    daemon_proc = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXFD; i++)</span><br><span class="line">	close(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* redirec stdin, stdout and stderr to '/dev/null' */</span></span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDONLY);</span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    openlog(pname, LOG_PID, facility);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先是fork，在fork结束之后，父进程终止，子进程自动在后台运行。另外，由于子进程继承了父进程的进程组ID，这保证了子进程不是一个进程组的头进程，这为下面的setsid做了准备。</li>
<li>setsid，其用于创建一个新的会话，当前进程变为新的会话的会话头进程以及新进程组的进程组头进程，从而不再有控制终端。</li>
<li>忽略SIGHUP信号并再次fork，再次fork保证本守护进程不会是会话头进程，那么即使将来打开了一个终端设备，也不会自动获得控制终端。因为当没有控制终端的会话头进程打开一个终端设备时，该终端会自动成为<br>这个会话头进程的控制终端。忽略SIGHUP信号是因为当会话头进程终止时，其会话中的所有进程（再次fork产生的子进程）都收到SIGHUP信号。</li>
<li>将stdin、stdout以及stderr重定向到/dev/null，打开这些描述符的理由在于，守护进程调用的那些假设能从这三个描述符读写的库函数不会因为这些描述符未打开而失败。</li>
<li>调用syslog处理函数。</li>
</ol>
<p>既然守护进程在没有控制终端的环境下运行，那么它绝对不会收到来自内核的SIGHUP信号，许多守护进程因此把这个信号作为来自系统管理员的一个通知，表示其配置文件已经发生变化，守护进程应该重新读入配置文件。</p>
<h1 id="Linux_u4E0Bdaemon_u7684_u542F_u52A8_u811A_u672C_u548C_u542F_u52A8_u65B9_u5F0F"><a href="#Linux_u4E0Bdaemon_u7684_u542F_u52A8_u811A_u672C_u548C_u542F_u52A8_u65B9_u5F0F" class="headerlink" title="Linux下daemon的启动脚本和启动方式"></a>Linux下daemon的启动脚本和启动方式</h1><h3 id="u914D_u7F6E_u6587_u4EF6_u4F4D_u7F6E"><a href="#u914D_u7F6E_u6587_u4EF6_u4F4D_u7F6E" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><p>通常daemon的启动脚本放在/etc/init.d/目录下，启动脚本可以进程环境检测、配置文件分析、PID文件放置以及相关重要交换文件的锁操作。</p>
<p>super daemon的配置文件放置在/etc/xinetd.d/目录和/etc/xinetd.conf中。</p>
<p>在/etc/目录下还有各自服务的配置文件</p>
<p>/var/lib/目录下是一些会产生数据的服务放置产生的数据库的位置，数据库管理系统MySQL的数据库默认写入/var/lib/mysql。</p>
<p>/var/run/目录下存放各服务程序的PID记录。</p>
<p>对于stand alone的daemon，我们即可执行/etc/init.d/目录下的脚本来启动它，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ /etc/init.d/mysql start</span><br></pre></td></tr></table></figure>
<p>也可以利用service命令（实际上它也是一个stand alone的服务）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ service mysql start</span><br></pre></td></tr></table></figure>
<h3 id="super_daemon_u914D_u7F6E_u6587_u4EF6"><a href="#super_daemon_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="super daemon配置文件"></a>super daemon配置文件</h3><p>Linux下super daemon由xinetd这个进程实现，它不仅可以启动其他daemon，还可以进行安全性或者其他管理机制的控制。xinetd的默认配置存放在/etc/xinetd.conf中，由xinetd启动的服务程序的配置放置在/etc/xinetd.d目录下。<br>如果一个服务的配置文件没有xinetd.conf中指定的参数，那么该服务对应的参数就以xinetd.conf中的为准。具体的参数说明可以参加《鸟哥——基础篇》P559。一个简单的daytime服务配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mydaytime&#10;&#123;&#10;        disable         = no&#10;        socket_type     = stream&#10;        wait            = no&#10;        user            = root&#10;        server          = /home/zach41/Desktop/unp/unpv13e/inetd/daytimetcpsrv3&#10;        log_on_failure  = USERID&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这之后我们还需要修改/etc/services文件，分配一个端口来提供daytime服务。具体就是添加如下一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydaytime    9999/tcp</span><br></pre></td></tr></table></figure>
<p>这样配置之后，我们重启xinetd服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ service xinetd restart&#10;&#10140;  ~ sudo netstat -tnlp | grep 9999&#10;[sudo] password for zach41: &#10;tcp        0      0 0.0.0.0:9999            0.0.0.0:*               LISTEN      15914/xinetd</span><br></pre></td></tr></table></figure>
<p>可以看到xinetd进程在监听9999端口。</p>
<p>我们运行一个daytime客户端程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  names git:(master) &#10007; ./daytimetcpcli2 0.0.0.0 9999&#10;trying 0.0.0.0:9999&#10;Mon Sep 19 18:43:04 2016</span><br></pre></td></tr></table></figure>
<h3 id="daytime_daemon_u7A0B_u5E8F"><a href="#daytime_daemon_u7A0B_u5E8F" class="headerlink" title="daytime daemon程序"></a>daytime daemon程序</h3><p>最后这里给出daytimeserver的代码，这是由xinetd作为守护进程启动的时间获取服务器程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>	<span class="string">"unp.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>	<span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">socklen_t</span>		len;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr	*cliaddr;</span><br><span class="line">	<span class="keyword">char</span>			buff[MAXLINE];</span><br><span class="line">	<span class="keyword">time_t</span>			ticks;</span><br><span class="line"></span><br><span class="line">	daemon_inetd(argv[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cliaddr = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">	len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">	Getpeername(<span class="number">0</span>, cliaddr, &amp;len);</span><br><span class="line">	err_msg(<span class="string">"connection from %s"</span>, Sock_ntop(cliaddr, len));</span><br><span class="line"></span><br><span class="line">    ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">"%.24s\r\n"</span>, ctime(&amp;ticks));</span><br><span class="line">    Write(<span class="number">0</span>, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">	Close(<span class="number">0</span>);	<span class="comment">/* close TCP connection */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到所有套接字的创建代码(tcp_listen和accept的调用)都不见了，这些步骤都有xinetd执行，我们使用描述符0指代已由xinetd接受的TCP连接（套接字描述符被复制到描述符0, 1, 2）。daemon_init只是负责设置daemon_proc<br>标志以及调用openlog，从而发送日志信息给syslogd守护进程。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/IPv4与IPv6的户操作性/" itemprop="url">
                  IPv4与IPv6的户操作性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T00:00:00+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/19/IPv4与IPv6的户操作性/" class="leancloud_visitors" data-flag-title="IPv4与IPv6的户操作性">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IPv4_u6620_u5C04_u7684IPv6_u5730_u5740"><a href="#IPv4_u6620_u5C04_u7684IPv6_u5730_u5740" class="headerlink" title="IPv4映射的IPv6地址"></a>IPv4映射的IPv6地址</h1><p>IPv4映射的IPv6地址允许在因特网向IPv6过度时期让运行在双栈主机上的IPv6应用进程能够与只支持IPv4的主机通信。这些地址是IPv6应用进程查询某个只有IPv4地址的主机的IPv6地址时，DNS解析器按需自动创建的且不存在于任何DNS<br>数据文件中。在IPv6套接字上使用这种类型的地址导致往目的地IPv4主机发送IPv4数据报。</p>
<p>下图展示了一个IPv4映射的IPv6地址的格式：</p>
<img src="/2016/09/19/IPv4与IPv6的户操作性/mapped.png" alt="mapped.png" title="">
<h1 id="IPv4_u5BA2_u6237_u4E0EIPv6_u670D_u52A1_u5668"><a href="#IPv4_u5BA2_u6237_u4E0EIPv6_u670D_u52A1_u5668" class="headerlink" title="IPv4客户与IPv6服务器"></a>IPv4客户与IPv6服务器</h1><p>双栈主机的一个特性就是其上的IPv6服务器既可以处理IPv4客户，也可以处理IPv6客户。这是通过IPv4映射的IPv6地址实现的。下图是一个例子：</p>
<img src="/2016/09/19/IPv4与IPv6的户操作性/ipv4to6.png" alt="ipv4to6.png" title="">
<p>IPv4客户发送一个IPv4的SYN分节以期和服务器建立连接。来自IPv4客户的SYN分节在以太网中表现为一个以太网首部、一个IPv4首部、一个TCP部以及TCP数据。以太网首部中包含的类型字段为0x0800，表示它是一个IPv4帧数据。</p>
<p>接收数据链路通过查看以太网类型字段把每个帧数据发送给对应的IP模块。IPv4模块结合其上的TCP模块检测到IPv4数据报的目的段端口对应一个IPv4套接字，于是该数据报Ipv4首部中的源IPv4地址被转换成IPv4映射的IPv6地址，当<br>accept系统调用把这个已经接收的IPv4客户连接返回被服务器进程的时候，这个映射后的地址作为客户的IPv6地址返回到服务器的IPv6套接字。该连接上的其余数据同样都是IPv4数据报。服务器进程完全不知道它是在与一个IPv4客户机通信。</p>
<h1 id="IPv6_u5BA2_u6237_u4E0EIPv4_u670D_u52A1_u5668"><a href="#IPv6_u5BA2_u6237_u4E0EIPv4_u670D_u52A1_u5668" class="headerlink" title="IPv6客户与IPv4服务器"></a>IPv6客户与IPv4服务器</h1><p>在一个双栈主机上运行一个IPv6客户程序，其于一个IPv4服务器程序交互的流程如下：</p>
<ol>
<li>一个IPv4服务器在只支持IPv4的一个主机上启动后创建一个IPv4监听套接字。</li>
<li>IPv6客户启动后调用getaddrinfo单纯查找IPv6地址（请求AF_INET6地址，hints结构中设置了AI_V4MAPPED标志），最后只有得到只支持IPv4的服务器主机的A记录，那么返回给客户的就是IPv4映射之后的IPv6地址。</li>
<li>IPv6客户设置这个IPv4映射后的IPv6地址，调用connect，内核检测到这个映射的地址后自动发送一个IPv4的SYN分节到服务器。</li>
<li>服务器响应一个IPv4 SYN/ACK分节，连接于是用IPv4数据报建立。</li>
</ol>
<p>以后在以太网上传递的是IPv4数据报。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/套接字选项/" itemprop="url">
                  套接字选项
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T00:00:00+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/13/套接字选项/" class="leancloud_visitors" data-flag-title="套接字选项">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u4FEE_u6539_u5957_u63A5_u5B57_u9009_u9879"><a href="#u4FEE_u6539_u5957_u63A5_u5B57_u9009_u9879" class="headerlink" title="修改套接字选项"></a>修改套接字选项</h1><p>有几种方法来修改和获取套接字的选项：</p>
<ul>
<li>getsockopt &amp; setsockopt</li>
<li>fcntl</li>
<li>ioctl</li>
</ul>
<h3 id="getsockopt__26amp_3B_setsockopt"><a href="#getsockopt__26amp_3B_setsockopt" class="headerlink" title="getsockopt &amp; setsockopt"></a>getsockopt &amp; setsockopt</h3><p>这两个函数仅仅用于套接字。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, socklen_t *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, socklen_t optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockfd必须指向一个已经打开的套接字，level指向系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码（如TCP、IPv4、IPv6或SCTP）。</p>
<p>optval指向某个变量，变量的大小由最后一个参数optlen指定，setsockopt从optval中取得待设置的新值，而getsockopt把获取到的值存入对应的地址中。</p>
<p>套接字选项粗分为两大基本类型：</p>
<ul>
<li>启用或禁止某个特性的标志选项(flag = 0禁止特性，flag = 1开启特性)</li>
<li>取得并返回我们可以设置或检查的特定值选项，即值选项。</li>
</ul>
<p>套接字选项可以参见UNP的P151</p>
<h1 id="u901A_u7528_u5957_u63A5_u5B57_u9009_u9879_uFF08_u90E8_u5206_uFF09"><a href="#u901A_u7528_u5957_u63A5_u5B57_u9009_u9879_uFF08_u90E8_u5206_uFF09" class="headerlink" title="通用套接字选项（部分）"></a>通用套接字选项（部分）</h1><p>这里仅仅列出部分的通用套接字选项，其实也就是挑了一些自己看得懂的选项记录下。</p>
<h3 id="SO_BROADCAST"><a href="#SO_BROADCAST" class="headerlink" title="SO_BROADCAST"></a>SO_BROADCAST</h3><p>开启或禁止进程发送广播消息的能力。只有数据报支持广播，并且还是在支持广播消息的网络上（以太网、令牌网络等）。</p>
<h3 id="SO_DEBUG"><a href="#SO_DEBUG" class="headerlink" title="SO_DEBUG"></a>SO_DEBUG</h3><p>仅由TCP支持，当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和接收的所有分组保留详细的跟踪信息，这些信息保存在内核的某个环形缓冲区中，并可使用trpt程序进行检查。</p>
<h3 id="SO_ERROR"><a href="#SO_ERROR" class="headerlink" title="SO_ERROR"></a>SO_ERROR</h3><p>当一个套接字上发生错误时，内核将套接字的名为so_error的变量设置为标准的Unix Exxx值中的一个，它被成为该套接字的待处理错误(pending error)，内核以以下方式通知进程这个错误：</p>
<ol>
<li>如果进程阻塞在套接字的select调用上，那么无论是检查可读条件还是可读可写条件，select均返回并设置其中一个或所有的条件。</li>
<li>如果进程使用信号驱动I/O模型，那么进程或进程组就会接收到内核产生的SIGIO信息。</li>
</ol>
<p>进程在被内核通知之后，可以通过访问SO_ERROR套接字选项获得so_error的值，由getsockopt返回的整数即待处理错误，随后so_error由内核复位成0。</p>
<p>这个套接字选项可以获取，但是不能设置。</p>
<h3 id="SO_KEEPALIVE"><a href="#SO_KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>给一个套接字设置保持存活(keep-alive)选项后，如果2小时内在该套接字的任意一个方向上没有数据交换，那么TCP就会自动给对端发送一个保持存活的探测分节(keep-alive probe)，这是一个对端必须响应的TCP分节，它<br>会导致以下三种情况之一：</p>
<ol>
<li>对端以期望的ACK响应，一切正常</li>
<li>对端以RST响应，对端已经崩溃并重启，套接字的待处理错误被置为ECONNRESET，套接字本身被关闭。</li>
<li>对端对保持存活的探测分节没有响应，TCP间隔一段时间再次发送探测分节，多次之后若还是没有响应，则放弃套接字的待处理错误被置为ETIMEOUT，如果收到一个ICMP错误作为某个探测分节的响应，就返回相应的错误，套接字本身被关闭。</li>
</ol>
<h3 id="SO_LINGER"><a href="#SO_LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><p>指定close函数对面向连接的协议(TCP和SCTP)如何操作。默认的行为是立即返回，如果这时候发送缓冲区有数据残留，系统会尝试把数据发送给对方。选项要求用户进程和内核间传递如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> linger &#123;</span><br><span class="line">	<span class="keyword">int</span> l_onoff;</span><br><span class="line">	<span class="keyword">int</span> l_linger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果l_onoff = 0，l_linger被忽略，选项关闭</li>
<li>l_onoff非0，<ul>
<li>l_linger = 0，那么TCP丢弃发送缓冲区内的任何数据，并发送一个RST给对端，不会再有四次挥手。</li>
<li>l_linger不为0，进程被阻塞，知道所有发送缓冲区的数据都发送完毕并被对方确认，或者是超过了l_linger指定的时间，如果超时，close返回EWOULDBLOCK错误。</li>
</ul>
</li>
</ol>
<p>假设客户在发送玩数据后调用了close函数，close可能在服务器读套接字接收缓冲区中的剩余数据之前就返回，在应用程序读数据之前服务器可能就会崩溃，而客户进程永远不会知道。<br>如果设置了SO_LINGER套接字，那么在调用close函数后，应用进程阻塞一段时间，等待数据全部发送并被对方确认（如图所示）。但是这里还有一个问题，延滞的时间可能不够，close仍然会返回EWOULDBLOCK错误，而且close的成功返回只是告诉我们先前发送的数据已经由对方确认，并不能告诉我们应用进程是否读取了数据。</p>
<img src="/2016/09/13/套接字选项/so_linger.png" alt="so_linger.png" title="">
<p>让客户进程知道服务器已经读取数据的一个方法是改用shutdown（设置SHUT_WR），改用之后的流程如下图：</p>
<img src="/2016/09/13/套接字选项/shutdown_linger.png" alt="shutdown_linger.png" title="">
<p>另外一个方法是应用程序自己做确认。客户在向服务器发送完数据后，调用read来读取一个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ack;</span><br><span class="line"></span><br><span class="line">Write(sockfd, data, nbytes);</span><br><span class="line">n = read(sockfd, &amp;ack, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>服务器读取来自客户端的数据后发回一个字节的ACK。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nbytes = Read(sockfd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"></span><br><span class="line">Write(sockfd, <span class="string">""</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="SO_RCVBUF__26amp_3B_SO_SNDBUF"><a href="#SO_RCVBUF__26amp_3B_SO_SNDBUF" class="headerlink" title="SO_RCVBUF &amp; SO_SNDBUF"></a>SO_RCVBUF &amp; SO_SNDBUF</h3><p>每一个套接字有一个发送和接收缓冲区，可以利用SO_RCVBUF和SO_SNDBUF选项来修改默认的缓冲区大小。需要注意的是，由于TCP的窗口规模是在建立连接时用SYN分节与对端呼唤a的都的。对于客户端，意味着<br>SO_RCVBUF必须在connect调用之前设置；对于服务端，该选项必须在调用Listen之前设置。</p>
<h3 id="SO_RCVLOWAT__26amp_3B_SO_SNDLOWAT"><a href="#SO_RCVLOWAT__26amp_3B_SO_SNDLOWAT" class="headerlink" title="SO_RCVLOWAT &amp; SO_SNDLOWAT"></a>SO_RCVLOWAT &amp; SO_SNDLOWAT</h3><p>每一个套接字还有一个接收和发送低水位标志，由select使用，用SO_RCVLOWAT和SO_SNDLOWAT可以修改低水位标志的值。</p>
<p>接收低水位标志是让select返回可读时套接字接收缓冲区所需要的最少的数据量。<br>发送低水位标志是让select返回可写是套接字发送缓冲区可存入的最少数据量。</p>
<p>两个低水位的默认值都为1</p>
<h3 id="SO_RCVTIMEO__26amp_3B_SO_SNDTIMEO"><a href="#SO_RCVTIMEO__26amp_3B_SO_SNDTIMEO" class="headerlink" title="SO_RCVTIMEO &amp; SO_SNDTIMEO"></a>SO_RCVTIMEO &amp; SO_SNDTIMEO</h3><p>这两个选项允许我们给套接字的接收和发送设置一个超时值。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/Linux文件与目录的默认、隐藏和特殊权限/" itemprop="url">
                  Linux文件与目录的默认、隐藏和特殊权限
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T00:00:00+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/12/Linux文件与目录的默认、隐藏和特殊权限/" class="leancloud_visitors" data-flag-title="Linux文件与目录的默认、隐藏和特殊权限">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u9ED8_u8BA4_u6743_u9650"><a href="#u9ED8_u8BA4_u6743_u9650" class="headerlink" title="默认权限"></a>默认权限</h1><p>在Linux下创建一个文件或者目录的默认权限和<code>umask</code>相关，umask指定“当前用户在创建文件或者目录时的权限默认值”。用umask来查看文件或目录的默认权限值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ umask&#10;002</span><br></pre></td></tr></table></figure>
<p>需要注意的是umask指定文件或目录的默认值应该减去的数值。而对于一个文件，默认值是“-rw-rw-rw”，对一个目录，默认值是“drwxrwxrwx”，举例来说，如果当前用户创建了一个文件，那么文件的权限默认值就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-rw-rw-rw-) - (--------w-) =&#62; -rw-rw-r--</span><br></pre></td></tr></table></figure>
<h1 id="u9690_u85CF_u5C5E_u6027"><a href="#u9690_u85CF_u5C5E_u6027" class="headerlink" title="隐藏属性"></a>隐藏属性</h1><p>可以利用<code>chattr</code>和<code>lsattr</code>来修改和查看文件或目录的隐藏属性。需要注意的是这两个命令只在Ext2/Ext3文件系统上有效。</p>
<p>命令使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [+-=] [ASacdistu] files...</span><br></pre></td></tr></table></figure>
<p>这里只说明两个参数，其余可以参见manual</p>
<ul>
<li>i: 让一个文件不能被删除、改名、设置连接、写入或添加数据。只有root才能设置该属性。</li>
<li>a: 设置a之后，这个文件只能添加数据，而不能删除也不能修改数据，只有root才能设置该属性。</li>
</ul>
<p>lsattr查看隐藏属性，用法简单，可以直接查看manual</p>
<h1 id="u6587_u4EF6_u7279_u6B8A_u6743_u9650"><a href="#u6587_u4EF6_u7279_u6B8A_u6743_u9650" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h1><p>Linux有三个特殊权限：</p>
<ul>
<li>SUID</li>
<li>SGID</li>
<li>SBIT</li>
</ul>
<h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><p>当s标志出现在文件所有者的x权限上时，此时就被成为<code>SET UID</code>，即SUID的特殊权限。</p>
<p>SUID有这样的功能和限制：</p>
<ol>
<li>仅仅对二进制程序有效</li>
<li>执行者对该程序具有科执行的权限</li>
<li>本权限仅仅在执行过程中有效</li>
<li>执行者将拥有该程序所有者的权限（仅在执行过程中）</li>
</ol>
<p>举例来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ ls -l /usr/bin/passwd &#10;-rwsr-xr-x 1 root root 54256 3&#26376;  29 17:25 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p><code>passwd</code>是一个二进制程序，它的所有者是root，但是当我们用用户身份登入时一样可以执行该程序并修改自己的密码（这回修改/etc/shadow文件）。这是因为<code>passwd</code>拥有SUID权限。</p>
<h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><p>当s标志在用户组的x时，成为<code>SET GID</code>，即SGID。SGID可以作用于一个文件，也可以作用于一个目录。</p>
<p>当作用于一个文件时：</p>
<ol>
<li>SGID对二进制程序有效</li>
<li>程序执行者对该程序有执行的权限</li>
<li>执行者在执行的过程中可以得到程序所在用户组的权限。</li>
</ol>
<p>当作用于一个目录时：</p>
<ol>
<li>用户若对此目录有r和x的权限，该用户能够进入此目录（前提）</li>
<li>用户在目录下的有效用户组将会变成该目录的用户组</li>
<li>若用户在此目录下具有w的权限，则用户所创建的文件将与此目录的用户组相同。</li>
</ol>
<h3 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h3><p>SBIT（Sticky Bit）只对目录有效。它对目录的作用是：</p>
<ol>
<li>当用户对此目录有w和x的权限，即具有写入权限时（前提）</li>
<li>当用户在该目录下创建文件或目录时，仅自己与root才有权限删除该文件。</li>
</ol>
<p>如果一个目录D有SBIT权限，当用户A在D下只能对自己创建的文件或目录进程删除、重命名、移动等操作，而无法删除他人的文件。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.JPG"
               alt="Zach" />
          <p class="site-author-name" itemprop="name">Zach</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zach</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("ntwSG1Uc9Pv9VSd5ODUsFYkK-gzGzoHsz", "HoWAvsNTJHhdUmXFuqT6j4vp");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
