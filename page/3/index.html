<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Zach的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Zach的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zach的博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>







  <title> Zach的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zach的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">这个人很懒，都不知道说些什么 :(</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/19/IPv4与IPv6的户操作性/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/IPv4与IPv6的户操作性/" itemprop="url">
                  IPv4与IPv6的户操作性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/19/IPv4与IPv6的户操作性/" class="leancloud_visitors" data-flag-title="IPv4与IPv6的户操作性">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IPv4_u6620_u5C04_u7684IPv6_u5730_u5740"><a href="#IPv4_u6620_u5C04_u7684IPv6_u5730_u5740" class="headerlink" title="IPv4映射的IPv6地址"></a>IPv4映射的IPv6地址</h1><p>IPv4映射的IPv6地址允许在因特网向IPv6过度时期让运行在双栈主机上的IPv6应用进程能够与只支持IPv4的主机通信。这些地址是IPv6应用进程查询某个只有IPv4地址的主机的IPv6地址时，DNS解析器按需自动创建的且不存在于任何DNS<br>数据文件中。在IPv6套接字上使用这种类型的地址导致往目的地IPv4主机发送IPv4数据报。</p>
<p>下图展示了一个IPv4映射的IPv6地址的格式：</p>
<img src="/2016/09/19/IPv4与IPv6的户操作性/mapped.png" alt="mapped.png" title="">
<h1 id="IPv4_u5BA2_u6237_u4E0EIPv6_u670D_u52A1_u5668"><a href="#IPv4_u5BA2_u6237_u4E0EIPv6_u670D_u52A1_u5668" class="headerlink" title="IPv4客户与IPv6服务器"></a>IPv4客户与IPv6服务器</h1><p>双栈主机的一个特性就是其上的IPv6服务器既可以处理IPv4客户，也可以处理IPv6客户。这是通过IPv4映射的IPv6地址实现的。下图是一个例子：</p>
<img src="/2016/09/19/IPv4与IPv6的户操作性/ipv4to6.png" alt="ipv4to6.png" title="">
<p>IPv4客户发送一个IPv4的SYN分节以期和服务器建立连接。来自IPv4客户的SYN分节在以太网中表现为一个以太网首部、一个IPv4首部、一个TCP部以及TCP数据。以太网首部中包含的类型字段为0x0800，表示它是一个IPv4帧数据。</p>
<p>接收数据链路通过查看以太网类型字段把每个帧数据发送给对应的IP模块。IPv4模块结合其上的TCP模块检测到IPv4数据报的目的段端口对应一个IPv4套接字，于是该数据报Ipv4首部中的源IPv4地址被转换成IPv4映射的IPv6地址，当<br>accept系统调用把这个已经接收的IPv4客户连接返回被服务器进程的时候，这个映射后的地址作为客户的IPv6地址返回到服务器的IPv6套接字。该连接上的其余数据同样都是IPv4数据报。服务器进程完全不知道它是在与一个IPv4客户机通信。</p>
<h1 id="IPv6_u5BA2_u6237_u4E0EIPv4_u670D_u52A1_u5668"><a href="#IPv6_u5BA2_u6237_u4E0EIPv4_u670D_u52A1_u5668" class="headerlink" title="IPv6客户与IPv4服务器"></a>IPv6客户与IPv4服务器</h1><p>在一个双栈主机上运行一个IPv6客户程序，其于一个IPv4服务器程序交互的流程如下：</p>
<ol>
<li>一个IPv4服务器在只支持IPv4的一个主机上启动后创建一个IPv4监听套接字。</li>
<li>IPv6客户启动后调用getaddrinfo单纯查找IPv6地址（请求AF_INET6地址，hints结构中设置了AI_V4MAPPED标志），最后只有得到只支持IPv4的服务器主机的A记录，那么返回给客户的就是IPv4映射之后的IPv6地址。</li>
<li>IPv6客户设置这个IPv4映射后的IPv6地址，调用connect，内核检测到这个映射的地址后自动发送一个IPv4的SYN分节到服务器。</li>
<li>服务器响应一个IPv4 SYN/ACK分节，连接于是用IPv4数据报建立。</li>
</ol>
<p>以后在以太网上传递的是IPv4数据报。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/19/系统服务——daemon/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/系统服务——daemon/" itemprop="url">
                  系统服务——daemon
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/19/系统服务——daemon/" class="leancloud_visitors" data-flag-title="系统服务——daemon">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h1><h3 id="u4EC0_u4E48_u662Fdaemon"><a href="#u4EC0_u4E48_u662Fdaemon" class="headerlink" title="什么是daemon"></a>什么是daemon</h3><p>简单来说，系统为了某些功能必须提供一些服务，这个服务我们称之为<code>service</code>，但是service的提供需要进程的运行，所以实现这个service的程序我们称之为<code>daemon</code>。我们不必<br>区分daemon与service，或者说可以将他们视为等同的。因为没有daemon在后台运行就不会有这个serivce。daemon没有控制终端，所以当有事发生时，它们需要有消息输出的方法可用。<br><code>syslog</code>函数是输出这些消息的标准方法，它把这些消息发送给<code>syslogd</code>守护进程。</p>
<p>syslogd的函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *message, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>priority</code>由level和facility组成，具体可以查看UNP P288。</p>
<h3 id="daemon_u7684_u4E3B_u8981_u5206_u7C7B"><a href="#daemon_u7684_u4E3B_u8981_u5206_u7C7B" class="headerlink" title="daemon的主要分类"></a>daemon的主要分类</h3><p>如果按照启动与管理方式分类：</p>
<ul>
<li>stand alone：这种类型的daemon不必通过其他机制来管理，可以自行启动，一旦启动就常驻内存。其最大的优点是由于一直在内存内持续的提供服务，因此对于客户的请求响应较快。常见的<br>stand alone的daemon有ftp、httpd等。</li>
<li>super daemon：一个特殊的daemon来统一管理其他的daemon。这一种服务的启动方式通过同一个daemon来负责唤起服务。这个特殊的daemon被称为super daemon。早期的super daemon是inetd，现在<br>Linux下是xinetd。当客户没有请求时，对应的服务未启动，只有当客户有对应的请求来到时，super daemon才会唤醒相应的服务，当请求完成之后，被唤醒的这个服务也会关闭并释放资源。该机制的优点在于：１）super daemon<br>可以具有安全管控机制；２）服务在请求结束后就关闭，不会一直占用资源。缺点在于对于请求的响应较慢。</li>
</ul>
<p>如果按照工作形态分类：</p>
<ul>
<li>signal-control：这种daemon通过信号来管理，只要有任何客户端的请求进来，它就会立即启动取处理。</li>
<li>interval-control：这种daemon每隔一段时间就主动取执行某项工作。</li>
</ul>
<h3 id="u5C06_u4E00_u4E2A_u7A0B_u5E8F_u4F5C_u4E3Adaemon_u8FD0_u884C"><a href="#u5C06_u4E00_u4E2A_u7A0B_u5E8F_u4F5C_u4E3Adaemon_u8FD0_u884C" class="headerlink" title="将一个程序作为daemon运行"></a>将一个程序作为daemon运行</h3><p>Linux提供了<code>daemon</code>函数将一个普通进程转变为守护进程运行。它的原理和这里给出的<code>daemon_init</code>函数大同小异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pname, <span class="keyword">int</span> facility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child continues */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* become session leader */</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 必须忽略SIGHUP，否则当会话头进程终止时，会话中的所有进程都收到SIGHUP信号 */</span></span><br><span class="line">    Signal(SIGHUP, SIG_IGN);</span><br><span class="line">    <span class="comment">/* 再次Fork，使得进程不再是会话头 */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid)</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    daemon_proc = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXFD; i++)</span><br><span class="line">	close(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* redirec stdin, stdout and stderr to '/dev/null' */</span></span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDONLY);</span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    openlog(pname, LOG_PID, facility);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先是fork，在fork结束之后，父进程终止，子进程自动在后台运行。另外，由于子进程继承了父进程的进程组ID，这保证了子进程不是一个进程组的头进程，这为下面的setsid做了准备。</li>
<li>setsid，其用于创建一个新的会话，当前进程变为新的会话的会话头进程以及新进程组的进程组头进程，从而不再有控制终端。</li>
<li>忽略SIGHUP信号并再次fork，再次fork保证本守护进程不会是会话头进程，那么即使将来打开了一个终端设备，也不会自动获得控制终端。因为当没有控制终端的会话头进程打开一个终端设备时，该终端会自动成为<br>这个会话头进程的控制终端。忽略SIGHUP信号是因为当会话头进程终止时，其会话中的所有进程（再次fork产生的子进程）都收到SIGHUP信号。</li>
<li>将stdin、stdout以及stderr重定向到/dev/null，打开这些描述符的理由在于，守护进程调用的那些假设能从这三个描述符读写的库函数不会因为这些描述符未打开而失败。</li>
<li>调用syslog处理函数。</li>
</ol>
<p>既然守护进程在没有控制终端的环境下运行，那么它绝对不会收到来自内核的SIGHUP信号，许多守护进程因此把这个信号作为来自系统管理员的一个通知，表示其配置文件已经发生变化，守护进程应该重新读入配置文件。</p>
<h1 id="Linux_u4E0Bdaemon_u7684_u542F_u52A8_u811A_u672C_u548C_u542F_u52A8_u65B9_u5F0F"><a href="#Linux_u4E0Bdaemon_u7684_u542F_u52A8_u811A_u672C_u548C_u542F_u52A8_u65B9_u5F0F" class="headerlink" title="Linux下daemon的启动脚本和启动方式"></a>Linux下daemon的启动脚本和启动方式</h1><h3 id="u914D_u7F6E_u6587_u4EF6_u4F4D_u7F6E"><a href="#u914D_u7F6E_u6587_u4EF6_u4F4D_u7F6E" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><p>通常daemon的启动脚本放在/etc/init.d/目录下，启动脚本可以进程环境检测、配置文件分析、PID文件放置以及相关重要交换文件的锁操作。</p>
<p>super daemon的配置文件放置在/etc/xinetd.d/目录和/etc/xinetd.conf中。</p>
<p>在/etc/目录下还有各自服务的配置文件</p>
<p>/var/lib/目录下是一些会产生数据的服务放置产生的数据库的位置，数据库管理系统MySQL的数据库默认写入/var/lib/mysql。</p>
<p>/var/run/目录下存放各服务程序的PID记录。</p>
<p>对于stand alone的daemon，我们即可执行/etc/init.d/目录下的脚本来启动它，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ /etc/init.d/mysql start</span><br></pre></td></tr></table></figure>
<p>也可以利用service命令（实际上它也是一个stand alone的服务）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ service mysql start</span><br></pre></td></tr></table></figure>
<h3 id="super_daemon_u914D_u7F6E_u6587_u4EF6"><a href="#super_daemon_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="super daemon配置文件"></a>super daemon配置文件</h3><p>Linux下super daemon由xinetd这个进程实现，它不仅可以启动其他daemon，还可以进行安全性或者其他管理机制的控制。xinetd的默认配置存放在/etc/xinetd.conf中，由xinetd启动的服务程序的配置放置在/etc/xinetd.d目录下。<br>如果一个服务的配置文件没有xinetd.conf中指定的参数，那么该服务对应的参数就以xinetd.conf中的为准。具体的参数说明可以参加《鸟哥——基础篇》P559。一个简单的daytime服务配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mydaytime&#10;&#123;&#10;        disable         = no&#10;        socket_type     = stream&#10;        wait            = no&#10;        user            = root&#10;        server          = /home/zach41/Desktop/unp/unpv13e/inetd/daytimetcpsrv3&#10;        log_on_failure  = USERID&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这之后我们还需要修改/etc/services文件，分配一个端口来提供daytime服务。具体就是添加如下一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydaytime    9999/tcp</span><br></pre></td></tr></table></figure>
<p>这样配置之后，我们重启xinetd服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ service xinetd restart&#10;&#10140;  ~ sudo netstat -tnlp | grep 9999&#10;[sudo] password for zach41: &#10;tcp        0      0 0.0.0.0:9999            0.0.0.0:*               LISTEN      15914/xinetd</span><br></pre></td></tr></table></figure>
<p>可以看到xinetd进程在监听9999端口。</p>
<p>我们运行一个daytime客户端程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  names git:(master) &#10007; ./daytimetcpcli2 0.0.0.0 9999&#10;trying 0.0.0.0:9999&#10;Mon Sep 19 18:43:04 2016</span><br></pre></td></tr></table></figure>
<h3 id="daytime_daemon_u7A0B_u5E8F"><a href="#daytime_daemon_u7A0B_u5E8F" class="headerlink" title="daytime daemon程序"></a>daytime daemon程序</h3><p>最后这里给出daytimeserver的代码，这是由xinetd作为守护进程启动的时间获取服务器程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>	<span class="string">"unp.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>	<span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">socklen_t</span>		len;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr	*cliaddr;</span><br><span class="line">	<span class="keyword">char</span>			buff[MAXLINE];</span><br><span class="line">	<span class="keyword">time_t</span>			ticks;</span><br><span class="line"></span><br><span class="line">	daemon_inetd(argv[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cliaddr = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">	len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">	Getpeername(<span class="number">0</span>, cliaddr, &amp;len);</span><br><span class="line">	err_msg(<span class="string">"connection from %s"</span>, Sock_ntop(cliaddr, len));</span><br><span class="line"></span><br><span class="line">    ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">"%.24s\r\n"</span>, ctime(&amp;ticks));</span><br><span class="line">    Write(<span class="number">0</span>, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">	Close(<span class="number">0</span>);	<span class="comment">/* close TCP connection */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到所有套接字的创建代码(tcp_listen和accept的调用)都不见了，这些步骤都有xinetd执行，我们使用描述符0指代已由xinetd接受的TCP连接（套接字描述符被复制到描述符0, 1, 2）。daemon_init只是负责设置daemon_proc<br>标志以及调用openlog，从而发送日志信息给syslogd守护进程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/13/套接字选项/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/套接字选项/" itemprop="url">
                  套接字选项
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/13/套接字选项/" class="leancloud_visitors" data-flag-title="套接字选项">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u4FEE_u6539_u5957_u63A5_u5B57_u9009_u9879"><a href="#u4FEE_u6539_u5957_u63A5_u5B57_u9009_u9879" class="headerlink" title="修改套接字选项"></a>修改套接字选项</h1><p>有几种方法来修改和获取套接字的选项：</p>
<ul>
<li>getsockopt &amp; setsockopt</li>
<li>fcntl</li>
<li>ioctl</li>
</ul>
<h3 id="getsockopt__26amp_3B_setsockopt"><a href="#getsockopt__26amp_3B_setsockopt" class="headerlink" title="getsockopt &amp; setsockopt"></a>getsockopt &amp; setsockopt</h3><p>这两个函数仅仅用于套接字。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, socklen_t *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, socklen_t optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockfd必须指向一个已经打开的套接字，level指向系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码（如TCP、IPv4、IPv6或SCTP）。</p>
<p>optval指向某个变量，变量的大小由最后一个参数optlen指定，setsockopt从optval中取得待设置的新值，而getsockopt把获取到的值存入对应的地址中。</p>
<p>套接字选项粗分为两大基本类型：</p>
<ul>
<li>启用或禁止某个特性的标志选项(flag = 0禁止特性，flag = 1开启特性)</li>
<li>取得并返回我们可以设置或检查的特定值选项，即值选项。</li>
</ul>
<p>套接字选项可以参见UNP的P151</p>
<h1 id="u901A_u7528_u5957_u63A5_u5B57_u9009_u9879_uFF08_u90E8_u5206_uFF09"><a href="#u901A_u7528_u5957_u63A5_u5B57_u9009_u9879_uFF08_u90E8_u5206_uFF09" class="headerlink" title="通用套接字选项（部分）"></a>通用套接字选项（部分）</h1><p>这里仅仅列出部分的通用套接字选项，其实也就是挑了一些自己看得懂的选项记录下。</p>
<h3 id="SO_BROADCAST"><a href="#SO_BROADCAST" class="headerlink" title="SO_BROADCAST"></a>SO_BROADCAST</h3><p>开启或禁止进程发送广播消息的能力。只有数据报支持广播，并且还是在支持广播消息的网络上（以太网、令牌网络等）。</p>
<h3 id="SO_DEBUG"><a href="#SO_DEBUG" class="headerlink" title="SO_DEBUG"></a>SO_DEBUG</h3><p>仅由TCP支持，当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和接收的所有分组保留详细的跟踪信息，这些信息保存在内核的某个环形缓冲区中，并可使用trpt程序进行检查。</p>
<h3 id="SO_ERROR"><a href="#SO_ERROR" class="headerlink" title="SO_ERROR"></a>SO_ERROR</h3><p>当一个套接字上发生错误时，内核将套接字的名为so_error的变量设置为标准的Unix Exxx值中的一个，它被成为该套接字的待处理错误(pending error)，内核以以下方式通知进程这个错误：</p>
<ol>
<li>如果进程阻塞在套接字的select调用上，那么无论是检查可读条件还是可读可写条件，select均返回并设置其中一个或所有的条件。</li>
<li>如果进程使用信号驱动I/O模型，那么进程或进程组就会接收到内核产生的SIGIO信息。</li>
</ol>
<p>进程在被内核通知之后，可以通过访问SO_ERROR套接字选项获得so_error的值，由getsockopt返回的整数即待处理错误，随后so_error由内核复位成0。</p>
<p>这个套接字选项可以获取，但是不能设置。</p>
<h3 id="SO_KEEPALIVE"><a href="#SO_KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>给一个套接字设置保持存活(keep-alive)选项后，如果2小时内在该套接字的任意一个方向上没有数据交换，那么TCP就会自动给对端发送一个保持存活的探测分节(keep-alive probe)，这是一个对端必须响应的TCP分节，它<br>会导致以下三种情况之一：</p>
<ol>
<li>对端以期望的ACK响应，一切正常</li>
<li>对端以RST响应，对端已经崩溃并重启，套接字的待处理错误被置为ECONNRESET，套接字本身被关闭。</li>
<li>对端对保持存活的探测分节没有响应，TCP间隔一段时间再次发送探测分节，多次之后若还是没有响应，则放弃套接字的待处理错误被置为ETIMEOUT，如果收到一个ICMP错误作为某个探测分节的响应，就返回相应的错误，套接字本身被关闭。</li>
</ol>
<h3 id="SO_LINGER"><a href="#SO_LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><p>指定close函数对面向连接的协议(TCP和SCTP)如何操作。默认的行为是立即返回，如果这时候发送缓冲区有数据残留，系统会尝试把数据发送给对方。选项要求用户进程和内核间传递如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> linger &#123;</span><br><span class="line">	<span class="keyword">int</span> l_onoff;</span><br><span class="line">	<span class="keyword">int</span> l_linger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果l_onoff = 0，l_linger被忽略，选项关闭</li>
<li>l_onoff非0，<ul>
<li>l_linger = 0，那么TCP丢弃发送缓冲区内的任何数据，并发送一个RST给对端，不会再有四次挥手。</li>
<li>l_linger不为0，进程被阻塞，知道所有发送缓冲区的数据都发送完毕并被对方确认，或者是超过了l_linger指定的时间，如果超时，close返回EWOULDBLOCK错误。</li>
</ul>
</li>
</ol>
<p>假设客户在发送玩数据后调用了close函数，close可能在服务器读套接字接收缓冲区中的剩余数据之前就返回，在应用程序读数据之前服务器可能就会崩溃，而客户进程永远不会知道。<br>如果设置了SO_LINGER套接字，那么在调用close函数后，应用进程阻塞一段时间，等待数据全部发送并被对方确认（如图所示）。但是这里还有一个问题，延滞的时间可能不够，close仍然会返回EWOULDBLOCK错误，而且close的成功返回只是告诉我们先前发送的数据已经由对方确认，并不能告诉我们应用进程是否读取了数据。</p>
<img src="/2016/09/13/套接字选项/so_linger.png" alt="so_linger.png" title="">
<p>让客户进程知道服务器已经读取数据的一个方法是改用shutdown（设置SHUT_WR），改用之后的流程如下图：</p>
<img src="/2016/09/13/套接字选项/shutdown_linger.png" alt="shutdown_linger.png" title="">
<p>另外一个方法是应用程序自己做确认。客户在向服务器发送完数据后，调用read来读取一个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ack;</span><br><span class="line"></span><br><span class="line">Write(sockfd, data, nbytes);</span><br><span class="line">n = read(sockfd, &amp;ack, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>服务器读取来自客户端的数据后发回一个字节的ACK。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nbytes = Read(sockfd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"></span><br><span class="line">Write(sockfd, <span class="string">""</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="SO_RCVBUF__26amp_3B_SO_SNDBUF"><a href="#SO_RCVBUF__26amp_3B_SO_SNDBUF" class="headerlink" title="SO_RCVBUF &amp; SO_SNDBUF"></a>SO_RCVBUF &amp; SO_SNDBUF</h3><p>每一个套接字有一个发送和接收缓冲区，可以利用SO_RCVBUF和SO_SNDBUF选项来修改默认的缓冲区大小。需要注意的是，由于TCP的窗口规模是在建立连接时用SYN分节与对端呼唤a的都的。对于客户端，意味着<br>SO_RCVBUF必须在connect调用之前设置；对于服务端，该选项必须在调用Listen之前设置。</p>
<h3 id="SO_RCVLOWAT__26amp_3B_SO_SNDLOWAT"><a href="#SO_RCVLOWAT__26amp_3B_SO_SNDLOWAT" class="headerlink" title="SO_RCVLOWAT &amp; SO_SNDLOWAT"></a>SO_RCVLOWAT &amp; SO_SNDLOWAT</h3><p>每一个套接字还有一个接收和发送低水位标志，由select使用，用SO_RCVLOWAT和SO_SNDLOWAT可以修改低水位标志的值。</p>
<p>接收低水位标志是让select返回可读时套接字接收缓冲区所需要的最少的数据量。<br>发送低水位标志是让select返回可写是套接字发送缓冲区可存入的最少数据量。</p>
<p>两个低水位的默认值都为1</p>
<h3 id="SO_RCVTIMEO__26amp_3B_SO_SNDTIMEO"><a href="#SO_RCVTIMEO__26amp_3B_SO_SNDTIMEO" class="headerlink" title="SO_RCVTIMEO &amp; SO_SNDTIMEO"></a>SO_RCVTIMEO &amp; SO_SNDTIMEO</h3><p>这两个选项允许我们给套接字的接收和发送设置一个超时值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/12/Linux文件与目录的默认、隐藏和特殊权限/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/Linux文件与目录的默认、隐藏和特殊权限/" itemprop="url">
                  Linux文件与目录的默认、隐藏和特殊权限
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/12/Linux文件与目录的默认、隐藏和特殊权限/" class="leancloud_visitors" data-flag-title="Linux文件与目录的默认、隐藏和特殊权限">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u9ED8_u8BA4_u6743_u9650"><a href="#u9ED8_u8BA4_u6743_u9650" class="headerlink" title="默认权限"></a>默认权限</h1><p>在Linux下创建一个文件或者目录的默认权限和<code>umask</code>相关，umask指定“当前用户在创建文件或者目录时的权限默认值”。用umask来查看文件或目录的默认权限值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ umask&#10;002</span><br></pre></td></tr></table></figure>
<p>需要注意的是umask指定文件或目录的默认值应该减去的数值。而对于一个文件，默认值是“-rw-rw-rw”，对一个目录，默认值是“drwxrwxrwx”，举例来说，如果当前用户创建了一个文件，那么文件的权限默认值就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-rw-rw-rw-) - (--------w-) =&#62; -rw-rw-r--</span><br></pre></td></tr></table></figure>
<h1 id="u9690_u85CF_u5C5E_u6027"><a href="#u9690_u85CF_u5C5E_u6027" class="headerlink" title="隐藏属性"></a>隐藏属性</h1><p>可以利用<code>chattr</code>和<code>lsattr</code>来修改和查看文件或目录的隐藏属性。需要注意的是这两个命令只在Ext2/Ext3文件系统上有效。</p>
<p>命令使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [+-=] [ASacdistu] files...</span><br></pre></td></tr></table></figure>
<p>这里只说明两个参数，其余可以参见manual</p>
<ul>
<li>i: 让一个文件不能被删除、改名、设置连接、写入或添加数据。只有root才能设置该属性。</li>
<li>a: 设置a之后，这个文件只能添加数据，而不能删除也不能修改数据，只有root才能设置该属性。</li>
</ul>
<p>lsattr查看隐藏属性，用法简单，可以直接查看manual</p>
<h1 id="u6587_u4EF6_u7279_u6B8A_u6743_u9650"><a href="#u6587_u4EF6_u7279_u6B8A_u6743_u9650" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h1><p>Linux有三个特殊权限：</p>
<ul>
<li>SUID</li>
<li>SGID</li>
<li>SBIT</li>
</ul>
<h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><p>当s标志出现在文件所有者的x权限上时，此时就被成为<code>SET UID</code>，即SUID的特殊权限。</p>
<p>SUID有这样的功能和限制：</p>
<ol>
<li>仅仅对二进制程序有效</li>
<li>执行者对该程序具有科执行的权限</li>
<li>本权限仅仅在执行过程中有效</li>
<li>执行者将拥有该程序所有者的权限（仅在执行过程中）</li>
</ol>
<p>举例来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ ls -l /usr/bin/passwd &#10;-rwsr-xr-x 1 root root 54256 3&#26376;  29 17:25 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p><code>passwd</code>是一个二进制程序，它的所有者是root，但是当我们用用户身份登入时一样可以执行该程序并修改自己的密码（这回修改/etc/shadow文件）。这是因为<code>passwd</code>拥有SUID权限。</p>
<h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><p>当s标志在用户组的x时，成为<code>SET GID</code>，即SGID。SGID可以作用于一个文件，也可以作用于一个目录。</p>
<p>当作用于一个文件时：</p>
<ol>
<li>SGID对二进制程序有效</li>
<li>程序执行者对该程序有执行的权限</li>
<li>执行者在执行的过程中可以得到程序所在用户组的权限。</li>
</ol>
<p>当作用于一个目录时：</p>
<ol>
<li>用户若对此目录有r和x的权限，该用户能够进入此目录（前提）</li>
<li>用户在目录下的有效用户组将会变成该目录的用户组</li>
<li>若用户在此目录下具有w的权限，则用户所创建的文件将与此目录的用户组相同。</li>
</ol>
<h3 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h3><p>SBIT（Sticky Bit）只对目录有效。它对目录的作用是：</p>
<ol>
<li>当用户对此目录有w和x的权限，即具有写入权限时（前提）</li>
<li>当用户在该目录下创建文件或目录时，仅自己与root才有权限删除该文件。</li>
</ol>
<p>如果一个目录D有SBIT权限，当用户A在D下只能对自己创建的文件或目录进程删除、重命名、移动等操作，而无法删除他人的文件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/11/UIStackView初探/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/UIStackView初探/" itemprop="url">
                  UIStackView初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/11/UIStackView初探/" class="leancloud_visitors" data-flag-title="UIStackView初探">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h1><p>iOS9引入了<code>UIStackView</code>，Apple文档对UIStackView的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The UIStackView class provides a streamlined interface for laying out a collection of views in either a column or a row. &#10;Stack views let you leverage the power of Auto Layout, creating user interfaces that can dynamically adapt to the device&#8217;s &#10;screen size, and any changes in the available space</span><br></pre></td></tr></table></figure>
<p>即，利用<code>UIStackView</code>我们可以很方便地垂直或水平排列多个subview。</p>
<h1 id="u914D_u7F6EUIStackView"><a href="#u914D_u7F6EUIStackView" class="headerlink" title="配置UIStackView"></a>配置UIStackView</h1><p><code>UIStackView</code>有以下几个配置选项让我们来配置它：</p>
<ol>
<li><code>Axis</code>：表示水平排列还是垂直排列</li>
<li><code>Alignment</code>：控制subview的对齐方式</li>
<li><code>Distribution</code>：控制subview的分布方式</li>
<li><code>Spacing</code>：subview间的最小距离</li>
</ol>
<p><code>Alignment</code>因<code>Axis</code>而异，用图示说明更加形象。</p>
<h4 id="u6C34_u5E73_u6392_u5217"><a href="#u6C34_u5E73_u6392_u5217" class="headerlink" title="水平排列"></a>水平排列</h4><img src="/2016/09/11/UIStackView初探/align_h.png" alt="align_h.png" title="">
<h4 id="u5782_u76F4_u6392_u5217"><a href="#u5782_u76F4_u6392_u5217" class="headerlink" title="垂直排列"></a>垂直排列</h4><img src="/2016/09/11/UIStackView初探/align_v1.png" alt="align_v1.png" title="">
<img src="/2016/09/11/UIStackView初探/align_v2.png" alt="align_v2.png" title="">
<h4 id="u6CE8_u610F"><a href="#u6CE8_u610F" class="headerlink" title="注意"></a>注意</h4><p><code>UIStackView</code>会被当成一个Container View，它不会像其他UIView一样被渲染，所以类似与设置背景或者是重载drawRect方法都是没有任何效果的。</p>
<h1 id="u7BA1_u7406Subview"><a href="#u7BA1_u7406Subview" class="headerlink" title="管理Subview"></a>管理Subview</h1><p><code>UIStackView</code>有两个属性</p>
<ul>
<li>arrangedSubviews</li>
<li>subviews</li>
</ul>
<p>如果我们想添加一个subview让StackView来管理，只要调用<code>addArrangedSubview(_ view: UIView)</code>或者<code>insertArrangedSubview(_ view: UIView, at stackIndex: Int)</code>即可，但是如果要删除一个被StackView管理的subview，那么我们需要主注意到<br><code>removeArrangedSubview(_ view: UIView)</code>函数只是让对应的subview不让StackView来管理它的约束，它并没有从当前的视图层级从移除，如果要移除视图，我们需要显示调用<code>removeFromSuperview()</code>。</p>
<h1 id="u7B80_u5355_u7684_u4F8B_u5B50"><a href="#u7B80_u5355_u7684_u4F8B_u5B50" class="headerlink" title="简单的例子"></a>简单的例子</h1><p>参考</p>
<ul>
<li><a href="http://code.tutsplus.com/tutorials/ios-9-getting-started-with-uistackview--cms-24193" target="_blank" rel="external">iOS 9: Getting Started with UIStackView</a></li>
<li><a href="https://www.raywenderlich.com/114552/uistackview-tutorial-introducing-stack-views" target="_blank" rel="external">UIStackView-Tutorial-Introducing-Stack-Views</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/09/TCP连接建立和终止/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/09/TCP连接建立和终止/" itemprop="url">
                  TCP连接建立和终止
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/09/TCP连接建立和终止/" class="leancloud_visitors" data-flag-title="TCP连接建立和终止">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP_u8FDE_u63A5_u7684_u5EFA_u7ACB_u548C_u7EC8_u6B62"><a href="#TCP_u8FDE_u63A5_u7684_u5EFA_u7ACB_u548C_u7EC8_u6B62" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h1><h3 id="TCP_u8FDE_u63A5_u5EFA_u7ACB"><a href="#TCP_u8FDE_u63A5_u5EFA_u7ACB" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><p>建立一个TCP连接的过程图示如下（图片均来源于网络…）：</p>
<img src="/2016/09/09/TCP连接建立和终止/shakehand3.jpg" alt="shakehand3.jpg" title="">
<ol>
<li>服务器在连接建立之前必须准备好接收客户发来的连接，这一般通过创建套接字，绑定服务器地址、监听套接字来完成，即<code>socket</code>，<code>bind</code>，<code>listen</code>三个函数。这一个过程被成为被动打开。</li>
<li>客户通过<code>connect</code>函数发起主动打开，客户会发送一个SYN分节，它告诉服务器客户将在连接中发送的数据的初始序列号，通常该分节不带数据，其所在IP数据只含有一个IP首部、一个TCP首部以及可能的TCP选项。</li>
<li>服务器收到客户发来的SYN分节后，服务器必须确认该分节，同时服务器发送一个自己的SYN分节，它含有服务器将在该连接中发送的数据的初始序列号。</li>
<li>客户收到服务器发回的消息后，确认服务器的分节，连接建立。</li>
</ol>
<p>从图中可以看到ACK是SYN分节的序列号加１，类似的，FIN分节的ACK也是FIN分节的序列号加１。</p>
<h3 id="TCP_u8FDE_u63A5_u7EC8_u6B62"><a href="#TCP_u8FDE_u63A5_u7EC8_u6B62" class="headerlink" title="TCP连接终止"></a>TCP连接终止</h3><p>TCP终止一个连接需要４个分节。</p>
<p>终止一个连接的图示如下：</p>
<img src="/2016/09/09/TCP连接建立和终止/shakehand4.jpg" alt="shakehand4.jpg" title="">
<ol>
<li>某个应用首先调用close，该端主动关闭，发送一个FIN分节</li>
<li>接收到FIN分节的对端执行被动关闭，这个FIN由TCP确认，FIN分节的接收也作为一个文件结束符（EOF）传递给接收端应用进程。</li>
<li>一段时间之后，接收到这个文件结束符的引用进程将调用close关闭它的套接字，这会导致它也发送一个FIN分节。</li>
<li>接收这个最终FIN的对端发送一个ACK确认这个FIN分节。</li>
</ol>
<h3 id="u8FDE_u63A5_u548C_u7EC8_u6B62"><a href="#u8FDE_u63A5_u548C_u7EC8_u6B62" class="headerlink" title="连接和终止"></a>连接和终止</h3><p>一个完整的连接和终止的过程示意：</p>
<img src="/2016/09/09/TCP连接建立和终止/full_process.jpg" alt="full_process.jpg" title="">
<p>一个完整的TCP状态转换图：</p>
<img src="/2016/09/09/TCP连接建立和终止/state.jpg" alt="state.jpg" title="">
<h4 id="TIME_WAIT"><a href="#TIME_WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>TCP终止中，执行了主动关闭的那端在接收到对端发来的FIN分节和发送对应的ACK之后就进入了TIME_WAIT状态，该状态的持续时间是2个MSL（maximum segment lifetime）。它的存在有两个理由：</p>
<ol>
<li>可靠地实现TCP全双工连接的终止</li>
<li>允许老的重复分节在网络中消逝</li>
</ol>
<p>对于第一个理由，如果最后的ACK丢失了，那么服务器需要重发FIN，因此客户必须维护状态信息，以允许它发送最终的那个ACK，如果客户不维护状态信息，那么客户在收到服务器重传的FIN后将直接相应RST，这个分节将会被服务器解释为一个错误。</p>
<p>对于第二个理由，假设在一个连接被终止了马上又发起来一个相同IP和端口上的连接，后一个连接成为前一个连接的化身，TCP必须防止老的连接的分组在老连接结束之后再现，以防止其被误解为新的连接的分组。TCP不会让处于TIME_WAIT状态的连接发起新的化身，既然TIME_WAIT的时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL时间即被丢弃，另外一个方向上的应答最多存活MSL时间也被丢弃。通过这种方式，老的重复分组在网络中都已经消逝。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/09/IO模型/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/09/IO模型/" itemprop="url">
                  I/O模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/09/IO模型/" class="leancloud_visitors" data-flag-title="I/O模型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="I/O_u6A21_u578B_u7684_u79CD_u7C7B"><a href="#I/O_u6A21_u578B_u7684_u79CD_u7C7B" class="headerlink" title="I/O模型的种类"></a>I/O模型的种类</h1><p>Unix环境下可用的5种I/O模型分别为：</p>
<ul>
<li>阻塞式I/Ob</li>
<li>非阻塞式I/O</li>
<li>I/O复用（select和poll）</li>
<li>信号驱动I/O（SIGIO）</li>
<li>异步I/O（POSIX的aio_系列函数）</li>
</ul>
<p>一个输入操作的通常包括两个步骤：</p>
<ol>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ol>
<h2 id="u963B_u585E_u5F0FI/O_u6A21_u578B"><a href="#u963B_u585E_u5F0FI/O_u6A21_u578B" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h2><img src="/2016/09/09/IO模型/io_block.png" alt="io_block.png" title="">
<p>在图示中，进程调用<code>recvfrom</code>，其系统调用直到数据到达且被复制到应用进程的缓冲区中或者发生错误才返回，最常见的错误就是被信号中断。</p>
<h2 id="u975E_u963B_u585EI/O_u6A21_u578B"><a href="#u975E_u963B_u585EI/O_u6A21_u578B" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h2><img src="/2016/09/09/IO模型/io_nonblock.png" alt="io_nonblock.png" title="">
<p>从图示中我们可以看出，当recvfrom没有数据可返回时，内核立即返回一个<code>EWOULDBLOCK</code>错误；如果有数据准备好了，那么s内核开始将数据复制到应用进程缓冲区，于是recvfrom成功返回。</p>
<p>这样一种对一个非阻塞描述符循环调用recvfrom的方式，我们称之为<code>polling</code>。</p>
<h2 id="I/O_u590D_u7528_u6A21_u578B"><a href="#I/O_u590D_u7528_u6A21_u578B" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h2><img src="/2016/09/09/IO模型/io_multiplexing.png" alt="io_multiplexing.png" title="">
<p>I/O复用模型中，我们的进程阻塞于select或者poll函数，而不是阻塞在真正的I/O系统调用上，当某一个描述符数据准备好时，我们的进程被唤醒，从而可以处理数据，通过I/O复用模型，我们可以让应用进程等待多个I/O的操作完成，而不是单单阻塞于一个I/O操作。</p>
<h2 id="u4FE1_u53F7_u9A71_u52A8_u7684I/O_u6A21_u578B"><a href="#u4FE1_u53F7_u9A71_u52A8_u7684I/O_u6A21_u578B" class="headerlink" title="信号驱动的I/O模型"></a>信号驱动的I/O模型</h2><img src="/2016/09/09/IO模型/io_signal.png" alt="io_signal.png" title="">
<p>信号驱动模型在数据就绪时通过发送<code>SIGIO</code>通知应用进程，应用进程收到信号后可以在信号处理函数中调用recvfrom读取数据。这种模式的优势在于等待数据报到达期间，进程不会被阻塞，主循环可继续执行。但是在内核复制数据到应用进程缓冲区期间，应用进程被阻塞。</p>
<h2 id="u5F02_u6B65I/O_u6A21_u578B"><a href="#u5F02_u6B65I/O_u6A21_u578B" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h2>
<p>POSIX定义同步和异步I/O操作如下：</p>
<ol>
<li>同步I/O操作：导致请求进程阻塞，直到I/O操作完成（前面四个模型按照该定义都是同步I/O）</li>
<li>异步I/O操作：不导致请求进程阻塞。</li>
</ol>
<p>异步I/O由POSIX规范定义，它告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到应用进程的缓冲区）完成后通知我们。它于信号驱动的I/O模型相比，区别在于异步模型由内核通知我们什么时候I/O操作完成，而信号驱动模型由内核通知我们什么时候可以启动一个I/O操作。</p>
<h1 id="select_u51FD_u6570"><a href="#select_u51FD_u6570" class="headerlink" title="select函数"></a>select函数</h1><p>select函数允许进程指示等到多个时间中的任何一个发生，并只在有一个或者多个时间发生或经历一段指定时间后才唤醒它。</p>
<p>函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd1, fd_set *readset, fd_set *writeset, fd_set *excepset, <span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>中断三个参数<code>readset</code>，<code>writeset</code>，<code>exceptset</code>指定要让内核测试读、写和异常条件的描述符。<code>maxfd1</code>参数指定待测试的描述符的个数，它的值是待测试描述符的最大描述符加1。在函数返回后，描述符集内任何与未就绪描述符对应的位都会被清为0，为此，每次重新调用select函数时，我们都得再次把所有需要测试的描述符对应位置位。</p>
<p>一般来说，为了提升性能而引入缓冲机制会增加网络应用程序的复杂性。比如用fgets读取文本行，这转而会使得一可用的文本行被读入到stdio缓冲区中，然而fgets只返回1行，其余仍然在缓冲区中，当fgets完成任务后，select函数会被再次调用以等待新的工作，它不管stdio缓冲区中是否还有数据，究其原因是select不知道stdio使用了缓冲区，它只是从read系统调用的角度指出是否有数据可用。所以在混合使用stdio和select时需要格外小心。</p>
<h1 id="shutdown_u51FD_u6570"><a href="#shutdown_u51FD_u6570" class="headerlink" title="shutdown函数"></a>shutdown函数</h1><p>终止网络连接的通常方法是调用close函数，但是close函数有两个限制：</p>
<ol>
<li>close把描述符的引用计数见减1，仅仅在计数变为0时关闭套接字。</li>
<li>close终止读和写两个方向的数据传送。</li>
</ol>
<p>利用shutdown函数，可以避免这两个限制，shutdown函数可以不管引用计数就激发TCP的正常终止序列，也可以在我们发送完数据后，只关闭写半部，仍然等待远端数据接收（反之亦可）。</p>
<p>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span></span><br></pre></td></tr></table></figure>
<p>函数的行为依赖于<code>howto</code>参数：</p>
<ul>
<li>SHUT_RD：关闭读半部，套接字中不再有数据可以接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数，对一个TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后悄然丢弃。</li>
<li>SHUT_WR：关闭写半部，对于TCP套接字这称为半关闭。当前留在套接字发送缓冲区中的数据将被发送掉，之后发送TCP的FIN分节，不管套接字描述符引用是否为0，写半部关闭都会执行，进程不能再对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR：连接的读半部和写半部都关闭，这和调用两次shutdown等效。</li>
</ul>
<h1 id="u4E00_u4E2AI/O_u590D_u7528_u7684_u4F8B_u5B50"><a href="#u4E00_u4E2AI/O_u590D_u7528_u7684_u4F8B_u5B50" class="headerlink" title="一个I/O复用的例子"></a>一个I/O复用的例子</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_strcli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxfdp1, stdineof, n;</span><br><span class="line">    fd_set rset;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    stdineof = <span class="number">0</span>;</span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/* 每次select返回后，任何未就绪的描述符清0，所以每次都要置位*/</span></span><br><span class="line">		<span class="keyword">if</span> (stdineof == <span class="number">0</span>)</span><br><span class="line">			FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">		FD_SET(sockfd, &amp;rset);</span><br><span class="line">		maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">		n = select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"select error"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span>;	<span class="comment">/* terminated normally */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				err_quit(<span class="string">"str_cli: server terminated prematurelly"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			Write(fileno(<span class="built_in">stdout</span>), buf, n);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((n = Read(fileno(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">			stdineof = <span class="number">1</span>;</span><br><span class="line">			Shutdown(sockfd, SHUT_WR); <span class="comment">/* send FIN, still can read */</span></span><br><span class="line">			FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Writen(sockfd, buf, n);</span><br><span class="line">		&#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/08/Hexo博客同步/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/08/Hexo博客同步/" itemprop="url">
                  Hexo博客同步
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/08/Hexo博客同步/" class="leancloud_visitors" data-flag-title="Hexo博客同步">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hexo_u5728_u591A_u8BBE_u5907_u95F4_u540C_u6B65"><a href="#Hexo_u5728_u591A_u8BBE_u5907_u95F4_u540C_u6B65" class="headerlink" title="Hexo在多设备间同步"></a>Hexo在多设备间同步</h1><p>最近使用的电脑在Mac和实验室的电脑之间不停的转换，就出现了想写博客，可是Mac不在身边没法写的情况，所以就折腾了一下如何让Hexo博客在多个设备间同步。</p>
<p>简单来说，在部署Hexo的时候，Github上的文件是编译过后的，而我们需要同步的往往是source目录下的源文件（markdown文件、图片等）。所以我们只要新创建一个仓库，然后把要备份的文件上传到仓库即可。<br>如果和我一样，不想太麻烦，直接备份整个hexo根目录下的文件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir &#60;Blog dir&#62;&#10;git init&#10;git add --all&#10;git commit -m &#39;first commit&#39;&#10;git remote add &#60;remote name&#62; &#60;remote addr&#62;&#10;git push -u &#60;remote name&#62; master</span><br></pre></td></tr></table></figure>
<p>然后在每次更新博客之后，即可更新远程仓库就可以了。</p>
<p>在一台新电脑上恢复博客也是很简单的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &#60;remote addr&#62;&#10;cd &#60;Blog dir&#62;&#10;npm install hexo&#10;npm install &#10;npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>这样就齐活儿了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/04/Interaction Transition/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/Interaction Transition/" itemprop="url">
                  Interaction Transition
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/04/Interaction Transition/" class="leancloud_visitors" data-flag-title="Interaction Transition">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Interaction_Transition"><a href="#Interaction_Transition" class="headerlink" title="Interaction Transition"></a>Interaction Transition</h1><p>为了自定义交互式的过渡动画，<code>UIViewControllerTransitioningDelegate</code>对象必须实现对应的协议方法，<code>interactionControllerForPresentation(_:)</code>和<code>interactionControllerForDismissal(_:)</code>。交互控制根据用户的手势输入来更新自定义的过渡动画，<br>而自定的过度动画是实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象，关于该协议这里就不再说明了。</p>
<p>Apple提供了一个交互式控制器的具体实现<code>UIPercentDrivenInteractiveTransition</code>，在大多数情况下，我们的交互式控制器只要继承它，然后加入自己的手势交互就好了。</p>
<p>在我们的手势交互逻辑中，根据用户的输入，我们利用以下几个方法来实时更新动画：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">updateInteractiveTransition</span><span class="params">(<span class="number">_</span> percentComplete: CGFloat)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cancelInteractiveTransition</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">finishInteractiveTransition</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>一个简单的例子如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwipeInteractionController</span>: <span class="title">UIPercentDrivenInteractiveTransition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> interactionInProgress : <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> shouldCompleteTransition : <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> viewController : <span class="type">UIViewController</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">wireToViewController</span><span class="params">(viewController : UIViewController!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewController = viewController</span><br><span class="line">        prepareGestureRecognizerInView(viewController.view)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">handleGesture</span><span class="params">(gestureRecognizer : UIScreenEdgePanGestureRecognizer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> translation = gestureRecognizer.translationInView(gestureRecognizer.view!.superview)</span><br><span class="line">        <span class="keyword">var</span> progress = translation.x / <span class="number">200.0</span></span><br><span class="line">        progress = <span class="type">CGFloat</span>(fminf(fmaxf(<span class="type">Float</span>(progress), <span class="number">0.0</span>), <span class="number">1.0</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> gestureRecognizer.state &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Began</span>:</span><br><span class="line">            interactionInProgress = <span class="literal">true</span></span><br><span class="line">            viewController.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Changed</span>:</span><br><span class="line">            shouldCompleteTransition = progress &gt; <span class="number">0.5</span></span><br><span class="line">            updateInteractiveTransition(progress)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Cancelled</span>:</span><br><span class="line">            shouldCompleteTransition = <span class="literal">false</span></span><br><span class="line">            interactionInProgress = <span class="literal">false</span></span><br><span class="line">            cancelInteractiveTransition()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ended</span>:</span><br><span class="line">            interactionInProgress = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> shouldCompleteTransition &#123;</span><br><span class="line">                finishInteractiveTransition()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cancelInteractiveTransition()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Unsupported"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MARK: private </span></span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareGestureRecognizerInView</span><span class="params">(view : UIView)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> edgeRecognizer = <span class="type">UIScreenEdgePanGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(handleGesture))</span><br><span class="line">        edgeRecognizer.edges = <span class="type">UIRectEdge</span>.<span class="type">Left</span></span><br><span class="line">        view.addGestureRecognizer(edgeRecognizer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了这个Animator之后，只要在另外一个对象（实现了UIViewControllerTransitioningDelegate协议）的<code>interactionControllerForDismissal(_:)</code>返回这个类的实例即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">interactionControllerForDismissal</span><span class="params">(animator: UIViewControllerAnimatedTransitioning)</span></span> -&gt; <span class="type">UIViewControllerInteractiveTransitioning</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> swipeAnimator.interactionInProgress ? swipeAnimator : <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/02/Signal/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/Signal/" itemprop="url">
                  Signal
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/02/Signal/" class="leancloud_visitors" data-flag-title="Signal">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Signal_2C_Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1"><a href="#Signal_2C_Linux_u8FDB_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="Signal, Linux进程间通信"></a>Signal, Linux进程间通信</h1><p>信号（Signal）是Linux的一种进程间通信机制，信号由内核或者其他进程发送给接收进程，接收到信号的进程相应地采取行动来处理信号。信号是一种软中断，即当一个进程收到一个信号时，它停止自己的执行流程，转而去处理信号。<br>值得注意的是信号是可重入的，即信号处理程序可以被其他信号中断。</p>
<h3 id="u4FE1_u53F7_u7684_u79CD_u7C7B"><a href="#u4FE1_u53F7_u7684_u79CD_u7C7B" class="headerlink" title="信号的种类"></a>信号的种类</h3><p>常用的信号并不是很多，信号的名称在<code>&lt;signal.h&gt;</code>中定义，常用的信号及解释如下：</p>
<ul>
<li>SIGALRM：由<code>alarm()</code>系统调用发送给接收进程，<code>alarm()</code>系统调用可以定时发送一个SIGALRM信号给进程，以触发某个定时操作。</li>
<li>SIGHUP：该信号表示某一个操作关闭了终端，运行在该终端下的程序会收到SIGHUP信号，默认的信号处理程序会结束收到的信号的程序。</li>
<li>SIGINT：用户输入了Ctrl-C就会发送一个SIGINT给前台应用。</li>
<li>SIGILL：这是一个异常信号，表示系统执行时遇到了一个非法程序，当加载动态链接一个被破坏的函数库时可能会产生该信号。注意，这个信号不能被捕获或者忽略，一般在shell中用于强制终止异常程序。</li>
<li>SIGABRT：程序中调用<code>abort()</code>系统调用会产生一个SIGABRT信号</li>
<li>SIGSEGV：这也是一个异常信号，当程序访问了一个不属于它的内存空间是内核会发送一个SIGSEGV信号给程序。</li>
<li>SIGPIPE：Broken Pipe，如果程序尝试往管道写入数据，而管道并没有与之对应的读数据的进程，就会产生SIGPIPE信号。</li>
<li>SIGTREM：这个信号告诉进程结束自身的运行，<code>kill</code>命令默认发送SIGTERM信号</li>
<li>SIGHLD：当一个子进程结束运行时，父进程就会收到一个SIGHLD信号。</li>
<li>SIGUSR1 &amp; SIGUSR2：用户可自定义的信号。</li>
</ul>
<p>注意<code>SIGILL</code>和<code>SIGSTOP</code>（用于调试）的处理行为不能被更改。</p>
<h3 id="POSIX_u4FE1_u53F7_u7684_u8BED_u4E49"><a href="#POSIX_u4FE1_u53F7_u7684_u8BED_u4E49" class="headerlink" title="POSIX信号的语义"></a>POSIX信号的语义</h3><p>符合POSIX的系统上信号的处理总结为：</p>
<ul>
<li>一旦安装了信号处理函数，它就一直安装着</li>
<li>在一个信号处理函数运行期间，正被递交的信号是阻塞的。而且安装处理函数时，POSIX保证传递给<code>sigaction</code>的<code>sa_mask</code>信号集中指定的任何信号都是被阻塞的。</li>
<li>如果一个信号在被阻塞期间产生了一次或多次，那么该信号在被解阻塞之后通常只递交一次，也就是说，Unix信号默认是不排队的。</li>
<li>利用sigprocmask函数选择性地阻塞或解阻塞一组信号是可能的，我们可以在一段临界代码执行期间，防止捕获某些信号，以此保护这段代码。</li>
</ul>
<h3 id="u4FE1_u53F7_u7684_u5904_u7406"><a href="#u4FE1_u53F7_u7684_u5904_u7406" class="headerlink" title="信号的处理"></a>信号的处理</h3><h4 id="signal_u51FD_u6570"><a href="#signal_u51FD_u6570" class="headerlink" title="signal函数"></a>signal函数</h4><p><code>signal</code>函数是一个年代久远的信号处理函数，其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span>, <span class="keyword">void</span> (*handler)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，signal是一个函数，其返回值是一个函数指针，signal函数注册一个新的信号处理函数，并返回原先注册的信号处理函数。</p>
<p>一个<code>signal</code>函数的例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Receive Signal : %d\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果截图：<br><img src="/2016/09/02/Signal/signal_test.png" alt="signal_test.png" title=""></p>
<p>可以看到当我们按下<code>Ctrl-C</code>时触发了自定义的信号处理函数。</p>
<h4 id="sigaction_u51FD_u6570"><a href="#sigaction_u51FD_u6570" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><p><code>signal</code>函数的行为根据UNIX版本的不同而不同，在不同的Linux版本中亦是如此。所以我们应该使用一个更加健壮的接口－－sigaction函数。sigaction的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sigaction</code>的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sigaction &#123;</span><br><span class="line">	<span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">	<span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">	<span class="keyword">int</span>        sa_flags;</span><br><span class="line">	<span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sa_flags</code>被设置成<code>SA_SIGINFO</code>时，信号处理函数是<code>sa_sigaction</code>函数，否则是<code>sa_handler</code>函数。<code>sa_flags</code>的其他值的解释如下：</p>
<ul>
<li>SA_NOCLDSTOP：子进程停止时不产生SIGHLD信号</li>
<li>SA_RESETHAND：将对此信号的处理方式在信号处理函数入口处重置为SIG_DFL</li>
<li>SA_RESTART：重启可中断的函数而不是给出EINTER错误</li>
<li>SA_NODEFER：捕获到信号时不将它添加到屏蔽字中。</li>
</ul>
<p>当我们使用<code>sa_sigaction</code>函数作为信号处理函数时，我们可以得到发送信号的进程的更多信息，信息存储在<code>siginfo_t</code>中，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">siginfo_t</span> &#123;</span><br><span class="line">	<span class="keyword">int</span>      si_signo;    <span class="comment">/* Signal number */</span></span><br><span class="line">    <span class="keyword">int</span>      si_errno;    <span class="comment">/* An errno value */</span></span><br><span class="line">    <span class="keyword">int</span>      si_code;     <span class="comment">/* Signal code */</span></span><br><span class="line">    <span class="keyword">int</span>      si_trapno;   <span class="comment">/* Trap number that caused</span><br><span class="line">                                      hardware-generated signal</span><br><span class="line">                                      (unused on most architectures) */</span></span><br><span class="line">	<span class="keyword">pid_t</span>    si_pid;      <span class="comment">/* Sending process ID */</span></span><br><span class="line">    <span class="keyword">uid_t</span>    si_uid;      <span class="comment">/* Real user ID of sending process */</span></span><br><span class="line">    <span class="keyword">int</span>      si_status;   <span class="comment">/* Exit value or signal */</span></span><br><span class="line">    <span class="keyword">clock_t</span>  si_utime;    <span class="comment">/* User time consumed */</span></span><br><span class="line">    <span class="keyword">clock_t</span>  si_stime;    <span class="comment">/* System time </span><br><span class="line">	sigval_t si_value;    <span class="comment">/* Signal value */</span></span><br><span class="line">    int      si_int;      <span class="comment">/* POSIX.1b signal */</span></span><br><span class="line">    void    *si_ptr;      <span class="comment">/* POSIX.1b signal */</span></span><br><span class="line">    int      si_overrun;  <span class="comment">/* Timer overrun count; POSIX.1b timers */</span></span><br><span class="line">    int      si_timerid;  <span class="comment">/* Timer ID; POSIX.1b timers */</span></span><br><span class="line">    void    *si_addr;     <span class="comment">/* Memory location which caused fault */</span></span><br><span class="line">    long     si_band;     <span class="comment">/* Band event (was int in</span><br><span class="line">                                      glibc 2.3.2 and earlier) */</span></span><br><span class="line">	int      si_fd;       <span class="comment">/* File descriptor */</span></span><br><span class="line">    short    si_addr_lsb; <span class="comment">/* Least significant bit of address</span><br><span class="line">                                        (since Linux 2.6.32) */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>sa_mask</code>中设置被进程屏蔽的信号。</p>
<p>一个使用<code>sigaction</code>的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Receive signal : %d\n"</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sigaction act;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line"></span><br><span class="line">    act.sa_handler = sig_handler;</span><br><span class="line">    act.sa_flags   = SA_RESETHAND;</span><br><span class="line">    <span class="comment">/* 清除屏蔽字 */</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Test\n"</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<img src="/2016/09/02/Signal/sigaction_test.png" alt="sigaction_test.png" title="">
<p>可以看到，程序第一次收到SIGINT信号时执行的是自定义的信号处理函数，第二次就被重置为默认的信号处理函数了。</p>
<h4 id="kill_u51FD_u6570"><a href="#kill_u51FD_u6570" class="headerlink" title="kill函数"></a>kill函数</h4><p><code>kill</code>系统调用函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(pid_t pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它的作用是发送一个信号（由sig参数指定）给一个特定进程。默认发送<code>SIGTERM</code>信号。</p>
<h4 id="u4FE1_u53F7_u96C6_u5904_u7406_u51FD_u6570"><a href="#u4FE1_u53F7_u96C6_u5904_u7406_u51FD_u6570" class="headerlink" title="信号集处理函数"></a>信号集处理函数</h4><p>信号集处理函数主要用于处理<code>sigset_t</code>，从而让进程屏蔽某些信号。函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(sigset_t *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(sigset_t *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(sigset_t *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(sigset_t *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(sigset_t *sigset, <span class="keyword">int</span> signal)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpromask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> sigset_t *<span class="built_in">set</span>, sigset_t *osigset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(sigset_t *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> sigset_t *)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sigpromask</code>可以根据<code>how</code>指定的值来修改进程的信号屏蔽字。如果<code>set</code>参数为空，则<code>how</code>没有意义，但是如果此时<code>osigset</code>不为空，那么当前信号屏蔽字保存在<code>osigset</code>指向的地址中。</p>
<p><code>how</code>的不同取值和对应的操作：</p>
<ul>
<li>SIG_BLOCK：把参数set中的信号加入到进程的信号屏蔽字中</li>
<li>SIG_SETMASK：把进程的信号屏蔽字设置为set中的信号</li>
<li>SIG_UNBLOCK：从进程的信号屏蔽字中删除set中指定的信号</li>
</ul>
<p>注意，调用这个函数才能修改进程的信号屏蔽字，它之前的函数都只是改变一个变量，对进程的信号屏蔽字并没有直接影响。</p>
<p><code>sigpending</code>函数将被阻塞的信号中停留在待处理状态的信号写入参数指定的地址中。</p>
<p><code>sigsuspend</code>函数首先将进程的屏蔽字换成参数指定的信号，然后挂起进程。</p>
<p>一个例子实验一下以上的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Handle the signal %d\n"</span>, sig);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">sigset_t</span> sigset;<span class="comment">//用于记录屏蔽字  </span></span><br><span class="line">    <span class="keyword">sigset_t</span> ign;<span class="comment">//用于记录被阻塞的信号集  </span></span><br><span class="line">    <span class="keyword">struct</span> sigaction act;  </span><br><span class="line">    <span class="comment">//清空信号集  </span></span><br><span class="line">    sigemptyset(&amp;sigset);  </span><br><span class="line">    sigemptyset(&amp;ign);  </span><br><span class="line">    <span class="comment">//向信号集中添加信号SIGINT  </span></span><br><span class="line">    sigaddset(&amp;sigset, SIGINT);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置处理函数和信号集      </span></span><br><span class="line">    act.sa_handler = handler;  </span><br><span class="line">    sigemptyset(&amp;act.sa_mask);  </span><br><span class="line">    act.sa_flags = <span class="number">0</span>;  </span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Wait the signal SIGINT...\n"</span>);  </span><br><span class="line">    pause();<span class="comment">//挂起进程，等待信号  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置进程屏蔽字，在本例中为屏蔽SIGINT   </span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;sigset, <span class="number">0</span>);     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please press Ctrl+c in 10 seconds...\n"</span>);  </span><br><span class="line">    sleep(<span class="number">10</span>);  </span><br><span class="line">    <span class="comment">//测试SIGINT是否被屏蔽  </span></span><br><span class="line">    sigpending(&amp;ign);  </span><br><span class="line">    <span class="keyword">if</span>(sigismember(&amp;ign, SIGINT))  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The SIGINT signal has ignored\n"</span>);  </span><br><span class="line">    <span class="comment">//在信号集中删除信号SIGINT  </span></span><br><span class="line">    sigdelset(&amp;sigset, SIGINT);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Wait the signal SIGINT...\n"</span>);  </span><br><span class="line">    <span class="comment">//将进程的屏蔽字重新设置，即取消对SIGINT的屏蔽  </span></span><br><span class="line">    <span class="comment">//并挂起进程  </span></span><br><span class="line">    sigsuspend(&amp;sigset);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The app will exit in 5 seconds!\n"</span>);  </span><br><span class="line">    sleep(<span class="number">5</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/2016/09/02/Signal/sigset_test.png" alt="sigset_test.png" title="">
<p>可以看到当我们屏蔽了SIGINT信号后，如果SIGINT发送给进程，那么信号就被阻塞编程待处理状态，当我们取消对信号的阻塞后该信号马上就被处理，于是程序就马上打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The app will exit in 5 seconds!</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.JPG"
               alt="Zach" />
          <p class="site-author-name" itemprop="name">Zach</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zach</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




	




  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("ntwSG1Uc9Pv9VSd5ODUsFYkK-gzGzoHsz", "HoWAvsNTJHhdUmXFuqT6j4vp");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
