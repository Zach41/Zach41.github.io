<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Zach的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Zach的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zach的博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>







  <title> Zach的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zach的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">这个人很懒，都不知道说些什么 :(</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/02/gitignore/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/02/gitignore/" itemprop="url">
                  快速添加gitignore
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/11/02/gitignore/" class="leancloud_visitors" data-flag-title="快速添加gitignore">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="gitignore-io"><a href="#gitignore-io" class="headerlink" title="gitignore.io"></a>gitignore.io</h1><p><a href="https://www.gitignore.io/" target="_blank" rel="external">gitignore.io</a>是一个可以在线快速生成项目<code>.gitignore</code>文件的网站。<br><strong>github</strong>也维护了一个<code>gitignore</code>文件的<a href="https://github.com/github/gitignore" target="_blank" rel="external">repo</a>。</p>
<p>可以从上述网站很快得到想要的<code>gitignore</code>文件。</p>
<p>当然如果你和我一样喜欢命令行，那么官方推荐的方法更值得拥有：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash&#10;$ echo &#34;function gi() &#123; curl -L -s https://www.gitignore.io/api/\$@ ;&#125;&#34; &#62;&#62; ~/.bashrc &#38;&#38; source ~/.bashrc&#10;&#10;#!/bin/zsh&#10;$ echo &#34;function gi() &#123; curl -L -s https://www.gitignore.io/api/\$@ ;&#125;&#34; &#62;&#62; ~/.zshrc &#38;&#38; source ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>上述代码在用户环境变量文件中添加了一个函数<code>gi</code>，以后我们就可以这样来添加<code>gitignore</code>了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gi CMake &#62; .gitignore&#10;gi C &#62;&#62; .gitignore</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/28/线程基础/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/28/线程基础/" itemprop="url">
                  线程基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/28/线程基础/" class="leancloud_visitors" data-flag-title="线程基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u7EBF_u7A0B_u6807_u8BC6"><a href="#u7EBF_u7A0B_u6807_u8BC6" class="headerlink" title="线程标识"></a>线程标识</h1><p>每一个线程有一个线程ID，线程ID不像进程ID一样在整个系统唯一，它只在进程的上下文中才有意义。线程ID用<code>pthread_t</code>结构表示，不同的实现下，<code>pthread_t</code>的内部表示不同，Linux用长整型表示，而Mac OS X下用指针来表示，所以不能简单的将其转换成长整型来比较。用以下接口来获得和比较线程ID:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(pthread_t tid1, pthread_t tid2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h1 id="u7EBF_u7A0B_u521B_u5EFA"><a href="#u7EBF_u7A0B_u521B_u5EFA" class="headerlink" title="线程创建"></a>线程创建</h1><p>创建线程的接口：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t *restrict tidp, </span><br><span class="line">                  const pthread_attr_t *restrict attr, </span><br><span class="line">                  void *(start_rtn)(void *), void *restrict arg);</span><br></pre></td></tr></table></figure>
<p><code>pthread</code>函数在发生错误时通常会返回错误码，而不去依赖全局的<code>errno</code>。</p>
<p><code>pthread_attr_t</code>指定创建的线程的属性，如果只需要默认的属性，将其设置为<code>NULL</code>即可。</p>
<p>POSIX.1定义的线程属性如下：</p>
<ul>
<li><code>detachstate</code>：线程的分离状态属性</li>
<li><code>guardsize</code>：线程栈尾的警戒缓冲区大小</li>
<li><code>stackaddr</code>：线程栈的最低地址</li>
<li><code>stacksize</code>：线程栈的最小长度</li>
</ul>
<p>线程创建后默认状态是<code>PTHREAD_CREATE_JOINABLE</code>，其终止状态，即线程执行最后的返回参数或者调用<code>pthread_exit</code>时传递的参数会保留知道对该线程调用<code>pthread_join</code>。如果线程已经分离，那么线程的底层存储资源可以在线程终止时立即被收回。可以在创建时指定<code>detachstate</code>为<code>PTHREAD_CREATE_DETACHED</code>或者创建之后调用<code>pthread_detach</code>函数来指定线程分离。在线程被分离之后，我们不能调用<code>pthread_join</code>来等待它的终止状态，这会产生未定义的行为。</p>
<p>线程属性<code>guardsize</code>控制线程栈末尾（栈顶上方）之后用于避免栈溢出的扩展内存大小。这个默认值和具体的实现相关，如果设置为0，那么该机制就无效了。同样的，如果修改了线程的<code>stackaddr</code>属性，那么系统就认为我们要自己管理线程栈，该缓冲区机制无效。在这种缓冲机制下，如果线程栈指针溢出到了警戒区域，那么应用程序就可能通过信号接收到出错信息。</p>
<p><code>stackaddr</code>和<code>stacksize</code>顾名思义就是用来管理新创建线程的栈空间的。<code>stackaddr</code>线程属性被定义为栈的最低内存地址，一般来说栈是向低地址增长的，所以<code>stackaddr</code>一般来说是栈顶位置。如果只是希望改变栈的大小，而不自己管理栈空间，可以只设置<code>stacksize</code>属性，该属性值不能小于<code>PTHREAD_STACK_MIN</code>。</p>
<p>相关接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化属性，销毁属性对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(pthread_attr_t *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(pthread_attr_t *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离状态</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * PTHREAD_CREATE_JOINABLE</span><br><span class="line"> * PTHREAD_CREATE_DETACHED</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> pthread_attr_t *<span class="keyword">restrict</span> attr, </span><br><span class="line">                               <span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(pthread_attr_t *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(pthread_t tid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> pthread_attr_t *<span class="keyword">restrict</span> attr,</span><br><span class="line">                         <span class="keyword">void</span> **<span class="keyword">restrict</span> stackaddr,</span><br><span class="line">                         size_t *<span class="keyword">restrict</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(pthread_attr_t *attr,</span><br><span class="line">                         <span class="keyword">void</span> *stackaddr,</span><br><span class="line">                         size_t stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> pthread_attr_t *<span class="keyword">restrict</span> attr,</span><br><span class="line">                             size_t *<span class="keyword">restrict</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(pthread_attr_t *attr, size_t stacksize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 警戒区大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">const</span> pthread_attr_t *<span class="keyword">restrict</span> attr,</span><br><span class="line">                             size_t *<span class="keyword">restrict</span> guardsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(pthread_attr_t *attr,</span><br><span class="line">                             size_t guardsize)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个设置线程分离状态的帮助函数例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int makethread(void *(*fn)(void *), void *arg) &#123;</span><br><span class="line">    int err;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    pthread_attr_t attr;</span><br><span class="line"></span><br><span class="line">    err = pthread_attr_init(&amp;attr);</span><br><span class="line">    if (err != 0)</span><br><span class="line">	return err;</span><br><span class="line">    err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    if (err == 0) &#123;</span><br><span class="line">	err = pthread_create(&amp;tid, &amp;attr, fn, arg);	</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u7EBF_u7A0B_u7EC8_u6B62"><a href="#u7EBF_u7A0B_u7EC8_u6B62" class="headerlink" title="线程终止"></a>线程终止</h1><p>如果进程中有任何一个线程调用了<code>exit</code>、<code>_Exit</code>或者<code>_exit</code>中任何一个函数，那么整个进程就会终止。同样的，如果发送到某一个线程的信号的默认动作是终止进程，那么整个进程也就会被终止。</p>
<p>单个线程可以通过3中方式退出而不终止整个进程：</p>
<ul>
<li>从线程的启动例程返回，返回值是退出码</li>
<li>线程可以被同一个进程中的其他线程取消</li>
<li>线程调用<code>pthread_exit</code>。</li>
</ul>
<p>如果一个线程未被分离，那么可以用<code>pthread_join</code>函数获得线程的退出状态码。</p>
<p>相关的接口如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void pthread_exit(void *rval_ptr);</span><br><span class="line"></span><br><span class="line">int pthread_join(pthread_t thread, void **rval_ptr);</span><br><span class="line"></span><br><span class="line">// 取消线程</span><br><span class="line">int pthread_cancel(pthread_t tid);</span><br><span class="line"></span><br><span class="line">// 清理函数</span><br><span class="line">void pthread_cleanup_push(void (*rtn)(void *), void *arg);</span><br><span class="line">void pthread_cleanup_pop(int execute);</span><br></pre></td></tr></table></figure>
<p>线程的退出的例子可以参考：<a href="https://github.com/Zach41/UNIX-Demos/blob/master/pthread/pthread_exit.c" target="_blank" rel="external">pthread_exit</a></p>
<p>需要注意的一点是，如果线程从启动例程正常返回，那么<code>rval_ptr</code>就包含返回码；如果线程被取消，由<code>rval_ptr</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code>。</p>
<p>线程可以像进程一样安排它退出时需要调用的线程清理程序。一个线程可以建立多个清理处理程序，程序的执行顺序和建立顺序相反。</p>
<p>当线程执行以下动作时，清理函数被调度执行：</p>
<ul>
<li>调用<code>pthread_exit</code></li>
<li>响应取消请求</li>
<li>用非零<code>execute</code>参数调用<code>pthread_cleanup_pop</code>。</li>
</ul>
<p>如果<code>execute</code>参数设置为0，那么清理函数不会被调用，但是无论<code>execute</code>参数如何，<code>pthread_cleanup_pop</code>都将删除最近一次<code>pthread_cleanup_push</code>建立的清理处理程序。</p>
<p>这里需要注意一点，<code>pthread_cleanup_push</code>和<code>pthread_cleanup_pop</code>可能被实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用。</p>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *msg = (<span class="keyword">char</span> *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 1 start\n"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"thread1 first cleanup"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"thread1 second cleanup"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg)</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 2 start\n"</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"thread2 first cleanup"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"thread2 second cleanup"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg)</span><br><span class="line">	pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, (<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">    err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, (<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    err = pthread_join(tid1, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 1 ended with status: %ld\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line">    err = pthread_join(tid2, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2 ended with status: %ld\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程1只是简单地从启动例程返回，而线程2调用了<code>pthread_exit</code>以结束启动例程。</p>
<p>结果输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;thread 1 start&#10;thread 2 start&#10;thread 1 ended with status: 1&#10;thread2 second cleanup&#10;thread2 first cleanup&#10;thread2 ended with status: 2</span><br></pre></td></tr></table></figure>
<p>可以看到只有线程2调用了清理程序，而且清理程序的执行顺序和建立顺序相反。</p>
<h3 id="u7EBF_u7A0B_u53D6_u6D88_u7684_u4E00_u4E9B_u7EC6_u8282"><a href="#u7EBF_u7A0B_u53D6_u6D88_u7684_u4E00_u4E9B_u7EC6_u8282" class="headerlink" title="线程取消的一些细节"></a>线程取消的一些细节</h3><p>前面提到线程可以被另外一个线程取消，但是这种行为是可以被关闭的。<strong>可取消状态属性</strong>控制着线程的是否响应取消请求，这个属性用两个值表示：</p>
<ul>
<li><code>PTHREAD_CANCEL_ENABLE</code></li>
<li><code>PTHREAD_CANCEL_DISABLE</code></li>
</ul>
<p>可以通过以下接口来修改线程的这一状态属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在默认的情况下，线程在取消请求被发出后仍然继续执行，只有到某一个取消点时，线程才响应取消请求，执行清理函数。取消点会在调用某一个函数时出现，如调用了<code>sleep</code>函数。当线程的状态为<code>PTHREAD_CANCEL_DISABLE</code>时，如果发出了一个取消请求，那么线程不会被杀死，该请求被挂起，在状态更改为<code>PTHREAD_CANCEL_ENABLE</code>后，线程就会在下一个取消点响应这个取消请求。用户也可以调用<code>pthread_testcancel</code>这个函数，添加自己的取消点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *msg = (<span class="keyword">char</span> *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"waiting for canceling.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL); */</span></span><br><span class="line">    </span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"first cleanup"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"second cleanup"</span>);</span><br><span class="line">    <span class="comment">/* must put this after cleanup push so cleanup can be executed */</span></span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">/* pthread_testcancel(); */</span></span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid2cancel = (<span class="keyword">pthread_t</span>)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cancel thread 1\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> err = pthread_cancel(tid2cancel);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_cancel error: %s\n"</span>, strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    err = pthread_attr_init(&amp;attr);</span><br><span class="line">    err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    </span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">    err = pthread_create(&amp;tid2, &amp;attr, thr_fn2, (<span class="keyword">void</span> *)tid1);</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    err = pthread_join(tid1, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (tret == PTHREAD_CANCELED) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 is canceled\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"some error occurred\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程2在执行后马上睡眠，以便让线程1首先执行，在线程1建立完清理函数后，线程1睡眠，于是就有了一个取消点。线程2在睡眠结束后调用<code>pthread_cancel</code> 取消线程1，于是线程1响应这个请求，清理函数被执行。</p>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;waiting for canceling.&#10;cancel thread 1&#10;second cleanup&#10;first cleanup&#10;thread 1 is canceled</span><br></pre></td></tr></table></figure>
<p>我们也可以自己调用<code>pthread_testcancel</code>设置一个取消点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *msg = (<span class="keyword">char</span> *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"waiting for canceling.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL); */</span></span><br><span class="line">    </span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"first cleanup"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, <span class="string">"second cleanup"</span>);</span><br><span class="line">    <span class="comment">/* must put this after cleanup push so cleanup can be executed */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>); t+<span class="number">5</span> &gt; time(<span class="literal">NULL</span>); )</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">    pthread_testcancel();</span><br><span class="line">    <span class="keyword">if</span> (arg)</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid2cancel = (<span class="keyword">pthread_t</span>)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cancel thread 1\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> err = pthread_cancel(tid2cancel);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_cancel error: %s\n"</span>, strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    err = pthread_attr_init(&amp;attr);</span><br><span class="line">    err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    </span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">    err = pthread_create(&amp;tid2, &amp;attr, thr_fn2, (<span class="keyword">void</span> *)tid1);</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    err = pthread_join(tid1, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (tret == PTHREAD_CANCELED) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread 1 is canceled\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"some error occurred\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程1中，在设置了清理函数之后，我们让线程空转，以防止它过早的结束，否则线程2在调用<code>pthread_cancel</code>的时候就会出错。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;waiting for canceling.&#10;cancel thread 1&#10;second cleanup&#10;first cleanup&#10;thread 1 is canceled</span><br></pre></td></tr></table></figure>
<h1 id="u7EBF_u7A0B_u540C_u6B65"><a href="#u7EBF_u7A0B_u540C_u6B65" class="headerlink" title="线程同步"></a>线程同步</h1><p>当有多个线程共享相同的内存时，需要确保每个线程看到一致的数据视图。当一个线程修改一个变量时，如果变量的修改时间多于一个存储器访问周期，那么就有可能出现不一致的情况。我们需要利用线程的同步机制来保证数据的一致。</p>
<h3 id="u4E92_u65A5_u91CF"><a href="#u4E92_u65A5_u91CF" class="headerlink" title="互斥量"></a>互斥量</h3><p>利用<code>pthread</code>提供的互斥接口，可以确保同一时间只有一个线程访问数据。互斥量是一把锁，线程在访问数据前必须获得这个锁，否则线程无法访问数据。互斥量用<code>pthread_mutex_t</code>表示，在使用该变量前，必须将其初始化，如果是静态分配的互斥量，那么可以把它设置为<code>PTHREAD_MUTEX_INIITIALIZER</code>，否则就需要调用<code>pthread_mutex_init</code>来初始化锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(pthread_mutex_t *<span class="keyword">restrict</span> mutex,</span><br><span class="line">                      <span class="keyword">const</span> pthread_mutexattr_t *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_desctroy</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获得和释放互斥量的锁的接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(pthread_mutex_t *<span class="keyword">restrict</span> mutex,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_mutex_lock</code>会阻塞线程，知道它可以获得锁，如果线程不想被阻塞，可以调用<code>pthread_mutex_trylock</code>，如果互斥量未被加锁，那么线程获得互斥量的锁，否则，函数立即返回，返回的错误码为<code>EBUSY</code>。</p>
<p>在使用互斥量的时候要注意避免死锁的情况：假设线程A拥有互斥量a的锁，线程B拥有互斥量b的锁，如果在某一个时刻，线程A请求b的锁，然后线程A被睡眠，此后线程B被唤醒，它请求a的锁，这个时候线程A和线程B被相互阻塞，出现了死锁。</p>
<p>为了避免这种情况，当我们用两个或者两个以上的互斥量的时候，需要注意请求互斥量的锁的顺序。比如在上述例子中，我们规定互斥量的a的锁必须在互斥量b的锁之前获取。这样一样，线程B在获得b的锁之前必须请求一次a的锁，这样的话线程B就会因线程A占有a的锁而被阻塞，线程A可以获得a和b的锁，当A执行完之后释放所有的锁，线程B也得到了执行。</p>
<h3 id="u4E92_u65A5_u91CF_u7684_u5C5E_u6027"><a href="#u4E92_u65A5_u91CF_u7684_u5C5E_u6027" class="headerlink" title="互斥量的属性"></a>互斥量的属性</h3><p>在调用<code>pthread_mutex_init</code>时，可以看到函数还接受一个<code>pthread_mutexattr_t</code>变量参数，该参数指定了互斥量的属性，如果只需要默认的属性，那么将参数设置为<code>NULL</code>即可。</p>
<p>初始化和销毁接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(pthread_mutexattr_t *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(pthread_mutexattr_t *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>互斥量有如下属性：</p>
<ul>
<li>进程共享属性：如果互斥量属于多个进程彼此共享的内存空间，那么该属性如果为<code>PTHREAD_PROCESS_SHARED</code>，那么不同进程可以利用这个互斥量进程同步；如果该属性为<code>PTHREAD_PROCESS_PRIVATE</code>，那么只有同一个进程的线程可以利用这个互斥量进程同步，这也是默认的行为</li>
<li>健壮属性：不太懂</li>
<li>一致性属性：不太懂</li>
<li>类型属性：有四种类型的互斥量<ul>
<li>PTHREAD_MUTEX_NORMAL：标准互斥量类型，不做任何特殊的错误检查和死锁检测</li>
<li>PTHREAD_MUTEX_ERRORCHECK：提供错误检查的互斥量</li>
<li>PTHREAD_MUTEX_RECURSIVE：递归互斥量类型，在获得互斥量的锁之后，允许再次获得锁，解锁时，必须调用相同次数的解锁操作。</li>
<li>PTHREAD_MUTEX_DEFAULT：提供默认特性和行为的互斥量，操作系统可以把这个类型映射到上述三种中的任意一个类型，可具体实现有关。</li>
</ul>
</li>
</ul>
<p>四种类型的锁的行为如下所示。<strong>不占用时解锁</strong>指：一个线程对被另外一个线程枷锁的互斥量进行解锁；<strong>在已解锁时解锁</strong>指：线程对一个已经解锁的互斥量再次解锁的情况。</p>
<table>
<thead>
<tr>
<th style="text-align:center">互斥量类型</th>
<th style="text-align:center">没有解锁时重新加锁</th>
<th style="text-align:center">不占用时解锁</th>
<th style="text-align:center">已解锁时解锁</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PTHREAD_MUTEX_NORMAL</td>
<td style="text-align:center">死锁</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
</tr>
<tr>
<td style="text-align:center">PTHREAD_MUTEX_ERRORCHECK</td>
<td style="text-align:center">返回错误</td>
<td style="text-align:center">返回错误</td>
<td style="text-align:center">返回错误</td>
</tr>
<tr>
<td style="text-align:center">PTHREAD_MUTEX_RECURSIVE</td>
<td style="text-align:center">允许</td>
<td style="text-align:center">返回错误</td>
<td style="text-align:center">返回错误</td>
</tr>
<tr>
<td style="text-align:center">PTHREAD_MUTEX_DEFAULT</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
</tr>
</tbody>
</table>
<p>设置类型的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(pthread_mutexattr_t *attr, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> pthread_mutexattr_t *<span class="keyword">restrict</span> attr,</span><br><span class="line">                             <span class="keyword">int</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个递归锁的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#include "pthread_functions.h"</span><br><span class="line"></span><br><span class="line">struct to_info &#123;</span><br><span class="line">    void            *(*fn)(void *);</span><br><span class="line">    void            *to_arg;</span><br><span class="line">    int             to_wait;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void *timer_helper(void *arg) &#123;</span><br><span class="line">    struct to_info *tip;</span><br><span class="line"></span><br><span class="line">    tip = (struct to_info *)arg;</span><br><span class="line">    printf("sleep for %d secs\n", tip -&gt; to_wait);</span><br><span class="line">    sleep(tip -&gt; to_wait);</span><br><span class="line">    (tip -&gt; fn)(tip -&gt; to_arg);</span><br><span class="line">    free(arg);</span><br><span class="line"></span><br><span class="line">    return (void *)0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void timeout(const int when, void *(*fn)(void *), void *arg) &#123;</span><br><span class="line">    struct to_info *tip;</span><br><span class="line"></span><br><span class="line">    tip = (struct to_info *)malloc(sizeof(struct to_info));</span><br><span class="line">    if (tip != NULL) &#123;</span><br><span class="line">	tip -&gt; to_wait = when;</span><br><span class="line">	tip -&gt; fn = fn;</span><br><span class="line">	tip -&gt; to_arg = arg;</span><br><span class="line"></span><br><span class="line">	pthread_t tid;</span><br><span class="line">	int err = makethread(timer_helper, (void *)tip, &amp;tid);</span><br><span class="line"></span><br><span class="line">	if (err != 0) &#123;</span><br><span class="line">	    fprintf(stderr, "makethread error: %s\n", strerror(err));</span><br><span class="line">	    free(tip);</span><br><span class="line">	    exit(-1);	    </span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t lock;</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line"></span><br><span class="line">static volatile int flag = 0;</span><br><span class="line"></span><br><span class="line">void *retry(void *arg) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    printf("Recursive lock\n");</span><br><span class="line">    flag = 1;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    </span><br><span class="line">    return (void *)0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    err = pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    if (err != 0) &#123;</span><br><span class="line">	fprintf(stderr, "pthread_mutexattr_init error: %s\n", strerror(err));</span><br><span class="line">	exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    if (err != 0) &#123;</span><br><span class="line">	fprintf(stderr, "pthread_mutexattr_settype error: %s\n", strerror(err));</span><br><span class="line">	exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_mutex_init(&amp;lock, &amp;attr);</span><br><span class="line">    if (err != 0) &#123;</span><br><span class="line">	fprintf(stderr, "pthread_mutex_init error: %s\n", strerror(err));</span><br><span class="line">	exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    timeout(4, retry, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    while (!flag)</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6761_u4EF6_u53D8_u91CF"><a href="#u6761_u4EF6_u53D8_u91CF" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量时线程可用的另外一种同步机制。条件变量给多个线程提供了一个会和的场所。条件变量和互斥变量一起使用时，允许线程以无竞争的方式等待特定的条件发生。条件变量本身是被互斥量保护的，线程在改变条件之前，必须锁住互斥量。</p>
<p>条件变量以<code>pthread_cond_t</code>结构表示，同样的，静态分配的变量可以用<code>PTHREAD_COND_INITIALIZER</code>初始化，动态分配的必须使用<code>pthread_cond_init</code>函数来初始化变量。</p>
<p>相关接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(pthread_cond_t *<span class="keyword">restrict</span> cond,</span><br><span class="line">		      <span class="keyword">const</span> pthread_condattr_t *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(pthread_cond_t *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(pthread_cond_t *<span class="keyword">restrict</span> cond,</span><br><span class="line">		      pthread_mutex_t *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(pthread_cond_t *<span class="keyword">restrict</span> cond,</span><br><span class="line">			   pthread_mutex_t *<span class="keyword">restrict</span> mutex,</span><br><span class="line">			   <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(pthread_cond_t *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(pthread_cond_t *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>传递给<code>pthread_cond_wait</code>的互斥量堆条件进行保护，调用者把锁住的互斥量传递给函数，函数然后自动把调用线程放到等待条件的线程列表中，对互斥量解锁。当获得互斥量之后，互斥量再一次被锁住。</p>
<p><code>pthread_cond_signal</code>和<code>pthread_cond_broadcast</code>用于通知线程条件已经得到满足，<code>pthread_cond_signal</code>可以唤醒一个等待条件的线程，<code>pthread_cond_broadcast</code>则用于唤醒所有等待该条件的线程。</p>
<p>一个条件变量的简单例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> quitflag;</span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> waitloc = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err, signo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	err = sigwait(&amp;mask, &amp;signo);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"sigwait failed: %s\n"</span>, strerror(err));</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">	<span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"\ninterrupt\n"</span>);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> SIGQUIT: &#123;</span><br><span class="line">	    pthread_mutex_lock(&amp;lock);</span><br><span class="line">	    quitflag = <span class="number">1</span>;</span><br><span class="line">	    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">	    pthread_cond_signal(&amp;waitloc);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"unexpected signal: %d\n"</span>, signo);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">sigset_t</span> oldmask;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sigemptyset(&amp;mask); */</span></span><br><span class="line">    <span class="comment">/* sigaddset(&amp;mask, SIGQUIT); */</span></span><br><span class="line">    <span class="comment">/* sigaddset(&amp;mask, SIGINT); */</span></span><br><span class="line">    sigfillset(&amp;mask);</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_sigmask(SIG_BLOCK, &amp;mask, &amp;oldmask)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SIG_BLOCK error: %s\n"</span>, strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error: %s\n"</span>, strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="keyword">while</span> (quitflag == <span class="number">0</span>) &#123;</span><br><span class="line">	pthread_cond_wait(&amp;waitloc, &amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGQUIT received\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SIG_SETMASK error\n"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里例子中，我们创建一个线程专门用于接收信号，如果<code>SIGQUIT</code>信号到来，那么主线程等待的条件得到满足，调用<code>pthread_cond_signal</code>通知这一事件，于是主线程被唤醒得以继续执行。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;^C&#10;interrupt&#10;^C&#10;interrupt&#10;^\SIGQUIT received</span><br></pre></td></tr></table></figure>
<h3 id="u8BFB_u5199_u9501"><a href="#u8BFB_u5199_u9501" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁也成为共享互斥锁。一个读写锁在读模式被锁住时，其他线程仍然可以以读模式锁住读写锁，但是不能以写模式锁住读写锁；而当读写锁以写模式锁住时，无论如何其他线程都无法锁住这个读写锁。读写锁适用于对数据结构读的次数远大于写的情况。</p>
<p>如果是静态分配的读写锁，可以将<code>PTHREAD_RWLOCK_INITIALIZER</code>赋予给它以初始化，否则需要调用<code>pthread_rwlock_init</code>函数来初始化读写锁。</p>
<p>相关接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(pthread_rwlock_t *<span class="keyword">restrict</span> rwlock,</span><br><span class="line">			<span class="keyword">const</span> pthread_rwlockattr_t *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(pthread_rwlock_t *rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(pthread_rwlock_t *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(pthread_rwlock_t *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(pthread_rwlock_t *rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞的读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(pthread_rwlock_t *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(pthread_rwlock_t *rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带超时的读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(pthread_rwlock_t *<span class="keyword">restrict</span> rwlock,</span><br><span class="line">			     <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(pthread_rwlock_t *<span class="keyword">restrict</span> rwlock,</span><br><span class="line">			       <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>读写锁唯一支持的属性是进程共享属性，它和互斥量的进程共享属性是相同的，如果设置为<code>PTHREAD_PROCESS_SHARED</code>，那么多个进程可以利用它进行任务同步操作。</p>
<p>相关接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(pthread_rwlockattr_t *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(pthread_rwlockattr_t *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> pthread_rwlockattr_t *<span class="keyword">restrict</span> attr,</span><br><span class="line">                                 <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(pthread_rwlockattr_t *attr,</span><br><span class="line">                                 <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里给出一个利用任务队列实现读写锁的例子，程序允许任务队列并发地搜索任务队列，但是要写入或者删除队列时，必须获得写模式的读写锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> job</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j_id;</span><br><span class="line">    <span class="keyword">struct</span> job *j_prev;</span><br><span class="line">    <span class="keyword">struct</span> job *j_next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">queue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> q_lock;</span><br><span class="line">    <span class="keyword">struct</span> job *q_head;</span><br><span class="line">    <span class="keyword">struct</span> job *q_tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_init</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    qp -&gt; q_head = <span class="literal">NULL</span>;</span><br><span class="line">    qp -&gt; q_tail = <span class="literal">NULL</span>;</span><br><span class="line">    err = pthread_rwlock_init(&amp;qp -&gt; q_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line">    <span class="keyword">for</span> (t = time(<span class="literal">NULL</span>); t+sec &gt; time(<span class="literal">NULL</span>); )</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_insert</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert a job at head</span></span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp -&gt; q_lock);</span><br><span class="line">    jp -&gt; j_next = qp -&gt; q_head;</span><br><span class="line">    jp -&gt; j_prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (qp -&gt; q_head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	qp -&gt; q_head -&gt; j_prev = jp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// empty list</span></span><br><span class="line">	qp -&gt; q_tail = jp;</span><br><span class="line">    &#125;</span><br><span class="line">    qp -&gt; q_head = jp;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp -&gt; q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// append a job to the list</span></span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp -&gt; q_lock);</span><br><span class="line">    jp -&gt; j_prev = qp -&gt; q_tail;</span><br><span class="line">    jp -&gt; j_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (qp -&gt; q_tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	qp -&gt; q_tail -&gt; j_next = jp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	qp -&gt; q_head = jp;</span><br><span class="line">    &#125;</span><br><span class="line">    qp -&gt; q_tail = jp;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp -&gt; q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_remove</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp -&gt; q_lock);</span><br><span class="line">    <span class="keyword">if</span> (jp == qp -&gt; q_head) &#123;</span><br><span class="line">	qp -&gt; q_head = jp -&gt; j_next;</span><br><span class="line">	<span class="keyword">if</span> (qp -&gt; q_tail == jp) &#123;</span><br><span class="line">	    qp -&gt; q_tail = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    jp -&gt; j_next -&gt; j_prev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jp == qp -&gt; q_tail) &#123;</span><br><span class="line">	qp -&gt; q_tail = jp -&gt; j_prev;</span><br><span class="line">	<span class="keyword">if</span> (jp == qp -&gt; q_head) &#123;</span><br><span class="line">	    qp -&gt; q_head = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    jp -&gt; j_prev -&gt; j_next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	jp -&gt; j_prev -&gt; j_next = jp -&gt; j_next;</span><br><span class="line">	jp -&gt; j_next -&gt; j_prev = jp -&gt; j_prev;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp -&gt; q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> job *<span class="title">job_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> job *jp;</span><br><span class="line">    <span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;qp -&gt; q_lock) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (jp = qp -&gt; q_head; jp != <span class="literal">NULL</span>; jp = jp -&gt; j_next) &#123;</span><br><span class="line">	<span class="keyword">if</span> (jp -&gt; j_id == id)</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp -&gt; q_lock);</span><br><span class="line">    <span class="keyword">return</span> jp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_jobs</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> job *jp;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_rwlock_rdlock(&amp;qp -&gt; q_lock)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_rwlock_rdlock error: %s\n"</span>, strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"delay before traversing\n"</span>);</span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Queue:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (jp = qp -&gt; q_head; jp != <span class="literal">NULL</span>; jp = jp-&gt; j_next) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" %d"</span>, jp -&gt; j_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp -&gt; q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NJOBS <span class="number">20</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">queue</span> *qp;</span><br><span class="line"><span class="keyword">struct</span> job* jp_arr[NJOBS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NJOBS; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"inserting\n"</span>);</span><br><span class="line">	<span class="keyword">struct</span> job *jp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> job));</span><br><span class="line">	jp -&gt; j_id = i;</span><br><span class="line">	<span class="keyword">if</span> (i%<span class="number">2</span>)</span><br><span class="line">	    job_insert(qp, jp);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    job_append(qp, jp);</span><br><span class="line">	jp_arr[i] = jp;</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NJOBS; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"deleting\n"</span>);</span><br><span class="line">    	job_remove(qp, jp_arr[i]);</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (qp -&gt; q_head != qp -&gt; q_tail) &#123;</span><br><span class="line">	traverse_jobs(qp);</span><br><span class="line">	delay(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Done\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    qp = (<span class="keyword">struct</span> <span class="built_in">queue</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">queue</span>));</span><br><span class="line">    err = queue_init(qp);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error: %s\n"</span>, strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error: %s\n"</span>, strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error: %s\n"</span>, strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = pthread_join(tid1, &amp;tret);</span><br><span class="line">    err = pthread_join(tid2, &amp;tret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5C4F_u969C"><a href="#u5C4F_u969C" class="headerlink" title="屏障"></a>屏障</h3><p>屏障是用户协调多个线程并行工作的同步机制。它允许多个线程暂停等待，直到所有的合作线程都达到某一点，然后从该点继续执行。<code>pthread_join</code>就是一种屏障，它暂停当前线程的运行，直到指定的线程退出为止。</p>
<p>接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(pthread_barrier_t *<span class="keyword">restrict</span> barriet,</span><br><span class="line">                        <span class="keyword">const</span> pthread_barrierattr_t *<span class="keyword">restrict</span> attr,</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(pthread_barrier_t *barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(pthread_barrier_t *barrier)</span></span>;</span><br></pre></td></tr></table></figure>
<p>初始化屏障时，使用<code>count</code>参数指定，在允许所有线程继续运行之前，必须达到屏障的线程数目。对于任意一个线程，<code>pthread_barrier_wait</code>函数返回了<code>PTHREAD_BARRIER_SERIAL_THREAD</code>，剩下的函数看到的返回都是0，这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。</p>
<p>屏障目前定义的只有进程共享属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(pthread_barrierattr_t *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(pthread_barrierattr_t *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="keyword">const</span> pthread_barrierattr_t *<span class="keyword">restrict</span> attr,</span><br><span class="line">                                  <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(pthread_barrierattr_t *attr,</span><br><span class="line">                                  <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个利用屏障来排序一个庞大的数组的实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NTHR   <span class="number">8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NUMNUM <span class="number">8000000L</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TNUM   (NUMNUM / NTHR)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> nums[NUMNUM];</span><br><span class="line"><span class="keyword">long</span> snums[NUMNUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_barrier_t</span> barrier;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmplong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *arg1, <span class="keyword">const</span> <span class="keyword">void</span> *arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l1 = *(<span class="keyword">long</span> *)arg1;</span><br><span class="line">    <span class="keyword">long</span> l2 = *(<span class="keyword">long</span> *)arg2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 == l2)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 &lt; l2)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> idx = (<span class="keyword">long</span>)arg;</span><br><span class="line"></span><br><span class="line">    qsort(&amp;nums[idx], TNUM, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), cmplong);</span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> idx[NTHR];</span><br><span class="line">    <span class="keyword">long</span> minidx, num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NTHR; i++)</span><br><span class="line">	idx[i] = i*TNUM;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sidx = <span class="number">0</span>; sidx&lt;NUMNUM; sidx++) &#123;</span><br><span class="line">	num = LONG_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NTHR; i++) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (idx[i] &lt; (i+<span class="number">1</span>)*TNUM &amp;&amp; num &gt; nums[idx[i]]) &#123;</span><br><span class="line">		num = nums[idx[i]];</span><br><span class="line">		minidx = i;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	snums[sidx] = num;</span><br><span class="line">	idx[minidx] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">struct</span> timeval start, end;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> startusec, endusec;</span><br><span class="line">    <span class="keyword">double</span> elapsed;</span><br><span class="line"></span><br><span class="line">    srandom(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>; i&lt;NUMNUM; i++) &#123;</span><br><span class="line">	nums[i] = random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, NTHR+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NTHR; i++) &#123;</span><br><span class="line">	err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, (<span class="keyword">void</span> *)(i*TNUM));</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error: %s\n"</span>, strerror(err));</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line">    merge();</span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">    endusec   = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">    elapsed   = (endusec - startusec) / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sort took %.4f seconds\n"</span>, elapsed);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NUMNUM; i++) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%ld\n"</span>, snums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序利用多个线程来并行地排序数组的某一个部分，然后主线程来合并各个线程的排序结果，我们比较一下它和单线程排序所花去的时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NUMNUM <span class="number">8000000L</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> nums[NUMNUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmplong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *arg1, <span class="keyword">const</span> <span class="keyword">void</span> *arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l1 = *(<span class="keyword">long</span> *)arg1;</span><br><span class="line">    <span class="keyword">long</span> l2 = *(<span class="keyword">long</span> *)arg2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 == l2)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 &lt; l2)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> timeval start, end;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> startusec, endusec;</span><br><span class="line">    </span><br><span class="line">    srandom(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>; i&lt;NUMNUM; i++) &#123;</span><br><span class="line">	nums[i] = random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    qsort(nums, NUMNUM, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), cmplong);</span><br><span class="line">    </span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">    endusec   = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> elapsed = (endusec - startusec) / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"normal sort time: %.4f\n"</span>, elapsed);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./barrier_sort 2&#62;/dev/null&#10;sort took 0.7819 seconds&#10;&#10;# zach41 @ zach41-H81M-S1 in ~/Desktop/UNIX-Demos/pthread on git:master x [14:02:50] &#10;$ ./norm_sort 2&#62;/dev/null&#10;normal sort time: 1.7947</span><br></pre></td></tr></table></figure>
<p>可以看到多线程排序所有时间明显低于单线程排序。</p>
<h1 id="u7EBF_u7A0B_u7279_u5B9A_u6570_u636E"><a href="#u7EBF_u7A0B_u7279_u5B9A_u6570_u636E" class="headerlink" title="线程特定数据"></a>线程特定数据</h1><p>线程特定数据，也称为线程私有数据，是存储和查询某个特定线程相关数据的一种机制。一个线程可以访问所属进程的整个地址空间，除了使用寄存器以外，一个线程没有办法阻止另一个线程访问它的数据，线程特定数据也不例外。虽然底层的实现部分并不能阻止这种访问能力，但是管理线程特定数据的函数可以提高线程间数据独立性，使得线程不太容易访问到其他线程的线程特定数据。</p>
<p>具体的可以看<a href="http://zach41.github.io/2016/09/21/%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82/" target="_blank" rel="external">用线程处理客户请求</a>中的<strong>线程特定数据</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/23/守护进程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/23/守护进程/" itemprop="url">
                  守护进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/23/守护进程/" class="leancloud_visitors" data-flag-title="守护进程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u5B88_u62A4_u8FDB_u7A0B"><a href="#u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="守护进程"></a>守护进程</h1><p>守护进程（daemon）是生存期长的一种进程。它们常常在系统引导装入时启动，在系统关闭时才终止。它们没有控制终端，所以它们一直在后台运行。UNIX系统中有很多守护进程，它们执行日常事务活动。</p>
<h1 id="u7F16_u5199_u5B88_u62A4_u8FDB_u7A0B"><a href="#u7F16_u5199_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="编写守护进程"></a>编写守护进程</h1><ol>
<li>首先调用<code>umask</code>设置文件模式创建屏蔽字。如果守护进程要创建文件，那么它可能要设定特定的权限，继承而来的文件模式创建屏蔽字可能会屏蔽某些权限。一般调用为<code>umask(0)</code>。</li>
<li>调用<code>fork</code>保证守护进程不是一个进程的组长进程，同时获得一个新的进程ID。</li>
<li>调用<code>setsid</code>创建一个会话</li>
<li>再次调用<code>fork</code>以保证当前进程不是会话的首进程，以防止日后打开一个终端时获得一个控制终端。</li>
<li>更改当前工作目录为根目录。这样可以防止某些文件系统不能被卸载。</li>
<li>关闭不需要的文件系统，通知把标准输入、标准输出和标准错误重定向到<code>/def/null</code>，这样可以防止某些利用这些描述符的库函数不会得不到描述符而出错。</li>
</ol>
<p>一个将普通进程转换成守护进程的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd0, fd1, fd2;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">struct</span> rlimit rl;</span><br><span class="line">    <span class="keyword">struct</span> sigaction sa;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">" getrlimit error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// become a session leader to lose controlling TTY</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* parent */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fork again, ensure future opens won;t allocate controlling TTY */</span></span><br><span class="line">    sa.sa_handler = SIG_IGN;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: can't ignore SIGHUP"</span>, cmd);</span><br><span class="line">	perror(<span class="string">""</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Change the current working directory to the root</span><br><span class="line">       so we won;t prevent file systems from being unmounted.</span><br><span class="line">       */</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"chdir error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* close all open file descriptors */</span></span><br><span class="line">    <span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY) &#123;</span><br><span class="line">	rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rl.rlim_max; i++) &#123;</span><br><span class="line">	close(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach stdin, stdout, stderr to /dev/null */</span></span><br><span class="line">    fd0 = open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    fd1 = dup(<span class="number">0</span>);</span><br><span class="line">    fd2 = dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize log file */</span></span><br><span class="line">    openlog(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">    <span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">	syslog(LOG_ERR, <span class="string">"unexpected file descriptors %d %d %d"</span>, fd0, fd1, fd2);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h1><p>守护进程的一个问题是如何处理出错信息，因为它没有控制终端，所以不能简单的写到标准错误上。可以利用<code>syslog</code>来记录守护进程的错误信息。<code>syslog</code>的组织结构如下：</p>
<img src="/2016/10/23/守护进程/syslog.png" alt="syslog.png" title="">
<p>有以下三种产生日志消息的方法：</p>
<ol>
<li>内核例程调用<code>log</code>函数。</li>
<li>大多数用户进程（守护进程）调用<code>syslog</code>函数产生日志消息</li>
<li>无论一个用户进程是否在此主机上，都可将日志消息发向UDP端口514.</li>
</ol>
<p><code>syslog</code>的接口为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">viud <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="u6587_u4EF6_u9501_u548C_u5355_u5B9E_u4F8B_u5B88_u62A4_u8FDB_u7A0B"><a href="#u6587_u4EF6_u9501_u548C_u5355_u5B9E_u4F8B_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="文件锁和单实例守护进程"></a>文件锁和单实例守护进程</h1><p><code>fcntl</code>函数可以用来给一整个文件或者是文件的部分区域加建议锁。文件锁分为<code>shared lock</code>和<code>execlusive lock</code>，一个文件可以加多个<code>shared lock</code>，就如同可以有多个读者一样，但是一个文件只能加一个<code>exclusive loc</code>，而且文件要么加<code>shared lock</code>要么加<code>exclusive lock</code>，不能同时加两个锁。</p>
<p>在设置文件锁时，需要传入<code>flock</code>结构的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> flock &#123;</span><br><span class="line">               ...</span><br><span class="line">               <span class="keyword">short</span> l_type;    <span class="comment">/* Type of lock: F_RDLCK,</span><br><span class="line">                                   F_WRLCK, F_UNLCK */</span></span><br><span class="line">               <span class="keyword">short</span> l_whence;  <span class="comment">/* How to interpret l_start:</span><br><span class="line">                                   SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">               <span class="keyword">off_t</span> l_start;   <span class="comment">/* Starting offset for lock */</span></span><br><span class="line">               <span class="keyword">off_t</span> l_len;     <span class="comment">/* Number of bytes to lock */</span></span><br><span class="line">               <span class="keyword">pid_t</span> l_pid;     <span class="comment">/* PID of process blocking our lock</span><br><span class="line">                                   (F_GETLK only) */</span></span><br><span class="line">               ...</span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，如果<code>l_len</code>被设置成0，那么从<code>l_whence</code>和<code>l_start</code>指定的位置开始到文件的末尾都被加上了文件锁。</p>
<p><code>fcntl</code>有三种和文件锁有关的操作：</p>
<ol>
<li>F_GETLK：<code>flock</code>参数表示调用者这时候想要加上的锁，如果锁能被加上，那么<code>fcntl</code>并没有实际上锁，它将<code>l_type</code>置为<code>F_UNLCK</code>。如果不能上锁，那么就把文件锁的相关信息填入<code>flock</code>参数中。</li>
<li>F_SETLK：给文件设置锁，如果另外一个进程已经持有锁而使得当前进程无法获得锁，返回-1。</li>
<li>F_SETLKW：和F_SETLCK一样，但是当锁无法获得时，调用进程被阻塞，直至锁可用。</li>
</ol>
<p>需要注意一点是，当对应的文件被关闭时，其上的锁被自动释放，子进程也无法继承父进程的锁。当拥有锁的进程终止时，锁也被自动释放。</p>
<p><code>flock</code>接口也可以获得文件锁（另外一种文件锁，不一定和上文的文件锁兼容），不同的是，子进程可以继承父进程的文件锁，但是子进程得到的只是文件锁的引用，即如果子进程释放文件锁，那么父进程的文件锁也被释放。具体可以参看<code>flock(2)</code>的manual。</p>
<p>我们利用<code>fcntl</code>函数设置文件锁，只有当前运行的守护进程拥有文件锁，之后尝试启动的守护进程都将无法得到该文件锁，从而无法启动，于是就可以达到单实例守护进程的目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOCKFILE <span class="string">"/var/run/daemon.pid"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOCKMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// re-read configuration</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lockfile</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> flock fl;</span><br><span class="line"></span><br><span class="line">    fl.l_start = <span class="number">0</span>;</span><br><span class="line">    fl.l_len = <span class="number">0</span>;</span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_type = F_WRLCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETLK, &amp;fl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd0, fd1, fd2;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">struct</span> rlimit rl;</span><br><span class="line">    <span class="keyword">struct</span> sigaction sa;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">" getrlimit error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// become a session leader to lose controlling TTY</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* parent */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fork again, ensure future opens won;t allocate controlling TTY */</span></span><br><span class="line">    sa.sa_handler = SIG_IGN;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: can't ignore SIGHUP"</span>, cmd);</span><br><span class="line">	perror(<span class="string">""</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Change the current working directory to the root</span><br><span class="line">       so we won;t prevent file systems from being unmounted.</span><br><span class="line">       */</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"chdir error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* close all open file descriptors */</span></span><br><span class="line">    <span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY) &#123;</span><br><span class="line">	rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rl.rlim_max; i++) &#123;</span><br><span class="line">	close(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach stdin, stdout, stderr to /dev/null */</span></span><br><span class="line">    fd0 = open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    fd1 = dup(<span class="number">0</span>);</span><br><span class="line">    fd2 = dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize log file */</span></span><br><span class="line">    openlog(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">    <span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">	syslog(LOG_ERR, <span class="string">"unexpected file descriptors %d %d %d"</span>, fd0, fd1, fd2);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">already_running</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    fd = open(LOCKFILE, O_RDWR | O_CREAT, LOCKMODE);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	syslog(LOG_ERR, <span class="string">"can't open %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lockfile(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (errno == EACCES || errno == EAGAIN) &#123;</span><br><span class="line">	    <span class="comment">/* already has one daemon running */</span></span><br><span class="line">	    close(fd);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	syslog(LOG_ERR, <span class="string">"can't lock %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ftruncate(fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%ld"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> *cmd;</span><br><span class="line">    <span class="keyword">struct</span> sigaction sa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cmd = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">'/'</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	cmd = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	cmd++;</span><br><span class="line"></span><br><span class="line">    daemonize(cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (already_running()) &#123;</span><br><span class="line">    	syslog(LOG_ERR, <span class="string">"daemon already running"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do daemon's work */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行一次之后，我们尝试在此运行，查看<code>/var/log/syslog</code>得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oct 23 17:00:35 localhost a.out: daemon already running</span><br></pre></td></tr></table></figure>
<h1 id="u4F7F_u7528sigwait_u4EE5_u53CA_u591A_u7EBF_u7A0B_u5904_u7406_u4FE1_u53F7"><a href="#u4F7F_u7528sigwait_u4EE5_u53CA_u591A_u7EBF_u7A0B_u5904_u7406_u4FE1_u53F7" class="headerlink" title="使用sigwait以及多线程处理信号"></a>使用sigwait以及多线程处理信号</h1><p>守护进程一般在接受到SIGHUP信号后重新读区其配置文件。这是因为守护进程没有控制终端，它永远不会收到来自终端的SIGHUP信号，那么就可以将SIGHUP信号重复使用，收到该信号就重新读取配置文件。</p>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOCKFILE <span class="string">"/var/run/daemon.pid"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOCKMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// re-read configuration</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lockfile</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> flock fl;</span><br><span class="line"></span><br><span class="line">    fl.l_start = <span class="number">0</span>;</span><br><span class="line">    fl.l_len = <span class="number">0</span>;</span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_type = F_WRLCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETLK, &amp;fl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd0, fd1, fd2;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">struct</span> rlimit rl;</span><br><span class="line">    <span class="keyword">struct</span> sigaction sa;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">" getrlimit error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// become a session leader to lose controlling TTY</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* parent */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fork again, ensure future opens won;t allocate controlling TTY */</span></span><br><span class="line">    sa.sa_handler = SIG_IGN;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: can't ignore SIGHUP"</span>, cmd);</span><br><span class="line">	perror(<span class="string">""</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Change the current working directory to the root</span><br><span class="line">       so we won;t prevent file systems from being unmounted.</span><br><span class="line">       */</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"chdir error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* close all open file descriptors */</span></span><br><span class="line">    <span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY) &#123;</span><br><span class="line">	rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rl.rlim_max; i++) &#123;</span><br><span class="line">	close(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach stdin, stdout, stderr to /dev/null */</span></span><br><span class="line">    fd0 = open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    fd1 = dup(<span class="number">0</span>);</span><br><span class="line">    fd2 = dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize log file */</span></span><br><span class="line">    openlog(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">    <span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">	syslog(LOG_ERR, <span class="string">"unexpected file descriptors %d %d %d"</span>, fd0, fd1, fd2);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">already_running</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    fd = open(LOCKFILE, O_RDWR | O_CREAT, LOCKMODE);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	syslog(LOG_ERR, <span class="string">"can't open %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lockfile(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (errno == EACCES || errno == EAGAIN) &#123;</span><br><span class="line">	    <span class="comment">/* already has one daemon running */</span></span><br><span class="line">	    close(fd);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	syslog(LOG_ERR, <span class="string">"can't lock %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ftruncate(fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%ld"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err, signo;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	err = sigwait(&amp;mask, &amp;signo);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">	    syslog(LOG_ERR, <span class="string">"sigwait failed"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">	<span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line">	    syslog(LOG_INFO, <span class="string">"Re-reading configuration file"</span>);</span><br><span class="line">	    reread();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> SIGTERM: &#123;</span><br><span class="line">	    syslog(LOG_INFO, <span class="string">"got SIGTERM; exiting"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	    syslog(LOG_INFO, <span class="string">"unexpected signal %d\n"</span>, signo);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> *cmd;</span><br><span class="line">    <span class="keyword">struct</span> sigaction sa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cmd = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">'/'</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	cmd = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	cmd++;</span><br><span class="line"></span><br><span class="line">    daemonize(cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (already_running()) &#123;</span><br><span class="line">    	syslog(LOG_ERR, <span class="string">"daemon already running"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">      Restore SIGHUP default and block all signals</span><br><span class="line">      */</span></span><br><span class="line">    sa.sa_handler = SIG_DFL;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	syslog(LOG_ERR, <span class="string">"%s: can't restore SIGHUP default"</span>, cmd);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigfillset(&amp;mask);</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_sigmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	syslog(LOG_ERR, <span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    	syslog(LOG_ERR, <span class="string">"can't create thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do daemon's work */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们将SIGHUP的处理函数恢复的到默认之后（否则进程忽略这个信号，sigwait永远不会见到它），阻塞所有信号，然后创建一个线程处理信号。该线程的唯一工作是等待SIGHUP和SIGTERM。当收到SIGHUP是就重新读取配置文件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/23/进程关系/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/23/进程关系/" itemprop="url">
                  进程关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/23/进程关系/" class="leancloud_visitors" data-flag-title="进程关系">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u7EC8_u7AEF_u767B_u5F55"><a href="#u7EC8_u7AEF_u767B_u5F55" class="headerlink" title="终端登录"></a>终端登录</h1><p>对于终端设备登陆，系统管理员首先创建一个配置文件，每一个终端设备在配置文件中占一行。当系统自举时，内核创建进程ID为1的进程，即<code>init</code>进程。<code>init</code>进程使系统进入多用户模式，它读取终端设备的配置文件，对灭一个允许登录的终端设备，它调用一次<code>fork</code>，然后用生成的子进程调用<code>exec</code>，执行<code>getty</code>程序。而<code>getty</code>则对终端设备调用<code>open</code>函数，以读写方式打开终端。如果设备时调制解调器，则<code>open</code>会在驱动中滞留，知道用户拨号调制解调器，并且线路被接通。一旦设备被打开，文件描述符0，1，2就被舍知道该设备，然后<code>getty</code>输入<code>login：</code>之类的信息，等到用户输入用户名。</p>
<p>一旦用户输入了用户名，那么<code>getty</code>的工作就完成了，然后它调用<code>login</code>程序，提示用户输入密码，如果用户输入正确，那么：</p>
<ul>
<li>将当前工作目录改为用户的起始目录。</li>
<li>调用<code>chown</code>更改终端的所有权，是登录用户称为它的所有者</li>
<li>更改终端设备的访问权限为当前用户可读写</li>
<li>调用<code>setgid</code>和<code>initgroups</code>设置进程的组ID</li>
<li>用<code>login</code>得到的所有信息初始化环境：HOME、shell、USERNAME、LOGNAME以及一个系统默认路径（PATH）。</li>
<li><code>login</code>进程更改为登录用户的用户ID（<code>setuid</code>）并调用该用户的登录<code>shell</code>。</li>
</ul>
<p>执行流程示意如下：</p>
<img src="/2016/10/23/进程关系/login_shell.png" alt="login_shell.png" title="">
<p>注意一点，<code>init</code>是以特权模式运行的，<code>login</code>因为也在特权模式下运行，<code>setuid</code>会改变进程的3个用户ID：实际用户ID、有效用户ID和保存的设置用户ID。</p>
<p>当用户登出时，<code>shell</code>进程被终止，于是<code>init</code>进程得到通知，它会对终端设备重复上述过程。</p>
<h3 id="u7F51_u7EDC_u767B_u5F55"><a href="#u7F51_u7EDC_u767B_u5F55" class="headerlink" title="网络登录"></a>网络登录</h3><p>网络登录和通过串行终端登录的不同之处在于<code>init</code>进程无法知道会有多少个用户通过网络登录，它也就无法通过预先配置终端文件生成进程的方式来等到用户登录。</p>
<p>当用户通过网络来登录时，守护进程<code>inetd</code>（linux下时<code>xinetd</code>）会收到请求，它<code>fork</code>一个进程来处理这个连接请求。一个<code>telnet</code>登录示意如下：</p>
<img src="/2016/10/23/进程关系/telnet_login.png" alt="telnet_login.png" title="">
<p><code>telnetd</code>进程打开一个伪终端设备，并用<code>fork</code>分成两个进程，父进程负责处理网络请求，子进程则执行<code>login</code>。父进程和子进程通过伪终端相连接。</p>
<p>需要理解的重点是：我们得到一个登录shell时，其标准输入、标准输出和标准错误要么连接到一个终端设备，要么连接到一个伪终端设备。</p>
<h1 id="u8FDB_u7A0B_u7EC4"><a href="#u8FDB_u7A0B_u7EC4" class="headerlink" title="进程组"></a>进程组</h1><p>进程组是一个或者多个进程的集合。通常，它们是在同一作业中结合起来的，同一进程组的各个进程收到来自统一终端的各种信号。每个进程组有一个唯一的进程组ID。每一个进程组有一个组长进程，组长进程的进程ID即进程组ID。需要注意的是，如果组长进程退出了，进程组仍然存在，而且进程组ID不变，只有当进程组内所有的进程都退出了，那么进程组的生命周期才算结束。</p>
<p>相关接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpgrp();		<span class="comment">/* 返回当前进程组ID*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);		<span class="comment">/* 返回进程ID为pid的进程组ID，pid = 0时和`getpgrp`等效 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(pid_t pid, pid_t pgid)</span></span>;		<span class="comment">/* 加入一个现有进程组或创建一个新进程组，进程职能为它自己和其子										进程设置进程组 */</span></span><br></pre></td></tr></table></figure>
<h1 id="u4F1A_u8BDD"><a href="#u4F1A_u8BDD" class="headerlink" title="会话"></a>会话</h1><p>会话（session）是一个或者多个进程组的集合。通常是由shell的管道将几个进程变成一组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> setsid();</span><br></pre></td></tr></table></figure>
<p><code>setsid</code>函数建立一个新的会话。函数调用成功的前提是调用进程不是一个进程组的组长进程。如果调用成功：</p>
<ul>
<li>进程变成新会话进程的首进程（<code>session leader</code>）</li>
<li>该进程称为一个新的进程组的组长进程，进程组ID为当前进程ID，会话ID也为当前进程ID。</li>
<li>该进程没有控制终端，如果在调用<code>setsid</code>之前有控制终端，这个联系也被切断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid);</span><br></pre></td></tr></table></figure>
<p><code>getsid</code>函数返回对应进程的会话首进程的进程组ID，如果<code>pid == 0</code>那么返回当前进程的对应值。出于安全考虑，如果<code>pid</code>不属于调用者所在的会话，那么调用失败。</p>
<h1 id="u63A7_u5236_u7EC8_u7AEF"><a href="#u63A7_u5236_u7EC8_u7AEF" class="headerlink" title="控制终端"></a>控制终端</h1><p>会话和进程组还有一些其他特性：</p>
<ul>
<li>一个会话可以有一个控制终端（controlling terminal），这通常是终端或者伪终端设备。</li>
<li>与控制终端建立连接的会话首进程称为控制进程。</li>
<li>一个会话的进程组可以被分割为一个前台进程组（foreground process group）和若干个后台进程组（background process group）。</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组</li>
<li>中断键（Ctrl-C）、退出键（Ctrl-\）都被发送至前台进程组的所有进程。</li>
<li>如果终端断开连接，则挂断信息发送至控制进程。</li>
</ul>
<p>特性示意：</p>
<img src="/2016/10/23/进程关系/session_property.png" alt="session_property.png" title="">
<p>有时候后台进程组也需要和终端交互，这时候后台进程组可以打开终端设备。当然用户也可以配置终端以防止后台进程和终端进行交互。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd);		<span class="comment">/* 返回前台进程组ID，它与fd上打开的终端相关联 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, pid_t pgrpid)</span></span>;		<span class="comment">/* 将前台进程组设置为pgrpid，fd必须饮用该会话的控制终端 */</span></span><br><span class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd);		<span class="comment">/* 得到控制控端的会话首进程的会话ID */</span></span><br></pre></td></tr></table></figure>
<h1 id="u5B64_u513F_u8FDB_u7A0B_u7EC4"><a href="#u5B64_u513F_u8FDB_u7A0B_u7EC4" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h1><p>POSIX.1将孤儿进程组定义为：该组的成员的父进程要么是该组的一个成员，要么不是改组所属会话的成员。POSIX.1要求向新的孤儿进程组中处于停滞状态的每一个成员发送挂断信号（SIGHUP），接着又向其发送继续信号（SIGCONT）。</p>
<p>一个孤儿进程的例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_hup</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGHUP received, pid=%ld\n"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr_ids</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: pid = %ld, ppid = %ld, pgrp = %ld, tpgrp = %ld\n"</span>,</span><br><span class="line">	   name, (<span class="keyword">long</span>)getpid(), (<span class="keyword">long</span>)getppid(), (<span class="keyword">long</span>)getpgrp(), (<span class="keyword">long</span>)tcgetpgrp(STDIN_FILENO));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pr_ids(<span class="string">"parent"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	pr_ids(<span class="string">"child"</span>);</span><br><span class="line">	signal(SIGHUP, sig_hup);</span><br><span class="line">	kill(getpid(), SIGTSTP);</span><br><span class="line">	pr_ids(<span class="string">"child"</span>);</span><br><span class="line">	<span class="keyword">if</span> (read(STDIN_FILENO, &amp;c, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"read error %d on controlling TTY\n"</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程设置SIGHUP信号的处理函数后将自己停止，当父进程退出后，子进程变成一个新的孤儿进程组的成员，于是系统向这个进程组发送SIGHUP信号，子进程的处理函数被触发，之后子进程又收到SIGCONT信号，程序继续执行。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ ./a.out &#10;parent: pid = 16564, ppid = 4501, pgrp = 16564, tpgrp = 16564&#10;child: pid = 16565, ppid = 16564, pgrp = 16564, tpgrp = 16564&#10;SIGHUP received, pid=16565                                                                                                                                                                                                                    &#10;child: pid = 16565, ppid = 1, pgrp = 16564, tpgrp = 4501&#10;read error 5 on controlling TTY</span><br></pre></td></tr></table></figure>
<p>由于子进程是孤儿进程组，它如果尝试向终端读取数据，就会出错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/20/进程控制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/20/进程控制/" itemprop="url">
                  进程控制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/20/进程控制/" class="leancloud_visitors" data-flag-title="进程控制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u8FDB_u7A0B_u6807_u8BC6"><a href="#u8FDB_u7A0B_u6807_u8BC6" class="headerlink" title="进程标识"></a>进程标识</h1><p>每一个进程都有一个非负的进程ID来唯一标识自己，虽然ID唯一，但是ID可以复用，如果一个进程被销毁了，那么它的ID就可以被新创建的进程所使用。除了进程ID，进程还有其他一些标识符：</p>
<ul>
<li><code>uid</code>：进程的实际用户ID</li>
<li><code>eid</code>：进程的有效用户ID</li>
<li><code>ppid</code>：进程的父亲进程ID</li>
<li><code>gid</code>：进程的实际组ID</li>
<li><code>egid</code>：进程的有效组ID</li>
</ul>
<p>获得这些标识的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getppid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">uid_t</span> getuid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">uid_t</span> geteuid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">gid_t</span> getgid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">gid_t</span> getegid();</span><br></pre></td></tr></table></figure>
<h3 id="uid_u4E0Eeuid_uFF0Cgid_u4E0Eegid"><a href="#uid_u4E0Eeuid_uFF0Cgid_u4E0Eegid" class="headerlink" title="uid与euid，gid与egid"></a>uid与euid，gid与egid</h3><p>这两组值用来管理进程的访问权限。这里只说明<code>uid</code>和<code>euid</code>，<code>gid</code>和<code>egid</code>作用类似，只不过它们作用于进程组。</p>
<ul>
<li><code>uid</code>指的是登录用户的用户ID</li>
<li><code>euid</code>是进程用来决定我们对资源的访问权限，一般实际用户ID等于有效用户ID，当设置用户ID时，有效用户ID等于文件的所有者。</li>
</ul>
<p>举一个例子，如果一个文件的所有者是root，同时该文件被设置了用户ID，即用<code>ls</code>命令得到了如下的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l system_secure&#10;-rwsrwxr-x 1 root zach41 8720 10&#26376; 20 16:07 system_secure</span><br></pre></td></tr></table></figure>
<p>那么当用户<code>zach41</code>执行这个文件时，在执行期间进程获得了文件拥有者root的权限。</p>
<p>我们可以用<code>setuid</code>来设置实际用户ID和有效用户ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(uid_t uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(gid_t gid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>设置权限的规则如下：</p>
<ol>
<li>如果进程具有超级用户权限，那么<code>setuid</code>讲实际用户ID、有效用户ID、保存的用户ID都设置成uid。</li>
<li>如果进程不具有超级用户权限，但是<code>uid</code>等于实际用户ID或者保存的用户ID，那么<code>setuid</code>讲有效用户ID设置成<code>uid</code>。不更改实际用户ID和保存的用户ID。</li>
<li>如果上述规则都不满足，则<code>errno</code>设置成<strong>EPERM</strong>，并返回-1。</li>
</ol>
<p>另外两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(uid_t uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(gid_t gid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于一个特权用户来说，<code>seteuid</code>可以将有效用户ID设置成<code>uid</code>，而<code>setuid</code>更改所有的3个用户ID。对于一个非特权用户，可以利用该函数讲有效用户ID设置为实际用户ID或者保存的设置用户ID。</p>
<h1 id="u8FDB_u7A0B_u521B_u5EFA_u4E0E_u9500_u6BC1"><a href="#u8FDB_u7A0B_u521B_u5EFA_u4E0E_u9500_u6BC1" class="headerlink" title="进程创建与销毁"></a>进程创建与销毁</h1><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><p>可以用<code>fork</code>来创建一个进程，用<code>exit</code>来销毁一个进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork();</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fork</code>函数返回两次，在父进程中函数返回值为新生成的子进程的<code>pid</code>，在子进程中返回值为0。一个比较典型的<code>fork</code>调用范式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pid = fork) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* fork error*/</span></span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* child process*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* parent process*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fork</code>通常有一下两种用法：</p>
<ol>
<li>一个父进程希望自己复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中比较常见。</li>
<li>一个进程需要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从<code>fork</code>中返回后立即调用<code>exec</code>函数。</li>
</ol>
<p><code>fork</code>的一个特性是，子进程复制父进程所有打开的描述符，这里只是复制文件描述符，父进程和子进程共享文件表项。一个典型的<code>fork</code>之后的文件描述图示：</p>
<img src="/2016/10/20/进程控制/file_shared.png" alt="file_shared.png" title="">
<p>除了打开的文件之外，子进程还继承了父进程的：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标识和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭<code>close-on-exec</code>标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
</ul>
<p>一个<code>fork</code>的演示例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> globalvar = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"a write to stdout\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(STDOUT_FILENO, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>) != <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	globalvar++;</span><br><span class="line">	var++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid = %ld, globalvar = %d, var = %d\n"</span>, (<span class="keyword">long</span>)pid, globalvar, var);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;a write to stdout&#10;before fork&#10;pid = 0, globalvar = 7, var = 89&#10;pid = 11510, globalvar = 6, var = 88&#10;&#10;$ ./a.out &#62; fork_buf.out&#10;&#10;a write to stdout&#10;before fork&#10;pid = 0, globalvar = 7, var = 89&#10;before fork&#10;pid = 11589, globalvar = 6, var = 88</span><br></pre></td></tr></table></figure>
<p>父进程在执行<code>fork</code>后主动睡眠，让子进程先执行（实际上这在有的时候也不能保证，需要用更高级的方法），可以看到子进程输出的<code>globalvar</code>和<code>var</code>都加了1，而父进程没有。</p>
<p>如果我们重定向了标准输出，那么就会看到<code>before fork</code>被输出了两次，这是因为当标准输出和一个文件相关联时它是全缓冲的，在<code>fork</code>之前，字符串被存放到缓冲区中，<code>fork</code>函数导致父进程的数据空间被复制到子进程中，标准输出的缓冲区也同样被复制，这样当进程结束时，缓冲区被清洗，于是就有了两次<code>brefore fork</code>的输出。在第一个例子中，由于标准输出和一个终端相关联，它是行缓冲的，所以只输出了一次<code>before fork</code>。</p>
<h3 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h3><p>进程有5种正常终止以及3种异常终止方式。</p>
<p>正常终止方式：</p>
<ol>
<li>在main函数中调用<code>return</code>语句</li>
<li>调用<code>exit</code>函数，其操作包括调用各个终止函数（由<code>atexit</code>函数注册），然后关闭所有的标准I/O流。在<code>main</code>函数里调用<code>return</code>语句等效于调用<code>exit</code>函数。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>函数。函数不运行各个终止函数，也不冲洗I/O流，但是它关闭所有打开的文件流。</li>
<li>进程的最后一个线程在其启动例程中执行<code>return</code>语句，但是该线程的返回值不用作进程的返回值。当最后一个线程中其启动例程返回时，该进程以终止状态0返回。</li>
<li>进程的最后一个线程调用pthread_exit函数，进程的终止状态为0。</li>
</ol>
<p>异常终止方式：</p>
<ol>
<li>调用<code>abort</code>函数</li>
<li>进程收到信号</li>
<li>最后一个线程对”取消”请求作出响应。</li>
</ol>
<p>进程终止函数由<code>atexit</code>函数注册：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int atexit(void (*func)(void));</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear_onexit1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"On exit1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear_onexit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"On exit2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"At Exit Demo!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atexit(clear_onexit1) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't register `clear_onexit1`"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (atexit(clear_onexit1) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't register `clear_onexit1`"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (atexit(clear_onexit2) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't register `clear_onexit1`"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* _exit(0); */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#10;At Exit Demo!&#10;On exit2&#10;On exit1&#10;On exit1</span><br></pre></td></tr></table></figure>
<p>可以看到一个函数可以多次被注册，而且执行的顺序和注册的顺序相反。</p>
<p>在一个进程退出后，如果它有子进程，那么它的所有子进程由<code>init</code>进程收养。而如果一个子进程在退出后，父进程没有调用<code>wait</code>或者<code>waitpid</code>去获取子进程的退出状态，那么子进程就会成为僵尸进程。僵尸进程的地址空间被内核收回，所有打开的文件也被关闭，但是内核保存它的终止状态、进程ID以及CPU时间总量。</p>
<h3 id="wait__26amp_3B_waitpid"><a href="#wait__26amp_3B_waitpid" class="headerlink" title="wait &amp; waitpid"></a>wait &amp; waitpid</h3><p>上一小节说到如果子进程的终止状态没有被父进程通过<code>wait</code>或者<code>waitpid</code>得到，那么子进程就会变成僵尸进程。这两个函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p><code>wait</code>等待任意一个子进程终止，如果没有子进程，那么函数出错。子进程的终止状态被存入<code>statloc</code>指向的内存地址。</p>
<p><code>waitpid</code>可以等待特定进程终止。<code>options</code>可以进一步控制函数的行为：</p>
<ul>
<li>WCONTINUED：若实现支持作业控制，那么由<code>pid</code>指定的任一子进程在停止后已经继续，但其状态未报告，则返回其状态</li>
<li>WNOHANG：若由<code>pid</code>指定的子进程不是立即调用，则<code>waitpid</code>不阻塞，返回值为0。</li>
<li>WUNTRACED：若实现支持作业控制，而由<code>pid</code>指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告，则返回其状态。<code>WIFSTOPPED</code>宏确定返回值是否对应于一个停止的子进程。</li>
</ul>
<p>可以利用以下宏来检查返回的状态值：</p>
<ul>
<li>WIFEXITED(status)：若正常终止，返回值为真，此时可执行<code>WEXITSTATUS(status)</code>，获取子进程传送给<code>exit</code>或者<code>_exit</code>参数的低8位。</li>
<li>WIFSIGNALED(status)：若为异常终止子进程，返回真。此时可以执行<code>WTERMSIG(status)</code>获取终止的信号值，而且如果有产生终止进程的core文件，那么<code>WCOREDUMP(status)</code>返回真。</li>
<li>WIFSTOPPED(status)：若为当前暂停子进程的返回的状态，那么为真。此时可以执行<code>WSTOPSIG(status)</code>得到使得子进程暂停的信号。</li>
<li>WIFCONTINUED(status)：若在作业控制暂停后已经继续的子进程返回了状态，那么为真。</li>
</ul>
<p>这里给一个<code>waitpid</code>的例子，同时也说明如何<code>fork</code>两次来让子进程在退出后不会变成僵尸进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"fork error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent process id: %ld\n"</span>, (<span class="keyword">long</span>)getppid());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != pid) &#123;</span><br><span class="line">	perror(<span class="string">"wait error"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Zach @ ZachMacbook in ~/Desktop/UNIX_Demos/proc_demos on git:master x [22:26:56] &#10;$ ./a.out &#10;&#10;# Zach @ ZachMacbook in ~/Desktop/UNIX_Demos/proc_demos on git:master x [22:26:59] &#10;$ parent process id: 1&#10;&#10;&#10;# Zach @ ZachMacbook in ~/Desktop/UNIX_Demos/proc_demos on git:master x</span><br></pre></td></tr></table></figure>
<p>可以看到第二个子进程的父进程后来变成了<code>init</code>进程，<code>init</code>进程不断地调用<code>wait</code>来等待其子进程退出，故而第二个子进程不会成为僵尸进程。输出中看到了在<code>./a.out</code>后输出了shell提示符，这是因为父进程首先退出了。</p>
<h1 id="u7ADE_u4E89_u6761_u4EF6"><a href="#u7ADE_u4E89_u6761_u4EF6" class="headerlink" title="竞争条件"></a>竞争条件</h1><p>前面提到过，在<code>fork</code>之后我们特意调用<code>sleep</code>函数然父进程睡眠，从而让子进程首先执行，这个方法是欠妥的，在一个非常繁忙的系统中，子进程不一定会先执行。这种不确定性就是进程的竞争条件。为了让子进程首先执行，我们需要一种特殊的手段。这里给出一种利用管道来实现进程同步的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_wait</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_parent</span><span class="params">(pid_t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_child</span><span class="params">(pid_t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wait_child</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wati_parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    tell_wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	charatatime(<span class="string">"output from child\n"</span>);</span><br><span class="line">	tell_parent(getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	wait_child();</span><br><span class="line">	charatatime(<span class="string">"output from parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (; *ptr != <span class="number">0</span>; ptr++) &#123;</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	putc(*ptr, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"pipe error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_parent</span><span class="params">(pid_t pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], <span class="string">"p"</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wait_child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> ((n = read(pipefd[<span class="number">0</span>], &amp;c, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"read error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">'p'</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"wait child error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tell_wait</code>初始化管道</li>
<li><code>wait_xxx</code>：从管道读端读一个字符，如果写端没有写，那么进程被内核投入睡眠</li>
<li><code>tell_xxx</code>：从管道写端写，唤醒被睡眠的读端进程吗，，从而达到进程同步的目的。</li>
</ul>
<h1 id="exec_u51FD_u6570"><a href="#exec_u51FD_u6570" class="headerlink" title="exec函数"></a>exec函数</h1><p><code>exec</code>函数族将<code>fork</code>的程序完全替换为另外一个程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ececle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0, char *const envp[]*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> agrv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>exec</code>函数族命名规则如下：</p>
<ul>
<li>含有<code>l</code>：程序参数以列表形式<code>arg0, arg1, ... argn, (char *)0</code>形式传入。</li>
<li>含有<code>v</code>：程序参数以向量形式<code>argv[]</code>传入，数组最后一个元素为NULL。</li>
<li>含有<code>p</code>：程序文件的路径名在环境变量<code>PATH</code>指定的路径下寻找</li>
<li>含有<code>e</code>：程序的环境变量由参数<code>envp</code>提供，否则继承父进程的环境变量</li>
<li>含有<code>f</code>：由文件描述符来代表程序文件。</li>
</ul>
<h1 id="u89E3_u91CA_u5668_u6587_u4EF6"><a href="#u89E3_u91CA_u5668_u6587_u4EF6" class="headerlink" title="解释器文件"></a>解释器文件</h1><p>解释器文件是一种文本文件，它的起始行格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! pathname [optional-arguement]</span><br></pre></td></tr></table></figure>
<p><code>pathname</code>一般为绝对路径。对这种文件的识别是由内核作为<code>exec</code>系统调用处理的一部分来完成的。内核使得调用<code>exec</code>函数的进程实际执行的不是这个解释器文件，而是在解释器文件第一行<code>pathname</code>所指定的文件，即解释器为<code>pathname</code>指定的文件，解释器文件为该文件。</p>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (execl(<span class="string">"./testinterp"</span>, <span class="string">"testinterp"</span>, <span class="string">"myarg1"</span>, <span class="string">"MY ARG2"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"execl error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"waitpid error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! /home/ubuntu/Desktop/UNIX-Demos/proc_demos/echoall foo</span><br></pre></td></tr></table></figure>
<p>echoall程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> **ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"argv[%d] : %s\n"</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for (ptr = environ; *ptr != 0; ptr++) &#123; */</span></span><br><span class="line">    <span class="comment">/* 	printf("%s\n", *ptr); */</span></span><br><span class="line">    <span class="comment">/* &#125; */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argv[0] : /home/ubuntu/UNIX-Demos/proc_demos/echoall&#10;argv[1] : foo&#10;argv[2] : ./testinterp&#10;argv[3] : myarg1&#10;argv[4] : MY ARG2&#10;ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$</span><br></pre></td></tr></table></figure>
<p>如一个<code>awk</code>脚本文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/awk -f&#10;# A awk example&#10;BEGIN &#123;&#10;      for (i=0; i&#60;ARGC; i++)&#10;          printf &#34;ARGV[%d] = %s\n&#34;, i, ARGV[i]&#10;      exit&#9;  &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行<code>./awkeample file1 file2</code>时，命令以以下方式被执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/awk -f /path/to/awkexample file1 file2</span><br></pre></td></tr></table></figure>
<p>于是<code>awk</code>程序执行该脚本输出所有参数的值。</p>
<h1 id="u8FDB_u7A0B_u8C03_u5EA6"><a href="#u8FDB_u7A0B_u8C03_u5EA6" class="headerlink" title="进程调度"></a>进程调度</h1><p>可以通过<code>nice</code>值来调控进程优先级，进程的<code>nice</code>值范围在[0, 2*NZERO-1]，<code>nice</code>值高的进程优先级越低（表示越友好）。进程可以通过<code>nice</code>函数接口来获得或者设置<code>nice</code>值，进程只能设置自己的<code>nice</code>值，而无法影响其他进程的<code>nice</code>值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>incr</code>参数被加到进程当前的nice值上，函数返回进程的<code>nice</code>值减去<code>NZERO</code>。所以如果函数返回-1，这时候函数调用可能是出错也可能调用正常，需要检查<code>errno</code>是否为0。<code>incr</code>置为0可以得到进程当前的<code>nice</code>减去<code>NZERO</code>的值。</p>
<p>系统的<code>NZERO</code>值可以通过<code>sysconf</code>函数得到。</p>
<h1 id="u8FDB_u7A0B_u65F6_u95F4"><a href="#u8FDB_u7A0B_u65F6_u95F4" class="headerlink" title="进程时间"></a>进程时间</h1><p>进程有三个时间：</p>
<ul>
<li>墙上时间：进程运行的总时间</li>
<li>用户CPU时间：进程运行用户指令的时间</li>
<li>系统CPU时间：程序调用系统调用后，内核执行系统服务所花去的时间。</li>
</ul>
<p>任何一个进程都可以通过调用<code>times</code>函数获得它自己以及已终止的子进程的上述三个值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> times(<span class="keyword">struct</span> tms *buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tms &#123;</span><br><span class="line">  <span class="keyword">clock_t</span> tms_utime;	<span class="comment">// user cpu time</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_stime;	<span class="comment">// system cpu time</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cutime; 	<span class="comment">// user cpu time, terminated children</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cstime;	<span class="comment">// system cpu time, terminated childrem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>times</code>函数返回进程的墙上时钟。注意这里的所有值都是绝对时间，而我们需要的是相对时间，于是就应该在某一个时刻调用<code>times</code>获得一个初始值，在另外一个时刻调用<code>times</code>获得一个最终值，其差即为我们所需。</p>
<p>所有由此函数返回的<code>clock_t</code>值都用<code>_SC_CLK_CTK</code>（由<code>sysconf</code>函数返回的每秒时钟滴答数）转换成秒数。</p>
<p>一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(clock_t, <span class="keyword">struct</span> tms *, <span class="keyword">struct</span> tms *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;argc; i++)</span><br><span class="line">	do_cmd(argv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"normal termination, exit status = %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"abnormal termination, signal number = %d%s\n"</span>, WTERMSIG(status),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">	       WCOREDUMP(status) ? <span class="string">"(core file generated)"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span>	</span></span><br><span class="line">	<span class="string">""</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child stopped, signal number = %d\n"</span>, WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">  struct tms &#123;</span><br><span class="line">      clock_t tms_utime;    // user CPU time</span><br><span class="line">      clock_t tms_stime;    // system CPU time</span><br><span class="line">      clock_t tms_cutime;   // user CPU time, terminated children</span><br><span class="line">      clock_t tms_sutime;   // system CPU time, terminated children</span><br><span class="line">  &#125;</span><br><span class="line">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(clock_t real, <span class="keyword">struct</span> tms *tmsstart, <span class="keyword">struct</span> tms *tmsend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> clktck = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (clktck == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((clktck = sysconf(_SC_CLK_TCK)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"sysconf error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  real:  %7.2f\n"</span>, real / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  user:  %7.2f\n"</span>, (tmsend -&gt; tms_utime - tmsstart -&gt; tms_utime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  sys:  %7.2f\n"</span>, (tmsend -&gt; tms_stime - tmsstart -&gt; tms_stime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  child user:  %7.2f\n"</span>, (tmsend -&gt; tms_cutime - tmsstart -&gt; tms_cutime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  child sys:  %7.2f\n"</span>, (tmsend -&gt; tms_cstime - tmsstart -&gt; tms_cstime) / (<span class="keyword">double</span>)clktck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> tms tmsstart, tmsend;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nCommand: %s\n"</span>, cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((start = times(&amp;tmsstart)) == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"times error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status = system(cmd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"system() error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((end = times(&amp;tmsend)) == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"times error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_times(end - start, &amp;tmsstart, &amp;tmsend);</span><br><span class="line">    pr_exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入与输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &#34;sleep 5&#34; &#34;date&#34; &#34;man bash &#62; /dev/null&#34;&#10;&#10;Command: sleep 5&#10;  real:     5.02&#10;  user:     0.00&#10;  sys:     0.00&#10;  child user:     0.00&#10;  child sys:     0.00&#10;normal termination, exit status = 0&#10;&#10;Command: date&#10;Thu Oct 20 23:58:06 CST 2016&#10;  real:     0.02&#10;  user:     0.00&#10;  sys:     0.00&#10;  child user:     0.00&#10;  child sys:     0.00&#10;normal termination, exit status = 0&#10;&#10;Command: man bash &#62; /dev/null&#10;  real:     0.24&#10;  user:     0.00&#10;  sys:     0.00&#10;  child user:     0.28&#10;  child sys:     0.07&#10;normal termination, exit status = 0</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/12/libev源码浅析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/12/libev源码浅析/" itemprop="url">
                  libev源码浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/12/libev源码浅析/" class="leancloud_visitors" data-flag-title="libev源码浅析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="libev"><a href="#libev" class="headerlink" title="libev"></a>libev</h1><p><code>libev</code>是一个高效的异步I/O库，采用了事件循环模型。用户向<code>libev</code>注册感兴趣的事件，如文件描述符可读等，当事件发生时，用户注册事件时的回调被调用。</p>
<p><code>libev</code>支持的事件有：</p>
<ol>
<li>文件描述符事件（描述符可读、可写），<code>ev_io</code></li>
<li>Linux的<code>inotify</code>接口，<code>ev_stat</code></li>
<li>信号事件，<code>ev_signal</code></li>
<li>定时事件，<code>ev_timer</code></li>
<li>周期事件，<code>ev_periodic</code></li>
<li>进程状态变化，<code>ev_child</code></li>
<li>事件循环自身的事件，<code>ev_idle</code>，<code>ev_prepare</code>和<code>ev_check</code></li>
</ol>
<h1 id="u4E00_u4E2A_u4F8B_u5B50"><a href="#u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="一个例子"></a>一个例子</h1><p>我们先看一个很简单的例子，然后用这个例子的执行流程去分析<code>libev</code>源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ev_io stdin_watcher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stdin_cb</span><span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (revents &amp; EV_READ) &#123;</span><br><span class="line">	n = read(w -&gt; fd, buf, <span class="number">128</span>);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"End of File\n"</span>);</span><br><span class="line">	    ev_io_stop(EV_A_ w);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"read: %s\n"</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> ev_loop *loop = EV_DEFAULT;</span><br><span class="line"></span><br><span class="line">    ev_io_init(&amp;stdin_watcher, stdin_cb, <span class="number">0</span>, EV_READ);</span><br><span class="line">    ev_io_start(loop, &amp;stdin_watcher);</span><br><span class="line"></span><br><span class="line">    ev_run(loop, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>libev</code>中一个事件有一个<code>watcher</code>表示，一个<code>watcher</code>的类型的格式为<code>ev_TYPE</code>。</p>
<p>每一个<code>watcher</code>有对应的初始化函数<code>ev_TYPE_init</code>，以<code>ev_io</code>为例，它的初始化函数原型为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ev_io_init(ev_io * w, void (*cb)(EV_P int revents), int fd, int events);</span><br><span class="line"></span><br><span class="line">#define EV_P struct ev_loop *loop,</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>注意的一点是，在<code>libev</code>的实现中，<code>ev_io_init</code>实际上是一个宏，但是我们把它理解成一个函数其实区别并不大。</p>
<p><code>ev_io_init</code>内部调用了两个函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ev_init(ev_watcher *w, void (*cb)(EV_P int revents));</span><br><span class="line"></span><br><span class="line">void ev_io_set(ev_io *w, int fd, int events);</span><br></pre></td></tr></table></figure>
<p>在初始化之后就调用<code>ev_io_start</code>在loop中注册事件，最后调用<code>ev_run</code>运行loop。</p>
<p>当标准输入可读时，我们注册的回调模块<code>stdin_watcher</code>会被调用，这时候我们就可以读取标准输入的数据，如果读到了<code>EOF</code>，那么就调用<code>ev_io_stop</code>停止这个监听事件。</p>
<h1 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h1><h3 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h3><p>以下的代码都是以2.0版本为准的。<br>在分析源码之前，我们先来看看<code>libev</code>中几个关键的数据结构。</p>
<h4 id="EV_WATCHER"><a href="#EV_WATCHER" class="headerlink" title="EV_WATCHER"></a>EV_WATCHER</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_watcher &#123;</span><br><span class="line">  <span class="keyword">int</span> active;</span><br><span class="line">  <span class="keyword">int</span> pending;</span><br><span class="line">  <span class="keyword">int</span> priority;</span><br><span class="line">  EV_COMMON				<span class="comment">/* void *data */</span></span><br><span class="line">  <span class="keyword">void</span> (*cb)(EV_P <span class="keyword">struct</span> ev_TYPE *w, <span class="keyword">int</span> revents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ev_watcher</code>相当于所有watcher的父类，它含有所有watcher的通用数据。拿<code>ev_io</code>来说，它的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_io &#123;</span><br><span class="line">  <span class="keyword">int</span> active;</span><br><span class="line">  <span class="keyword">int</span> pending;</span><br><span class="line">  <span class="keyword">int</span> priority;</span><br><span class="line">  <span class="function">EV_COMMON</span><br><span class="line">  <span class="title">void</span> <span class="params">(*cb)</span><span class="params">(EV_P <span class="keyword">struct</span> ev_TYPE *w <span class="keyword">int</span> revents)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> ev_watcher_list *next;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个<code>ev_io</code>指针可以转换成一个<code>ev_watcher</code>指针，其他watcher类型也可以这么操作，所以<code>ev_watcher</code>相当于所有watcher的父类。</p>
<h4 id="ANFD"><a href="#ANFD" class="headerlink" title="ANFD"></a>ANFD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANFD &#123;</span><br><span class="line">  WL head;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> events;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> reify;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ev_watcher_list* WL;</span><br></pre></td></tr></table></figure>
<p><code>ANFD</code>表示一个文件描述符对应的事件。一个文件描述符可以有多个watcher，它们以链表的形式被组织起来，<code>head</code>即是链表的头。在<code>ev_loop</code>结构中，有一个<code>anfds</code>数组，每一个数组元素即数组下标对应的文件描述符的<code>ANFD</code>。</p>
<h4 id="ANPENDING"><a href="#ANPENDING" class="headerlink" title="ANPENDING"></a>ANPENDING</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANPENDING &#123;</span><br><span class="line">  W w;</span><br><span class="line">  <span class="keyword">int</span> events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ev_watcher* W;</span><br></pre></td></tr></table></figure>
<p>一个<code>ANPENDING</code>即一个待处理的事件。在<code>ev_loop</code>中，待处理的事件的组织形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pri_max |----|     |----|----|----|----|----|&#10;        |  --|---&#62; |    |    |    |    |    |&#10;   .    |----|     |----|----|----|----|----|&#10;   .    |    |&#9;&#9;&#9;ANPENDINGS&#10;   .    |----|    &#10;        |    |&#10;        |----|&#10;        |    |&#9;&#9;pendings[w-&#62;priority][w-&#62;pending]&#21363;&#23545;&#24212;watcher&#30340;ANPENDING&#10;        |----|&#10;        |    |&#10;        |----|&#10;        |    |&#10;pri_min |----|</span><br></pre></td></tr></table></figure>
<p><code>ev_loop</code>中每一个<code>ANPENDING</code>都有一个优先级，高优先级的事件在一个事件循环中首先被处理，但是低优先级事件也一定会被执行，只不过执行被延后了而已。</p>
<h4 id="EV_LOOP"><a href="#EV_LOOP" class="headerlink" title="EV_LOOP"></a>EV_LOOP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_loop &#123;</span><br><span class="line">  ev_tstamp ev_rt_now;</span><br><span class="line">  <span class="keyword">int</span> activent;</span><br><span class="line">  <span class="keyword">int</span> loop_count;</span><br><span class="line">  <span class="keyword">void</span> (*backend_modify)(EV_P <span class="keyword">int</span> fd, <span class="keyword">int</span> oev, <span class="keyword">int</span> nev);</span><br><span class="line">  <span class="keyword">void</span> (*backend_poll)(EV_P ev_tstamp timeout);</span><br><span class="line">  <span class="keyword">int</span> backend_fd;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> epoll_event *epoll_events;			<span class="comment">/* epoll for example */</span></span><br><span class="line">  <span class="keyword">int</span> epoll_eventmax;</span><br><span class="line">  </span><br><span class="line">  ANFD *anfds;</span><br><span class="line">  <span class="keyword">int</span> anfdmax;</span><br><span class="line">  </span><br><span class="line">  ANPENDING *pendings[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> pendingmax[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> pendingcnt[NUMPRI];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> *fdchanges;</span><br><span class="line">  <span class="keyword">int</span> fdchangemax;</span><br><span class="line">  <span class="keyword">int</span> fdchangecnt;</span><br><span class="line">  </span><br><span class="line">  WT *timers;</span><br><span class="line">  <span class="keyword">int</span> timermax;</span><br><span class="line">  <span class="keyword">int</span> timercnt;</span><br><span class="line">  </span><br><span class="line">  WT *periodics;</span><br><span class="line">  <span class="keyword">int</span> periodicmax;</span><br><span class="line">  <span class="keyword">int</span> periodiccnt;</span><br><span class="line">  </span><br><span class="line">  ev_idle **idles[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> idlemax[NUMPRI];</span><br><span class="line">  <span class="keyword">int</span> idlecnt[NUMPRI];</span><br><span class="line">  </span><br><span class="line">  ev_prepare **prepares;</span><br><span class="line">  <span class="keyword">int</span> preparemax;</span><br><span class="line">  <span class="keyword">int</span> preparecnt;</span><br><span class="line">  </span><br><span class="line">  ev_check **checks;</span><br><span class="line">  <span class="keyword">int</span> checkmax;</span><br><span class="line">  <span class="keyword">int</span> checkcnt;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ev_loop</code>显然是<code>libev</code>中最重要的结构，这里只列出部分元素的含义，其余部分等在分析对应源码时再作解释。</p>
<ul>
<li><code>ev_rt_now</code>：用于记录<code>ev_loop</code>的现在时间。<code>libev</code>中的计时器是基于真实时间的，如果你注册了一个超时事件，事件在一小时之后发生，之后你把系统时间设置成去年的某个事件，注册的事件也会在大约一小时后发生。</li>
<li><code>activent</code>：watcher必须保持<code>ev_loop</code>存活，这样每当一个事件发生时，watcher的回调函数才能被执行。为了保持<code>ev_loop</code>存活，watcher必须调用<code>ev_ref</code> 增加<code>activent</code>的个数，若<code>activent</code>值为0，那么这一次事件循环之后，<code>ev_loop</code>就被摧毁了。</li>
<li><code>loop_count</code>：记录了<code>ev_loop</code>事件迭代的次数</li>
<li><code>backend_modify</code>：<code>ev_loop</code>添加或修改事件监听的接口，依平台而定。<code>libev</code>支持的接口有<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
<li>port</li>
</ul>
</li>
<li><code>backend_poll</code>：<code>ev_loop</code>调用平台相关接口监听相关事件的接口。</li>
<li><code>backend_fd</code>：以<code>epoll</code>为例，其值为我们调用<code>epoll_create</code>接口创建的文件句柄。</li>
</ul>
<h3 id="ev_io"><a href="#ev_io" class="headerlink" title="ev_io"></a>ev_io</h3><p>首先来看一下<code>ev_io</code>的执行流程</p>
<h4 id="ev_io_start"><a href="#ev_io_start" class="headerlink" title="ev_io_start"></a>ev_io_start</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> noinline</span><br><span class="line"><span class="title">ev_io_start</span> <span class="params">(EV_P_ ev_io *w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = w-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expect_false (ev_is_active (w)))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  assert ((<span class="string">"ev_io_start called with negative fd"</span>, fd &gt;= <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  ev_start (EV_A_ (W)w, <span class="number">1</span>);</span><br><span class="line">  array_needsize (ANFD, anfds, anfdmax, fd + <span class="number">1</span>, anfds_init);</span><br><span class="line">  wlist_add (&amp;anfds[fd].head, (WL)w);</span><br><span class="line"></span><br><span class="line">  fd_change (EV_A_ fd, w-&gt;events &amp; EV_IOFDSET | <span class="number">1</span>);</span><br><span class="line">  w-&gt;events &amp;= ~EV_IOFDSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_speed</span><br><span class="line"><span class="title">ev_start</span> <span class="params">(EV_P_ W w, <span class="keyword">int</span> active)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  pri_adjust (EV_A_ w);</span><br><span class="line">  w-&gt;active = active;</span><br><span class="line">  ev_ref (EV_A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">wlist_add</span> <span class="params">(WL *head, WL elem)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  elem-&gt;next = *head;</span><br><span class="line">  *head = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">fd_change</span> <span class="params">(EV_P_ <span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> reify = anfds [fd].reify;</span><br><span class="line">  anfds [fd].reify |= flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expect_true (!reify))</span><br><span class="line">    &#123;</span><br><span class="line">      ++fdchangecnt;</span><br><span class="line">      array_needsize (<span class="keyword">int</span>, fdchanges, fdchangemax, fdchangecnt, EMPTY2);</span><br><span class="line">      fdchanges [fdchangecnt - <span class="number">1</span>] = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤为：</p>
<ol>
<li>执行<code>ev_start</code>，调整watcher的优先级，设置watcher的<code>active</code>标志同增加<code>ev_loop</code>的<code>activent</code>。</li>
<li>在文件描述符对应的watcher链表中插入该<code>ev_io</code>。</li>
<li>调用<code>fd_change</code>，它增加<code>fdchangecnt</code>的个数，同时记录发生变化的文件描述符，以便在事件循环的时候处理它。</li>
</ol>
<h4 id="ev_loop"><a href="#ev_loop" class="headerlink" title="ev_loop"></a>ev_loop</h4><p>在最新版本中<code>ev_loop</code>对应的函数为<code>ev_run</code>，由于我看的是2.0版本的，就用<code>ev_loop</code>来说明了。</p>
<h5 id="ev_loop-1"><a href="#ev_loop-1" class="headerlink" title="ev_loop"></a>ev_loop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">ev_loop</span> <span class="params">(EV_P_ <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  loop_done = flags &amp; (EVLOOP_ONESHOT | EVLOOP_NONBLOCK)</span><br><span class="line">            ? EVUNLOOP_ONE</span><br><span class="line">            : EVUNLOOP_CANCEL;</span><br><span class="line"></span><br><span class="line">  call_pending (EV_A); <span class="comment">/* in case we recurse, ensure ordering stays nice and clean */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> _WIN32</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (curpid)) <span class="comment">/* penalise the forking check even more */</span></span><br><span class="line">        <span class="keyword">if</span> (expect_false (getpid () != curpid))</span><br><span class="line">          &#123;</span><br><span class="line">            curpid = getpid ();</span><br><span class="line">            postfork = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_FORK_ENABLE</span></span><br><span class="line">      <span class="comment">/* we might have forked, so queue fork handlers */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (postfork))</span><br><span class="line">        <span class="keyword">if</span> (forkcnt)</span><br><span class="line">          &#123;</span><br><span class="line">            queue_events (EV_A_ (W *)forks, forkcnt, EV_FORK);</span><br><span class="line">            call_pending (EV_A);</span><br><span class="line">          &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue prepare watchers (and execute them) */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (preparecnt))</span><br><span class="line">        &#123;</span><br><span class="line">          queue_events (EV_A_ (W *)prepares, preparecnt, EV_PREPARE);</span><br><span class="line">          call_pending (EV_A);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expect_false (!activecnt))		<span class="comment">/* A */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* we might have forked, so reify kernel state if necessary */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (postfork))</span><br><span class="line">        loop_fork (EV_A);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* update fd-related kernel structures */</span></span><br><span class="line">      fd_reify (EV_A);						<span class="comment">/* B */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* calculate blocking time */</span></span><br><span class="line">      &#123;</span><br><span class="line">        ev_tstamp block;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expect_false (flags &amp; EVLOOP_NONBLOCK || idleall || !activecnt))</span><br><span class="line">          block = <span class="number">0.</span>; <span class="comment">/* do not block at all */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* update time to cancel out callback processing overhead */</span></span><br><span class="line">            time_update (EV_A_ <span class="number">1e100</span>);</span><br><span class="line"></span><br><span class="line">            block = MAX_BLOCKTIME;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timercnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)timers [<span class="number">0</span>])-&gt;at - mn_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">            <span class="keyword">if</span> (periodiccnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)periodics [<span class="number">0</span>])-&gt;at - ev_rt_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expect_false (block &lt; <span class="number">0.</span>)) block = <span class="number">0.</span>;</span><br><span class="line">          &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/* C */</span></span><br><span class="line">        ++loop_count;</span><br><span class="line">        backend_poll (EV_A_ block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update ev_rt_now, do magic */</span></span><br><span class="line">        time_update (EV_A_ block);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue pending timers and reschedule them */</span></span><br><span class="line">      timers_reify (EV_A); <span class="comment">/* relative timers called last */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">      periodics_reify (EV_A); <span class="comment">/* absolute timers called first */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_IDLE_ENABLE</span></span><br><span class="line">      <span class="comment">/* queue idle watchers unless other events are pending */</span></span><br><span class="line">      idle_reify (EV_A);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue check watchers, to be executed first */</span></span><br><span class="line">      <span class="keyword">if</span> (expect_false (checkcnt))</span><br><span class="line">        queue_events (EV_A_ (W *)checks, checkcnt, EV_CHECK);</span><br><span class="line">	</span><br><span class="line">      call_pending (EV_A);				<span class="comment">/* E */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (expect_true (activecnt &amp;&amp; !loop_done));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop_done == EVUNLOOP_ONE)</span><br><span class="line">    loop_done = EVUNLOOP_CANCEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fd_reify"><a href="#fd_reify" class="headerlink" title="fd_reify"></a>fd_reify</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">fd_reify</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdchangecnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> fd = fdchanges [i];</span><br><span class="line">      ANFD *anfd = anfds + fd;</span><br><span class="line">      ev_io *w;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span> events = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (w = (ev_io *)anfd-&gt;head; w; w = (ev_io *)((WL)w)-&gt;next)</span><br><span class="line">        events |= (<span class="keyword">unsigned</span> <span class="keyword">char</span>)w-&gt;events;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_SELECT_IS_WINSOCKET</span></span><br><span class="line">      <span class="keyword">if</span> (events)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span> argp;</span><br><span class="line">          anfd-&gt;handle = _get_osfhandle (fd);</span><br><span class="line">          assert ((<span class="string">"libev only supports socket fds in this configuration"</span>, ioctlsocket (anfd-&gt;handle, FIONREAD, &amp;argp) == <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> o_events = anfd-&gt;events;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> o_reify  = anfd-&gt;reify;</span><br><span class="line"></span><br><span class="line">        anfd-&gt;reify  = <span class="number">0</span>;</span><br><span class="line">        anfd-&gt;events = events;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o_events != events || o_reify &amp; EV_IOFDSET)</span><br><span class="line">          backend_modify (EV_A_ fd, o_events, events);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fdchangecnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="epoll_poll"><a href="#epoll_poll" class="headerlink" title="epoll_poll"></a>epoll_poll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">epoll_poll</span> <span class="params">(EV_P_ ev_tstamp timeout)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* D */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax, (<span class="keyword">int</span>)<span class="built_in">ceil</span> (timeout * <span class="number">1000.</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expect_false (eventcnt &lt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        syserr (<span class="string">"(libev) epoll_wait"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eventcnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> epoll_event *ev = epoll_events + i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> fd   = ev-&gt;data.u64;</span><br><span class="line">      <span class="keyword">int</span> got  = (ev-&gt;events &amp; (EPOLLOUT | EPOLLERR | EPOLLHUP) ? EV_WRITE : <span class="number">0</span>)</span><br><span class="line">               | (ev-&gt;events &amp; (EPOLLIN  | EPOLLERR | EPOLLHUP) ? EV_READ  : <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">int</span> want = anfds [fd].events;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expect_false (got &amp; ~want))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* we received an event but are not interested in it, try mod or del */</span></span><br><span class="line">          ev-&gt;events = (want &amp; EV_READ  ? EPOLLIN  : <span class="number">0</span>)</span><br><span class="line">                     | (want &amp; EV_WRITE ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          epoll_ctl (backend_fd, want ? EPOLL_CTL_MOD : EPOLL_CTL_DEL, fd, ev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      fd_event (EV_A_ fd, got);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* if the receive array was full, increase its size */</span></span><br><span class="line">  <span class="keyword">if</span> (expect_false (eventcnt == epoll_eventmax))</span><br><span class="line">    &#123;</span><br><span class="line">      ev_free (epoll_events);</span><br><span class="line">      epoll_eventmax = array_nextsize (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> epoll_event), epoll_eventmax, epoll_eventmax + <span class="number">1</span>);</span><br><span class="line">      epoll_events = (<span class="keyword">struct</span> epoll_event *)ev_malloc (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> epoll_event) * epoll_eventmax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="call_pending"><a href="#call_pending" class="headerlink" title="call_pending"></a>call_pending</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_speed</span><br><span class="line"><span class="title">call_pending</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pri;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (pri = NUMPRI; pri--; )</span><br><span class="line">    <span class="keyword">while</span> (pendingcnt [pri])</span><br><span class="line">      &#123;</span><br><span class="line">        ANPENDING *p = pendings [pri] + --pendingcnt [pri];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expect_true (p-&gt;w))</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/*assert (("non-pending watcher on pending list", p-&gt;w-&gt;pending));*/</span></span><br><span class="line"></span><br><span class="line">            p-&gt;w-&gt;pending = <span class="number">0</span>;</span><br><span class="line">            EV_CB_INVOKE (p-&gt;w, p-&gt;events);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体部分就在<code>do {} while</code>这个循环里面。</p>
<p>我们先略过不和<code>ev_io</code>相关的部分，只看代码中标注（[A-E]）位置对应的部分：</p>
<ul>
<li><code>A</code>：检查<code>activent</code>值是否为0，若是，那么loop退出事件循环</li>
<li><code>B</code>：调用<code>fd_reify</code>函数，该函数遍历<code>fdchanges</code>数组，对于每一个描述符，如果其对应的事件有改变或者新增加的描述符，那么就调用<code>backend_modify</code>修改或添加文件描述符的事件。</li>
<li><code>C</code>：增加事件循环的迭代次数，然后调用<code>backend_poll</code>调用相关平台的接口监听文件描述符事件。</li>
<li><code>D</code>：以<code>epoll</code>为例，<code>backend_poll</code>的实现为<code>epoll_poll</code>。<code>epoll_poll</code>调用<code>epoll_wait</code>，发生的事件被存放在<code>epoll_events</code>数组中，对于一个事件，得到的事件不是我们想要的事件，那么就修改或删除文件描述符对应的监听事件。然后调用<code>fd_event</code>函数，把得到文件描述符事件加到<code>ev_loop</code>的对应的<code>pendings</code>列表中。在<code>fd_event</code>之后，如果发现<code>epoll_eventmax == eventcnt</code>，那么就增大<code>epoll_events</code>数组元素的个数，以便下一次能够接收更多发生的文件描述符事件。</li>
<li><code>E</code>：调用<code>call_pending</code>函数:<ol>
<li>按照优先级从大到小，遍历<code>pendings</code>数组</li>
<li>如果对应的<code>pendingcnt[pri]</code>值大于0，即对应优先级有事件待处理，依次去对应<code>ANPENDING</code>列表的元素</li>
<li>对取到的<code>ANPENDING</code>，用<code>EV_CB_INVOKE</code>宏调用其对应watcher的回调函数。</li>
</ol>
</li>
</ul>
<h4 id="ev_io_stop"><a href="#ev_io_stop" class="headerlink" title="ev_io_stop"></a>ev_io_stop</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> noinline</span><br><span class="line"><span class="title">ev_io_stop</span> <span class="params">(EV_P_ ev_io *w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* A */</span></span><br><span class="line">  clear_pending (EV_A_ (W)w);</span><br><span class="line">  <span class="keyword">if</span> (expect_false (!ev_is_active (w)))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  assert ((<span class="string">"ev_io_start called with illegal fd (must stay constant after start!)"</span>, w-&gt;fd &gt;= <span class="number">0</span> &amp;&amp; w-&gt;fd &lt; anfdmax));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* B */</span></span><br><span class="line">  wlist_del (&amp;anfds[w-&gt;fd].head, (WL)w);</span><br><span class="line">  <span class="comment">/* C */</span></span><br><span class="line">  ev_stop (EV_A_ (W)w);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* D */</span></span><br><span class="line">  fd_change (EV_A_ w-&gt;fd, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="clear_pending"><a href="#clear_pending" class="headerlink" title="clear_pending"></a>clear_pending</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_speed</span><br><span class="line"><span class="title">clear_pending</span> <span class="params">(EV_P_ W w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w-&gt;pending)</span><br><span class="line">    &#123;</span><br><span class="line">      pendings [ABSPRI (w)][w-&gt;pending - <span class="number">1</span>].w = <span class="number">0</span>;</span><br><span class="line">      w-&gt;pending = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ev_stop"><a href="#ev_stop" class="headerlink" title="ev_stop"></a>ev_stop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">ev_stop</span> <span class="params">(EV_P_ W w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ev_unref (EV_A);</span><br><span class="line">  w-&gt;active = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A</code>：从<code>pendings</code>列表中删除对应的watcher</li>
<li><code>B</code>：从文件描述符对应的watcher链表<code>anfds[w-&gt;fd]</code>中删除将被停止的watcher。</li>
<li><code>C</code>：调用<code>ev_stop</code>，减少<code>ev_loop</code>中<code>activent</code>的个数（通过<code>ev_unref</code>实现），讲watcher的<code>active</code>标志置为０。</li>
<li><code>D</code>：调用<code>fd_change</code>函数修改对应的<code>fdchanges</code>数组和<code>fdchangecnt</code>变量，以便在下一次事件循环中修改文件描述符的监听事件。如果文件描述符没有任何监听事件，那么在文件描述符的epoll事件会在<code>epoll_poll</code>函数中被删除。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expect_false (got &amp; ~want))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* we received an event but are not interested in it, try mod or del */</span></span><br><span class="line">        ev-&gt;events = (want &amp; EV_READ  ? EPOLLIN  : <span class="number">0</span>)</span><br><span class="line">                     | (want &amp; EV_WRITE ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        epoll_ctl (backend_fd, want ? EPOLL_CTL_MOD : EPOLL_CTL_DEL, fd, ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ev_timer__26amp_3B_ev_periodic"><a href="#ev_timer__26amp_3B_ev_periodic" class="headerlink" title="ev_timer &amp; ev_periodic"></a>ev_timer &amp; ev_periodic</h3><p><code>ev_timer</code>和<code>ev_periodic</code>都可以用来设置超时和周期事件，不同的是，<code>ev_periodic</code>可以设置一个回调函数，在每一次周期完成后这个回调函数被调用并返回一个时间节点，该节点是下一次事件被触发的时间。</p>
<p><code>ev_loop</code>结构内有两个元素：</p>
<ul>
<li>timers</li>
<li>periodics</li>
</ul>
<p><code>timer</code>和<code>periodic</code>的结构分别为：</p>
<h5 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_timer &#123;</span><br><span class="line">  EV_WATCHER(ev_timer)</span><br><span class="line">  ev_tstamp at;</span><br><span class="line">  ev_tstamp repeat;			<span class="comment">/* 多少时间后重复执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="periodic"><a href="#periodic" class="headerlink" title="periodic"></a>periodic</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_periodic &#123;</span><br><span class="line">  EV_WATCHER(ev_periodic)</span><br><span class="line">  ev_tstamp offset;</span><br><span class="line">  ev_tstamp interval;</span><br><span class="line">  ev_tstamp (*reschedule_cb)(<span class="keyword">struct</span> ev_periodic *w, ev_tstamp now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们分别存储了在<code>ev_loop</code>中注册的所有<code>ev_timer</code>和<code>ev_periodic</code>。它们都以最小堆的形式被组织，堆顶是离现在最近的timer事件。每一次事件循环，在调用<code>backend_poll</code>之前，首先取两个堆顶的元素，取时间较小的那个作为此次<code>backend_poll</code>的超时事件。在<code>backend_poll</code>返回之后调用<code>timers_reify</code>和<code>periodics_reify</code>调整堆，同时把已经发生的超时和定时事件加入到<code>pendings</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (expect_false (flags &amp; EVLOOP_NONBLOCK || idleall || !activecnt))</span><br><span class="line">          block = <span class="number">0.</span>; <span class="comment">/* do not block at all */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* update time to cancel out callback processing overhead */</span></span><br><span class="line">            time_update (EV_A_ <span class="number">1e100</span>);</span><br><span class="line"></span><br><span class="line">            block = MAX_BLOCKTIME;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timercnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)timers [<span class="number">0</span>])-&gt;at - mn_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">            <span class="keyword">if</span> (periodiccnt)</span><br><span class="line">              &#123;</span><br><span class="line">                ev_tstamp to = ((WT)periodics [<span class="number">0</span>])-&gt;at - ev_rt_now + backend_fudge;</span><br><span class="line">                <span class="keyword">if</span> (block &gt; to) block = to;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expect_false (block &lt; <span class="number">0.</span>)) block = <span class="number">0.</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        ++loop_count;</span><br><span class="line">        backend_poll (EV_A_ block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update ev_rt_now, do magic */</span></span><br><span class="line">        time_update (EV_A_ block);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* queue pending timers and reschedule them */</span></span><br><span class="line">      timers_reify (EV_A); <span class="comment">/* relative timers called last */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> EV_PERIODIC_ENABLE</span></span><br><span class="line">      periodics_reify (EV_A); <span class="comment">/* absolute timers called first */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>time_update</code>：主要用于更新<code>ev_loop</code>的当前时间。</li>
<li><code>backend_fudge</code>：时间误差变量</li>
</ul>
<p><code>time_reify</code>和<code>periodic_reify</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">timers_reify</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (timercnt &amp;&amp; ((WT)timers [<span class="number">0</span>])-&gt;at &lt;= mn_now)</span><br><span class="line">    &#123;</span><br><span class="line">      ev_timer *w = (ev_timer *)timers [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*assert (("inactive timer on timer heap detected", ev_is_active (w)));*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* first reschedule or stop timer */</span></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;repeat)</span><br><span class="line">        &#123;</span><br><span class="line">          assert ((<span class="string">"negative ev_timer repeat value found while processing timers"</span>, w-&gt;repeat &gt; <span class="number">0.</span>));</span><br><span class="line"></span><br><span class="line">          ((WT)w)-&gt;at += w-&gt;repeat;</span><br><span class="line">          <span class="keyword">if</span> (((WT)w)-&gt;at &lt; mn_now)</span><br><span class="line">            ((WT)w)-&gt;at = mn_now;</span><br><span class="line"></span><br><span class="line">          downheap (timers, timercnt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ev_timer_stop (EV_A_ w); <span class="comment">/* nonrepeating: stop timer */</span></span><br><span class="line"></span><br><span class="line">      ev_feed_event (EV_A_ (W)w, EV_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> inline_size</span><br><span class="line"><span class="title">periodics_reify</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* A */</span></span><br><span class="line">  <span class="keyword">while</span> (periodiccnt &amp;&amp; ((WT)periodics [<span class="number">0</span>])-&gt;at &lt;= ev_rt_now)</span><br><span class="line">    &#123;</span><br><span class="line">      ev_periodic *w = (ev_periodic *)periodics [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*assert (("inactive timer on periodic heap detected", ev_is_active (w)));*/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* first reschedule or stop timer */</span></span><br><span class="line">    <span class="comment">/* B */</span></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;reschedule_cb)</span><br><span class="line">        &#123;</span><br><span class="line">          ((WT)w)-&gt;at = w-&gt;reschedule_cb (w, ev_rt_now + TIME_EPSILON);</span><br><span class="line">          assert ((<span class="string">"ev_periodic reschedule callback returned time in the past"</span>, ((WT)w)-&gt;at &gt; ev_rt_now));</span><br><span class="line">          downheap (periodics, periodiccnt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (w-&gt;interval)</span><br><span class="line">        &#123;</span><br><span class="line">          ((WT)w)-&gt;at = w-&gt;offset + <span class="built_in">ceil</span> ((ev_rt_now - w-&gt;offset) / w-&gt;interval) * w-&gt;interval;</span><br><span class="line">          <span class="keyword">if</span> (((WT)w)-&gt;at - ev_rt_now &lt;= TIME_EPSILON) ((WT)w)-&gt;at += w-&gt;interval;</span><br><span class="line">          assert ((<span class="string">"ev_periodic timeout in the past detected while processing timers, negative interval?"</span>, ((WT)w)-&gt;at &gt; ev_rt_now));</span><br><span class="line">          downheap (periodics, periodiccnt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ev_periodic_stop (EV_A_ w); <span class="comment">/* nonrepeating: stop timer */</span></span><br><span class="line"></span><br><span class="line">      ev_feed_event (EV_A_ (W)w, EV_PERIODIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>periodics_reify</code>例子（<code>timers_reify</code>类似）：</p>
<ol>
<li>如果堆顶的时间比现在的事件小，那么取堆顶，否则函数返回</li>
<li>如果是周期事件，即<code>reschedule_cb</code>不为空或者<code>interval</code>不为0，那么计算出下一次事件触发的事件，调整堆，否则停止这个timer事件。</li>
<li>把这一次触发的事件加入到<code>pendings</code>中，等待<code>call_pending</code>被调用而触发回调函数。</li>
</ol>
<h3 id="ev_signal"><a href="#ev_signal" class="headerlink" title="ev_signal"></a>ev_signal</h3><p><code>libev</code>加入了对信号事件的支持。当一个信号发生时，回调函数不会像在UNIX系统中一样被立刻调用，而是在下一个事件循环中被处理。</p>
<p>先看看信号事件在<code>libev</code>中的组织形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">     |--------|     |----|----|----|----|----|&#10;     | head   |---&#62; |    |    |    |    |    |&#10;.    |        |     |----|----|----|----|----|&#10;.    | gotsig |&#9;&#9;&#9;EV_WATCHERS&#10;.    |--------|    &#10;     |        |&#10;     |        |&#10;     |        |&#9;&#10;     |--------|&#10;     |        |&#10;     |        |&#10;     |        |&#10;     |--------|</span><br></pre></td></tr></table></figure>
<p>相关的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ANSIG &#123;</span><br><span class="line">  WL *head;</span><br><span class="line">  <span class="keyword">sig_atomic_t</span> <span class="keyword">volatile</span> gotsig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当某一个信号被触发时，信号对应的<code>WL</code>中所有的回调函数都会被依次执行。</p>
<p><code>libev</code>利用管道实现了异步信号处理。一个loop在调用<code>loop_init</code>初始化之后，调用<code>siginit</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> noinline</span><br><span class="line"><span class="title">siginit</span> <span class="params">(EV_P)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  fd_intern (sigpipe [<span class="number">0</span>]);</span><br><span class="line">  fd_intern (sigpipe [<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  ev_io_set (&amp;sigev, sigpipe [<span class="number">0</span>], EV_READ);</span><br><span class="line">  ev_io_start (EV_A_ &amp;sigev);</span><br><span class="line">  ev_unref (EV_A); <span class="comment">/* child watcher should not keep loop alive */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看<code>siginit</code>往loop中注册一个<code>ev_io</code>，用于监听管道中<code>pipe[0]</code>的读事件。</p>
<p>用户在注册一个信号事件时，调用<code>ev_signal_init</code>设置信号的回调处理，监听的信号值等。然后调用<code>ev_signal_start</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...  </span><br><span class="line">  ev_start (EV_A_ (W)w, <span class="number">1</span>);</span><br><span class="line">  wlist_add (&amp;signals [w-&gt;signum - <span class="number">1</span>].head, (WL)w);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!((WL)w)-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line">      signal (w-&gt;signum, sighandler);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">struct</span> sigaction sa;</span><br><span class="line">      sa.sa_handler = sighandler;</span><br><span class="line">      sigfillset (&amp;sa.sa_mask);</span><br><span class="line">      sa.sa_flags = SA_RESTART; <span class="comment">/* if restarting works we save one iteration */</span></span><br><span class="line">      sigaction (w-&gt;signum, &amp;sa, <span class="number">0</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>首先讲watcher加入对应信号的链表，然后如果是链头，那么说明对应的信号处理函数未被注册到内核中，于是初始化一个<code>sigaction</code>，注册对应的信号处理函数。<code>sighandler</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">sighandler</span> <span class="params">(<span class="keyword">int</span> signum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line">  signal (signum, sighandler);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  signals [signum - <span class="number">1</span>].gotsig = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!gotsig)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> old_errno = errno;</span><br><span class="line">      gotsig = <span class="number">1</span>;</span><br><span class="line">      write (sigpipe [<span class="number">1</span>], &amp;signum, <span class="number">1</span>);</span><br><span class="line">      errno = old_errno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当一个信号发生时，<code>libev</code>设置信号的对应<code>gosig</code>为1，然后往管道离写信号值，这样先前注册的读管道监视器<code>sigev</code>就被激活，其对应的回调函数被在下一个事件循环被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">sigcb</span> <span class="params">(EV_P_ ev_io *iow, <span class="keyword">int</span> revents)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> signum;</span><br><span class="line"></span><br><span class="line">  read (sigpipe [<span class="number">0</span>], &amp;revents, <span class="number">1</span>);</span><br><span class="line">  gotsig = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (signum = signalmax; signum--; )</span><br><span class="line">    <span class="keyword">if</span> (signals [signum].gotsig)</span><br><span class="line">      ev_feed_signal_event (EV_A_ signum + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这之后所有的信号事件被加入<code>pendings</code>中，当<code>call_pending</code>被调用时，信号事件的回调事件也就得到了处理。</p>
<h3 id="ev_prepare__26amp_3B_ev_check"><a href="#ev_prepare__26amp_3B_ev_check" class="headerlink" title="ev_prepare &amp; ev_check"></a>ev_prepare &amp; ev_check</h3><p><code>ev_prepare</code>和<code>ev_check</code>是<code>ev_loop</code>事件循环自身的事件。<code>ev_prepare</code>在<code>ev_loop</code>收集事件前被调用；<code>ev_check</code>在收集完事件后被调用。他们都能唤醒和休眠任意个监视器，以实现一些特定的事件循环行为。</p>
<p><code>ev_prepare</code>和<code>ev_check</code>的结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ev_TYPE &#123;</span><br><span class="line">  EV_WATCHER(TYPE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ev_stat"><a href="#ev_stat" class="headerlink" title="ev_stat"></a>ev_stat</h3><p><code>ev_stat</code>相关接口没有看，因为对<code>inotify</code>和<code>kqueue</code>接口还不是很熟悉（逃</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/08/进程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/08/进程/" itemprop="url">
                  进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/08/进程/" class="leancloud_visitors" data-flag-title="进程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u8FDB_u7A0B_u7684_u6982_u5FF5"><a href="#u8FDB_u7A0B_u7684_u6982_u5FF5" class="headerlink" title="进程的概念"></a>进程的概念</h1><p>进程是一个可执行程序的实例。而程序包含了一系列的文件信息，这些信息描述了如何在运行时创建一个进程，其所包括的内容有：</p>
<ul>
<li>二进制格式标识：用于描述可执行文件格式的元信息，内核用它来解释文件中的其他信息。Linux采用<code>ELF文件系统</code>。</li>
<li>机器语言指令</li>
<li>程序入口地址</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面常量值（如字符串）.</li>
<li>符号表及重定位表</li>
<li>共享库和动态链接库的信息</li>
<li>其他信息，用以描述如何创建进程。</li>
</ul>
<p>可以用一个程序创建许多个进程，反过来，许多进程运行的可以是同一个程序。从内核角度来说，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码以及代码所使用的变量，而内核数据结构则用于维护进程状态信息，如进程号、虚拟内存表、进程打开的文件描述符、信号传递及处理的有关信息、当前工作目录、进程资源使用及限制和其他大量信息。</p>
<p>一个进程运行时的信息可以在<code>/proc/{PID}/</code>目录下看到。</p>
<h1 id="u8FDB_u7A0B_u5185_u5B58_u5E03_u5C40"><a href="#u8FDB_u7A0B_u5185_u5B58_u5E03_u5C40" class="headerlink" title="进程内存布局"></a>进程内存布局</h1><p>每个进程所分配的内存由许多部分组成，通常称之为<code>段</code>，各个段如下：</p>
<ul>
<li>文本段：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令；同时，文本段是共享的，从而可以让一份程序代码的拷贝映射到所有共享这份代码的进程中，从而让多个进程运行同一个程序。</li>
<li>初始化数据段：包含显示初始化的全局变量和静态变量。</li>
<li>未初始化的数据段：包含了为进程显示初始化的全局变量和静态变量，程序启动之前，系统将本段内所有内存初始化为0，该段常被成为BSS段。为初始化和初始化的变量分开存放主要是由于没有必要为未初始化的变量在文件中分配存储空间，相反，可执行文件只要记录未初始化数据段的位置及其所需要的大小，知道运行时再由程序加载器来分配空间。</li>
<li>栈是一个动态增长和收缩的段，由<code>栈帧</code>组成。系统为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（即自动变量）、实参和返回值。</li>
<li>堆是可在运行时动态进行内存分配的一块区域。堆顶称为<code>program break</code>。</li>
</ul>
<p>大多数UNIX实现（包括Linux）中C语言编程环境提供了3个全局变量<code>etext</code>、<code>edata</code>、<code>end</code>，它们分别用来标识<code>文本段</code>、<code>初始化数据段</code>、<code>非初始化数据段</code>结尾处的下一个字节位置。在x86-32体系结构进程在内存中的布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#34394;&#25311;&#20869;&#23384;&#22320;&#22336;&#65288;&#20174;&#19979;&#24448;&#19978;&#22686;&#38271;&#65289;&#10;          |----------------------------------------&#10;          |&#9;     Kernel&#26144;&#23556;&#21040;&#36827;&#31243;&#34394;&#25311;&#20869;&#23384;&#65292;&#21306;&#22495;          &#10;          |      &#25552;&#20379;&#20102;&#20869;&#23384;&#31526;&#21495;&#30340;&#22320;&#22336;&#12290;&#65288;/proc/kallsyms) &#65288;&#26080;&#27861;&#20351;&#29992;&#65289;&#10;          |----------------------------------------&#10;          |&#9;&#9;argv, environ&#9;&#9;&#9;    &#10;          |----------------------------------------&#26632;&#39030;&#10;          |&#9;&#9;&#26632;&#65288;&#21521;&#19979;&#22686;&#38271;&#65289;&#10;          |----------------------------------------&#10;          |&#10;          |&#9;&#9;&#26410;&#20998;&#37197;&#30340;&#20869;&#23384;&#65288;&#26080;&#27861;&#20351;&#29992;&#65289;&#10;          |&#10;          |----------------------------------------&#31243;&#24207;&#20013;&#26029;&#10;          |     &#22534;&#65288;&#21521;&#19978;&#22686;&#38271;&#65289;&#10;          |----------------------------------------end&#10;          |     &#26410;&#21021;&#22987;&#21270;&#30340;&#25968;&#25454;&#65288;bss&#65289;&#10;          |----------------------------------------edata&#10;          |     &#21021;&#22987;&#21270;&#30340;&#25968;&#25454;&#10;          |----------------------------------------etext&#10;          |     &#25991;&#26412;&#27573;&#10;          |-----------------------------------------0x08048000&#10;          |     (&#26080;&#27861;&#20351;&#29992;)&#10;          |-----------------------------------------0x00000000</span><br></pre></td></tr></table></figure>
<p>上述布局存在于虚拟内存之中。</p>
<h1 id="u547D_u4EE4_u884C_u53C2_u6570_u548C_u73AF_u5883_u53D8_u91CF"><a href="#u547D_u4EE4_u884C_u53C2_u6570_u548C_u73AF_u5883_u53D8_u91CF" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h1><p>上一节的内存布局图中，<code>argv和eviron</code>那一部分存储了进程启动时用户输入的命令行参数和环境变量，关于命令行参数，即<code>main</code>函数的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv[%d] = %s\n"</span>, i, argv[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于环境变量，每一个进程都有与之相关联的环境变量列表，其结构式字符串数组，每一个字符串以<code>name=value</code>形式定义。新进程在创建之时，会继承其父进程的环境变量副本，这是一种原始的进程间通信方式，却颇为有用。</p>
<p>关于环境变量的几个接口和变量如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;		<span class="comment">// 全局变量，用于访问进程的环境变量，每一个以`name=value`的形式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;			<span class="comment">// 成功返回环境变量字符串，否则返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;			   <span class="comment">// 0表示公共，否则失败。`string`为`name=value`形式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clearenv</span><span class="params">()</span></span>;		<span class="comment">// 0表示成功，否则失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意以下函数不用`name=value`形式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;		<span class="comment">// 0表示成功，-1表示失败</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;		<span class="comment">// 0表示成功，-1表示失败。</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>putenv</code>不为字符串分配一个缓冲区，它仅仅改变对应的<code>environ</code>数组中的对应指针，因此<code>string</code>参数应该是一个静态或者全局变量，而不是自动变量。</p>
<p><code>setenv</code>会为字符串分配一个内存缓冲区，并将name和value的字符串复制到该缓冲区中，以此来创建一个新的环境变量。若<code>overwrite</code>值非0，那么<code>setenv</code>总是覆写原来的环境变量；否则，若环境变量已经存在，那么它不会改变。</p>
<p><code>clearenv</code>仅仅是把<code>environ</code>置为NULL，在某些时候可能会导致内存泄漏。</p>
<h3 id="u4E00_u4E2A_u4F8B_u5B50_uFF1A"><a href="#u4E00_u4E2A_u4F8B_u5B50_uFF1A" class="headerlink" title="一个例子："></a>一个例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errExit(fmt, ...) do &#123;fprintf(stderr, fmt, ##__VA_ARGS__); perror(<span class="string">""</span>); exit(-<span class="number">1</span>);&#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    clearenv();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;argc; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (putenv(argv[i]) != <span class="number">0</span>)</span><br><span class="line">	    errExit(<span class="string">"putenv: %s"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">"GREET"</span>, <span class="string">"Hello world"</span>, <span class="number">0</span>) == -<span class="number">1</span>)</span><br><span class="line">	errExit(<span class="string">"setenv"</span>);</span><br><span class="line"></span><br><span class="line">    unsetenv(<span class="string">"BYE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep=environ; *ep!=<span class="literal">NULL</span>; ep++)</span><br><span class="line">	<span class="built_in">puts</span>(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out G=&#34;HAGA&#34;&#10;G=HAGA&#10;GREET=Hello world&#10;&#10;ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out G=&#34;HAGA&#34; GREET=&#34;Hello&#34;&#10;G=HAGA&#10;GREET=Hello</span><br></pre></td></tr></table></figure>
<h1 id="u975E_u5C40_u90E8_u8DF3_u8F6C"><a href="#u975E_u5C40_u90E8_u8DF3_u8F6C" class="headerlink" title="非局部跳转"></a>非局部跳转</h1><p>C语言中的<code>goto</code>语句允许我们进行语句跳转，但是这仅仅局限在同一个函数中。虽然跳转会让我们的代码变得难以维护，看着就头大，但是有时候有这样一个语句还是能解决很大的问题的，前提是不要滥用。为了能够解决非局部跳转的问题，UNIX系统提供了两个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjump</span><span class="params">(jump_buf env)</span></span>;		<span class="comment">// 0表示初始化操作，非0时返回的是`longjmp`设定的`val`值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jump_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>setjmp</code>为后续的<code>longjmp</code>设立了跳转目标，<code>setjmp</code>把当前进程环境的各种信息保存到<code>env</code>参数中，调用<code>longjmp</code>时必须指定相同的<code>env</code>变量，一般将<code>env</code>设定为全局变量。</p>
<h3 id="u4E00_u4E2A_u4F8B_u5B50"><a href="#u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    longjmp(env, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">	longjmp(env, <span class="number">1</span>);</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(env)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Calling f1() after initial setjmp()\n"</span>);</span><br><span class="line">	f1(argc);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We jumped back from f1()\n"</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We jumped back from f2()\n"</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out &#10;Calling f1() after initial setjmp()&#10;We jumped back from f1()&#10;&#10;ubuntu@VM-121-120-ubuntu:~/UNIX-Demos/proc_demos$ ./a.out  ss&#10;Calling f1() after initial setjmp()&#10;We jumped back from f2()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/04/epoll入门/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/04/epoll入门/" itemprop="url">
                  epoll入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/04/epoll入门/" class="leancloud_visitors" data-flag-title="epoll入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p><code>epoll</code>是linux内核的可扩展I/O机制，旨在替代POSIX的<code>select</code>和<code>poll</code>函数，让需要大量文件操作符的程序拥有更佳的性能。</p>
<h3 id="epoll_u63A5_u53E3"><a href="#epoll_u63A5_u53E3" class="headerlink" title="epoll接口"></a>epoll接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>epoll_create</code>创建一个epoll的句柄，参数<code>size</code>告知内核这个epoll需要监听的I/O事件的个数。函数返回一个描述符，在使用完epoll以后，我们需要手动关闭这个描述符，否则可能导致描述符耗尽。</li>
</ul>
<ul>
<li><p><code>epoll_ctl</code>用来操纵epoll所监听的事件，参数<code>op</code>表示这一次操作，其值：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的事件到epoll中</li>
<li>EPOLL_CTL_DEL：从epoll中删除一个事件</li>
<li>EPOLL_CTL_MOD：修改之前注册的一个事件</li>
</ul>
<p><code>epoll_event</code>是对应的描述符的事件的数据结构，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">               <span class="keyword">void</span>    *ptr;</span><br><span class="line">               <span class="keyword">int</span>      fd;</span><br><span class="line">               <span class="keyword">uint32_t</span> u32;</span><br><span class="line">               <span class="keyword">uint64_t</span> u64;</span><br><span class="line">           &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> epoll_event &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>epoll_event</code>中events是以下几个值的按位或的集合：</p>
<ul>
<li>EPOLLIN：对应的描述符可读</li>
<li>EPOLLOUT：对应的描述符可写</li>
<li>EPOLLERR：对应的描述符发生错误</li>
<li>EPOLLRDHUP：TCP套接字对端被关闭或者用<code>shutdown</code>函数关闭了写半部。</li>
<li>EPOLLPRI：有紧急数据可读</li>
<li>EPOLLHUP：对应的文件描述符被挂断</li>
<li>EPOLLET：将EPOLL设为边缘触发</li>
<li>EPOLLONESHOT：只监听一次事件，当事件发生之后如果还要监听则需要再次把事件注册入队列。</li>
</ul>
<p><code>epoll</code>的工作模式有两种：</p>
<ol>
<li>ET（edge trigger）模式：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理，如果不处理，下次调用<code>epoll_wait</code>时，不会再次向应用程序通知此事件。</li>
<li>LT（level trigger）模式：当<code>epoll_wait</code>检测到描述符事件发生并通知此事件时，应用程序不需要立即处理，下次调用<code>epoll_wait</code>时，会再次通知此事件。</li>
</ol>
<p>ET模式很大程序上减少了epoll事件被重复触发的次数，因此效率较LT模式高。epoll工作在ET模式时必须使用非阻塞接口，以避免一个阻塞读/写操作把处理多个文件描述符的任务饿死。</p>
</li>
<li><p><code>epoll_wait</code>等待事件的发生。<code>maxevents</code>参数告诉内核这次返回的事件最多有多少个，返回的事件存放在<code>events</code>参数对应的数组中，<code>timeoout</code>指定超时事件，若为-1则永久阻塞。</p>
</li>
</ul>
<h1 id="u4E00_u4E2Aecho_server/client_u7684_u4F8B_u5B50"><a href="#u4E00_u4E2Aecho_server/client_u7684_u4F8B_u5B50" class="headerlink" title="一个echo server/client的例子"></a>一个echo server/client的例子</h1><h3 id="u670D_u52A1_u5668_u7AEF"><a href="#u670D_u52A1_u5668_u7AEF" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IPADDRESS    <span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT         <span class="number">8080</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE      <span class="number">1024</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LISTENQ      <span class="number">20</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EPOLLEVENTS  <span class="number">100</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FDSIZE       <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> listenfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> listenfd = socket_bind(IPADDRESS, PORT);</span><br><span class="line">    listen(listenfd, LISTENQ);</span><br><span class="line">    do_epoll(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"socket create error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in server_addr;</span><br><span class="line">    bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"bind socket error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event events[EPOLLEVENTS];</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    epollfd = epoll_create(FDSIZE); <span class="comment">/* create a epoll fd which can handles FDSIZE fds */</span></span><br><span class="line">    <span class="keyword">if</span> (epollfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"create epoll error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add_event(epollfd, listenfd, EPOLLIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	ret = epoll_wait(epollfd, events, EPOLLEVENTS, -<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"epoll wait error"</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	handle_events(epollfd, events, ret, listenfd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(epollfd);		<span class="comment">/* must close epoll fd */</span>    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> listenfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">	fd = events[i].data.fd;</span><br><span class="line">	<span class="keyword">if</span> (fd == listenfd &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">	    handle_accept(epollfd, listenfd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">	    do_read(epollfd, fd, buf);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">	    do_write(epollfd, fd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in cli_addr;</span><br><span class="line">    <span class="keyword">int</span> cli_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> clifd;</span><br><span class="line">    <span class="keyword">if</span> ((clifd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cli_addr, &amp;cli_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"accept error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	add_event(epollfd, clifd, EPOLLIN);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread = read(fd, buf, MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"read error"</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"client close.\n"</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	delete_event(epollfd, fd, EPOLLIN);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"read message: %s"</span>, buf);</span><br><span class="line">	modify_event(epollfd, fd, EPOLLOUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nwrite = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (nwrite == -<span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	delete_event(epollfd, fd, EPOLLOUT);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">	modify_event(epollfd, fd, EPOLLIN);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAXSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5BA2_u6237_u7AEF"><a href="#u5BA2_u6237_u7AEF" class="headerlink" title="客户端"></a>客户端</h3><p>客户端代码我们也用epoll来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IPADDRESS    <span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT         <span class="number">8080</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE      <span class="number">1024</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LISTENQ      <span class="number">20</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EPOLLEVENTS  <span class="number">100</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FDSIZE       <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> pollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> conn_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in serv_addr;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"socket create error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port   = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, IPADDRESS, &amp;serv_addr.sin_addr) != <span class="number">1</span>) &#123;</span><br><span class="line">	perror(<span class="string">"inet_pton error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    </span><br><span class="line">    handle_connection(sockfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event events[EPOLLEVENTS];</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE];</span><br><span class="line"></span><br><span class="line">    epollfd = epoll_create(FDSIZE);</span><br><span class="line">    <span class="keyword">if</span> (epollfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"create epoll error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add_event(epollfd, STDIN_FILENO, EPOLLIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	ret = epoll_wait(epollfd, events, EPOLLEVENTS, -<span class="number">1</span>);</span><br><span class="line">	handle_events(epollfd, events, ret, sockfd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> num, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">	fd = events[i].data.fd;</span><br><span class="line">	<span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">	    do_read(epollfd, fd, sockfd, buf);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">	    do_write(epollfd, fd, sockfd, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread = read(fd, buf, MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"read error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"server close.\nbye\n"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fd == STDIN_FILENO) &#123;</span><br><span class="line">	    add_event(epollfd, sockfd, EPOLLOUT);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    delete_event(epollfd, sockfd, EPOLLIN);</span><br><span class="line">	    add_event(epollfd, STDOUT_FILENO, EPOLLOUT);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nwrite = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (nwrite &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fd == STDOUT_FILENO) &#123;</span><br><span class="line">	    delete_event(epollfd, fd, EPOLLOUT);	    </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    modify_event(epollfd, fd, EPOLLIN);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAXSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="See_Also"><a href="#See_Also" class="headerlink" title="See Also"></a>See Also</h3><p>文章内容和代码学习自<a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="external">IO多路复用之epoll总结</a></p>
<p><a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="external">epoll manual</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/22/互斥锁和条件变量/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/22/互斥锁和条件变量/" itemprop="url">
                  互斥锁和条件变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/22/互斥锁和条件变量/" class="leancloud_visitors" data-flag-title="互斥锁和条件变量">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u5E76_u53D1_u7F16_u7A0B_u7684_u95EE_u9898"><a href="#u5E76_u53D1_u7F16_u7A0B_u7684_u95EE_u9898" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h1><p>考虑这样一个问题，有两个线程，A和B，他们对同一个全局变量执行递减操作。假设C编译器将递减运算转换成3条机器指令：从内存装载到寄存器、递减寄存器、从寄存器存储到内存。可能会出现以下情形：</p>
<ol>
<li>线程A运行，把变量的值装载到一个寄存器中</li>
<li>系统把运行线程从A切换到B运行。A的寄存器被保存，B的寄存器则恢复。</li>
<li>线程B执行递减的全部操作，把新值存放到变量的变量中</li>
<li>线程A被恢复执行，A的寄存器被恢复，于是A从原来离开的地方开始执行，此时寄存器中保留的变量值是线程B执行递减前的值，这时候就出错了。</li>
</ol>
<p>可以看到这种并发的错误是因为递减操作不是原子操作而造成的，线程的切换会中断某些步骤，从而出现不预期的错误。</p>
<h1 id="u7B80_u5355_u5B9E_u4F8B"><a href="#u7B80_u5355_u5B9E_u4F8B" class="headerlink" title="简单实例"></a>简单实例</h1><p>我们通过一个简单的例子来说明如何利用互斥锁来解决并发。程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NLOOP    <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXP     <span class="number">5</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[MAXP];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> *iptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (iptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"malloc error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*iptr = i;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, doit, iptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread create error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_join(tids[i], <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread join error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NLOOP; i++) &#123;</span><br><span class="line">		val = counter;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, idx, val+<span class="number">1</span>);</span><br><span class="line">		counter = val+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;&#10;2: 1&#10;2: 2&#10;2: 3&#10;2: 4&#10;2: 5&#10;3: 5&#10;3: 6&#10;1: 1&#10;1: 2&#10;0: 1&#10;0: 2&#10;0: 3&#10;0: 4&#10;0: 5&#10;0: 6&#10;0: 7&#10;0: 8&#10;0: 9&#10;0: 10&#10;&#10;...</span><br></pre></td></tr></table></figure>
<p>可以看到当线程切换时，counter的值明显是错误的。</p>
<p>解决这种多个线程共享一个变量的问题是使用互斥锁（mutex，mutual exclusion）保护这个共享变量。互斥锁的作用是在线程访问该变量前必须持有互斥锁，否则线程将进入睡眠知道互斥锁可用。对于能够函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值*/</span></span><br></pre></td></tr></table></figure>
<p>修改之后的程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NLOOP    <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXP     <span class="number">5</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> counter_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[MAXP];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> *iptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (iptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"malloc error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*iptr = i;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, doit, iptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread create error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_join(tids[i], <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread join error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NLOOP; i++) &#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">	val = counter;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, idx, val+<span class="number">1</span>);</span><br><span class="line">	counter = val+<span class="number">1</span>;</span><br><span class="line">	Pthread_mutex_unlock(&amp;counter_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_lock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex lock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_unlock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex unlock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0: 1&#10;4: 2&#10;4: 3&#10;4: 4&#10;4: 5&#10;4: 6&#10;4: 7&#10;4: 8&#10;4: 9&#10;0: 10&#10;4: 11&#10;4: 12&#10;0: 13&#10;2: 14&#10;3: 15&#10;3: 16&#10;3: 17&#10;3: 18&#10;1: 19&#10;1: 20&#10;1: 21&#10;1: 22&#10;1: 23&#10;1: 24&#10;1: 25&#10;1: 26&#10;1: 27&#10;1: 28&#10;0: 29&#10;0: 30&#10;0: 31&#10;0: 32&#10;0: 33&#10;0: 34&#10;0: 35&#10;3: 36&#10;3: 37&#10;3: 38&#10;3: 39&#10;3: 40&#10;3: 41&#10;2: 42&#10;2: 43&#10;2: 44&#10;2: 45&#10;2: 46&#10;2: 47&#10;2: 48&#10;2: 49&#10;2: 50</span><br></pre></td></tr></table></figure>
<p>结果是正确的。</p>
<h1 id="u6761_u4EF6_u53D8_u91CF"><a href="#u6761_u4EF6_u53D8_u91CF" class="headerlink" title="条件变量"></a>条件变量</h1><p>互斥锁适合于防止同时访问某个共享变量，但是有的时候我们需要另外某种在等待某个条件发生期间让我们的进入睡眠的东西，这个就是条件变量。这里有一个例子，pthread函数库并没有等待任意一个线程终止的接口，那么如何实现呢？我们可以利用条件变量来实现这一功能。关于条件变量的函数接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(pthread_cond_t *cptr, pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(pthread_cond_t *cptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值*/</span></span><br></pre></td></tr></table></figure>
<p>先看完整的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NLOOP    <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXP     <span class="number">5</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="keyword">int</span> t_done;</span><br><span class="line"><span class="keyword">int</span> flag[MAXP];</span><br><span class="line"><span class="keyword">int</span> nleft;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> counter_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> tdone_mutex   = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>  tdone_cond    = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_wait</span><span class="params">(pthread_cond_t *cptr, pthread_mutex_t *mptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_signal</span><span class="params">(pthread_cond_t *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_join</span><span class="params">(pthread_t tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[MAXP];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    nleft = MAXP;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> *iptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (iptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    perror(<span class="string">"malloc error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*iptr = i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((error = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, doit, iptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    errno = error;</span><br><span class="line">	    perror(<span class="string">"pthread create error"</span>);</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line">	<span class="keyword">while</span> (t_done == <span class="number">0</span>)</span><br><span class="line">	    Pthread_cond_wait(&amp;tdone_cond, &amp;tdone_mutex);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXP; i++) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (flag[i] ==  <span class="number">1</span>) &#123;	<span class="comment">/* thread i already done */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread %d done\n"</span>, i);</span><br><span class="line">		Pthread_join(tids[i], <span class="literal">NULL</span>);</span><br><span class="line">		flag[i] = -<span class="number">1</span>;</span><br><span class="line">		nleft--;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Pthread_mutex_unlock(&amp;tdone_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> idx = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;NLOOP; i++) &#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">	val = counter;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, idx, val+<span class="number">1</span>);</span><br><span class="line">	counter = val+<span class="number">1</span>;</span><br><span class="line">	Pthread_mutex_unlock(&amp;counter_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line">    flag[idx] = <span class="number">1</span>;</span><br><span class="line">    t_done++;</span><br><span class="line">    Pthread_cond_signal(&amp;tdone_cond);</span><br><span class="line">    Pthread_mutex_unlock(&amp;tdone_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_lock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_lock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex lock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_mutex_unlock</span><span class="params">(pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_mutex_unlock(mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread mutex unlock error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_wait</span><span class="params">(pthread_cond_t *cptr, pthread_mutex_t *mptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((error = pthread_cond_wait(cptr, mptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread condition wait error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_cond_signal</span><span class="params">(pthread_cond_t *cptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_cond_signal(cptr)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread condition signal error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pthread_join</span><span class="params">(pthread_t tid, <span class="keyword">void</span> **status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = pthread_join(tid, status)) != <span class="number">0</span>) &#123;</span><br><span class="line">	errno = error;</span><br><span class="line">	perror(<span class="string">"pthread join error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先我们新建一个全局变量<code>t_done</code>表示当前终止的线程数量。</li>
<li>创建一个<code>tdone_cond</code>条件变量和与之相关联的互斥锁，通过持有该互斥锁期间递增该计数器并发送信号到该条件变量，一个线程通知朱循环自身即将终止。</li>
<li>主循环在持有条件变量相关联的互斥锁期间检查<code>t_done</code>，如果发现无事可做，那么主线程调用pthread_cond_wait等待信号，该函数把调用线程投入睡眠并释放调用线程持有的互斥锁，当调用线程后来从pthread_cond_wait返回时，<br>线程再次只有该互斥锁。</li>
<li>我们用一个flag标志来记录线程的状态，1表示线程已经终止，但未被另外一个线程调用pthread_join，-1表示已经被调用了pthread_join。</li>
</ol>
<p>每一个条件变量都需要关联一个互斥锁，因为<code>条件</code>通常是线程之间共享的某个变量的值。允许不同线程设置和测试该变量要求有一个与该变量相关联的互斥锁。举个栗子，如果之前的代码我们没有互斥锁，那么主循环的就是如下的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (t_done == <span class="number">0</span>)</span><br><span class="line">	Pthread_cond_wait(&amp;tdone_cond, &amp;tdone_mutex);</span><br></pre></td></tr></table></figure>
<p>有这样的可能：主线程外的一个线程在主循环测试t_done == 0之后但是在调用pthread_cond_wait之前调用递增了t_done，那么这个信号就会永远的地丢失了（pthread_cond_wait一定要在pthread_cond_signal前调用）。同样的理由要求<br>pthread_cond_wait被调用时，其所关联的互斥锁是必须上锁的，该函数作为单个原子操作解锁该互斥锁并把调用线程投入睡眠也是出于这个理由。如果函数不先解锁，到返回是再给它上锁，调用线程不得不实现解锁事后上锁，测试t_done的循环就变成了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line"><span class="keyword">while</span> (t_done == <span class="number">0</span>) &#123;</span><br><span class="line">	Pthread_mutex_unlock(&amp;tdone_mutex);</span><br><span class="line">	Pthread_cond_wait(&amp;tdone_cond, &amp;tdone_mutex);</span><br><span class="line">	Pthread_mutex_lock(&amp;tdone_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而会有这种情况：在Pthread_mutext_unlock与Pthread_cond_wait之间有另外的一个线程递增了t_done，那么这个信号也就永远消失了。</p>
<p>最后要说明的是，pthread_cond_signal通常唤醒等待相应条件上的单个线程，有时候一个线程需要唤醒多个等待条件的线程，这时候可以调用pthread_cond_broadcast，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(pthread_cond_t *cptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(pthread_cond_t *cptr, pthread_mutext_t *mptr, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/21/用线程处理客户请求/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Zach">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.JPG">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zach的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zach的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/用线程处理客户请求/" itemprop="url">
                  用线程处理客户请求
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/09/21/用线程处理客户请求/" class="leancloud_visitors" data-flag-title="用线程处理客户请求">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h1><p>传统的UNIX模型中，如果需要异步地完成一个任务，通常我们只要fork一个进程就可以了，但是fork进程存在以下两个问题：</p>
<ol>
<li>fork的代价是昂贵的。fork需要把父进程的内存映像复制到子进程，并在子进程中复制所有的描述符，虽然现在的实现是写时复制，但是fork一样是昂贵的。</li>
<li>fork返回之后父子进程通信需要利用IPC机制，比较费力。</li>
</ol>
<p>线程被称为<code>lightweight process</code>，同一进程可以创建多个线程，这些线程共享进程内的全局内存，这使得线程通信变得容易。同时，线程创建的代码大大小于进程创建。但是线程也存在同步的问题。</p>
<p>同一进程内的所有线程共享全局变量外，还共享：</p>
<ul>
<li>进程指令</li>
<li>大多数数据</li>
<li>打开的文件（描述符）</li>
<li>信号处理函数和信号变量</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
</ul>
<p>每个线程也有各自的：</p>
<ul>
<li>线程ID</li>
<li>寄存器集合，包括程序计数器和栈指针</li>
<li>栈，存放局部变量和返回地址</li>
<li>errno</li>
<li>信号掩码</li>
<li>优先级</li>
</ul>
<h1 id="u7EBF_u7A0B_u64CD_u7EB5_u51FD_u6570"><a href="#u7EBF_u7A0B_u64CD_u7EB5_u51FD_u6570" class="headerlink" title="线程操纵函数"></a>线程操纵函数</h1><h3 id="u521B_u5EFA_u7EBF_u7A0B"><a href="#u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="创建线程"></a>创建线程</h3><p>函数原型为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t *tid, pthread_attr_t *attr, void *(*func)(void *), void *arg);</span><br><span class="line"></span><br><span class="line">/× 成功返回0，否则返回正的Exxx值×/</span><br></pre></td></tr></table></figure>
<p>进程内的线程有一个线程ID标志，由tid返回。每个线程有许多属性：优先级、初始栈大小、是否应该成为一个守护进程等，若attr为NULL，则取默认值。线程的执行逻辑由func函数指针指定，函数接收一个void指针的<br>参数，第四个参数就是我们传递的参数，如果需要传递多个参数，把参数打包进一个结构指针即可。</p>
<h3 id="u7B49_u5F85_u7EBF_u7A0B_u7ED3_u675F"><a href="#u7B49_u5F85_u7EBF_u7A0B_u7ED3_u675F" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>利用pthread_join等待一个给定线程终止（是的，不能等待任意一个线程终止，如果需要，必须利用其他手段）。函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(pthread_t *tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>
<p>status通常是创建线程时func函数的返回值。</p>
<h3 id="u7EBF_u7A0B_u7EC8_u6B62"><a href="#u7EBF_u7A0B_u7EC8_u6B62" class="headerlink" title="线程终止"></a>线程终止</h3><p>让一个线程终止的方法之一是调用pthread_exit，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>
<p>status不能局限于要终止的线程的对象，因为当线程终止时，对象也将消失。如果该线程未曾脱离（下面会说到），它的线程ID和退出状态将一直留存到调用进程内的某个其他线程对它调用pthread_join。</p>
<p>让一个线程终止的另外的两个方法：</p>
<ul>
<li>启动线程的函数可以返回，其返回值就是相应线程的终止状态。</li>
<li>如果进程的main函数返回或者任何线程调用了exit，整个进程就终止，其中包括它的任何线程。</li>
</ul>
<h3 id="pthread_self_u4E0Epthread_detach_u51FD_u6570"><a href="#pthread_self_u4E0Epthread_detach_u51FD_u6570" class="headerlink" title="pthread_self与pthread_detach函数"></a>pthread_self与pthread_detach函数</h3><p>pthread_self返回进程内该线程的ID，pthread_detach后，线程像守护进程一样，当它们终止时，所有的资源都被释放，不需要某个其他进程调用pthread_join。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(pthread_t tid)</span></span>;        <span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，上述函数的调用情况是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure>
<p>以此，线程让自己脱离。</p>
<h1 id="u7EBF_u7A0B_u5B89_u5168_u51FD_u6570"><a href="#u7EBF_u7A0B_u5B89_u5168_u51FD_u6570" class="headerlink" title="线程安全函数"></a>线程安全函数</h1><p>当一个函数修改了全局变量，那么这个函数不是线程安全的，换句话说该函数不可重入。考虑以下的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		len = addrlen;</span><br><span class="line">		connfd = Accept(listenfd, cliaddr, &amp;len);</span><br><span class="line">		Pthread_create(&amp;tid, <span class="literal">NULL</span>, doit, &amp;connfd);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> connfd;</span><br><span class="line">	</span><br><span class="line">	connfd = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来上述代码是没有问题的，但是考虑这样一种情况：</p>
<ol>
<li>accept返回，主线程调用pthread_create创建一个新的线程</li>
<li>调度新创建的线程执行，但是并没有执行到给connfd赋值就被切换了。</li>
<li>另一个连接就绪，accept返回，返回的描述符存入connfd</li>
<li>先前切换的线程被调度执行，这时候它所得到的connfd却并不是第一个连接的描述符了。</li>
</ol>
<p>POSIX要求许多函数是线程安全的，即它们都是可重入的，这个要求通过对我们透明的库函数内部执行某种形式的同步达到，线程安全函数见UNP P542。</p>
<h1 id="u7EBF_u7A0B_u7279_u5B9A_u6570_u636E"><a href="#u7EBF_u7A0B_u7279_u5B9A_u6570_u636E" class="headerlink" title="线程特定数据"></a>线程特定数据</h1><p>把一个未线程化的程序转换成使用线程的版本时，有时会碰到因其中有函数使用静态变量而引起的一个常见变成错误。解决这样的错误有许多方法，这里我们介绍使用<code>线程特定数据</code>的方法。</p>
<p>每个系统支持优先数量的线程特定数据，POSIX要求这个限制不小于128.系统为每个进程维护一个我们称之为Key的结构数据，如图所示：</p>
<img src="/2016/09/21/用线程处理客户请求/key_tsd.png" alt="key_tsd.png" title="">
<p>flag表示该项是否被使用，析构函数用于线程终止时释放线程占用的数据内存，由编程人员指定。</p>
<p>这个Key是进程范围内的，即所有线程共享该数组。除此之外，系统还为每个线程维护特定于线程的Pthread结构，其部分内容是我们称之为pkey数据的128个元素的指针数组。如下所示：</p>
<img src="/2016/09/21/用线程处理客户请求/pkey_tsd.png" alt="pkey_tsd.png" title="">
<p>pkey数组的所有元素都被初始化为空指针，这128个指针和进程内的128个可能的Key是逐一关联的。</p>
<p>举一个例子来说明线程特定的数据如何使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> rl_key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> rl_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_destructor</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Pthread_key_create(&amp;rl_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> thread_readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen) &#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	pthread_once(&amp;rl_once, readline_once);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((ptr = pthread_getspecific(rl_key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ptr = Malloc(...);</span><br><span class="line">		pthread_setspecific(rl_key, ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* use values pointed to by ptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程内第一个线程调用thread_readline时，一个Key被创建，同时注册对应的析构函数。之后进程内线程的状态如下：</p>
<img src="/2016/09/21/用线程处理客户请求/thread_statues1.png" alt="thread_statues1.png" title="">
<p>这时候如果有另外一个线程调用thread_readline，那么pthread_once之前执行过一次，Key已经创建（这两次析构函数是一样的），线程取该Key对应的内存指针，返回为空，于是线程创建一个新的内存区域。进程内线程的状态变为如下所示：</p>
<img src="/2016/09/21/用线程处理客户请求/thread_statues2.png" alt="thread_statues2.png" title="">
<p>可以看到每一个线程有特定于线程自身的缓冲区域，这样就不会发生同步的问题。</p>
<p>可以给出用到的函数原型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include d.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_once(pthread_once_t *onceptr, void (*init)(void));</span><br><span class="line"></span><br><span class="line">int pthread_key_create(pthread_key_t *keyptr, void (*destructor) (void *));</span><br><span class="line"></span><br><span class="line">void *pthread_getspecific(pthread_key_t key);</span><br><span class="line"></span><br><span class="line">void *pthread_setspecific(pthread_key_t key, const void *value);</span><br></pre></td></tr></table></figure>
<p>注意pthread_once_t类型的变量在传入pthread_once函数之前，要初始化为PTHREAD_ONCE_INIT。</p>
<h1 id="u4F7F_u7528_u7EBF_u7A0B_u7279_u5B9A_u6570_u636E_u7684readline_u51FD_u6570"><a href="#u4F7F_u7528_u7EBF_u7A0B_u7279_u5B9A_u6570_u636E_u7684readline_u51FD_u6570" class="headerlink" title="使用线程特定数据的readline函数"></a>使用线程特定数据的readline函数</h1><p>这里给出一个具体的例子，该例子是修改过的readline函数，它是利用了线程的特定数据以做到线程安全。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unp.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unpthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> rl_key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> rl_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_destructor</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Pthread_key_create(&amp;rl_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> rl_cnt;</span><br><span class="line">    <span class="keyword">char</span> *rl_bufptr;</span><br><span class="line">    <span class="keyword">char</span> rl_buf[MAXLINE];</span><br><span class="line">&#125;Rline;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(Rline *tsd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tsd -&gt; rl_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* no data in buffer */</span></span><br><span class="line">    again:</span><br><span class="line">	<span class="keyword">if</span> ((tsd -&gt; rl_cnt = read(fd, tsd -&gt; rl_buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tsd -&gt; rl_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">/* EOF */</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    tsd -&gt; rl_bufptr = tsd -&gt; rl_buf;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tsd -&gt; rl_cnt--;</span><br><span class="line">    *ptr = *tsd -&gt; rl_bufptr++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> thread_readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen) &#123;</span><br><span class="line">    Rline *tsd;</span><br><span class="line">    <span class="keyword">size_t</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;rl_once, readline_once);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tsd = pthread_getspecific(rl_key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* alloc thread specific data */</span></span><br><span class="line">	tsd = Calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(Rline));</span><br><span class="line">	pthread_setspecific(rl_key, tsd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n&lt;maxlen; n++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((rc = my_read(tsd, fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">	    *ptr++ = c;</span><br><span class="line">	    <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">/* end of file */</span></span><br><span class="line">	    *ptr = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">/* error */</span></span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.JPG"
               alt="Zach" />
          <p class="site-author-name" itemprop="name">Zach</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zach</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




	




  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("ntwSG1Uc9Pv9VSd5ODUsFYkK-gzGzoHsz", "HoWAvsNTJHhdUmXFuqT6j4vp");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
