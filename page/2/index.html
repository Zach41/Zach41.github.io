<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Zach的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Zach的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zach的博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Zach的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zach的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">这个人很懒，都不知道说些什么 :(</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/用线程处理客户请求/" itemprop="url">
                  用线程处理客户请求
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T00:00:00+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/21/用线程处理客户请求/" class="leancloud_visitors" data-flag-title="用线程处理客户请求">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h1><p>传统的UNIX模型中，如果需要异步地完成一个任务，通常我们只要fork一个进程就可以了，但是fork进程存在以下两个问题：</p>
<ol>
<li>fork的代价是昂贵的。fork需要把父进程的内存映像复制到子进程，并在子进程中复制所有的描述符，虽然现在的实现是写时复制，但是fork一样是昂贵的。</li>
<li>fork返回之后父子进程通信需要利用IPC机制，比较费力。</li>
</ol>
<p>线程被称为<code>lightweight process</code>，同一进程可以创建多个线程，这些线程共享进程内的全局内存，这使得线程通信变得容易。同时，线程创建的代码大大小于进程创建。但是线程也存在同步的问题。</p>
<p>同一进程内的所有线程共享全局变量外，还共享：</p>
<ul>
<li>进程指令</li>
<li>大多数数据</li>
<li>打开的文件（描述符）</li>
<li>信号处理函数和信号变量</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
</ul>
<p>每个线程也有各自的：</p>
<ul>
<li>线程ID</li>
<li>寄存器集合，包括程序计数器和栈指针</li>
<li>栈，存放局部变量和返回地址</li>
<li>errno</li>
<li>信号掩码</li>
<li>优先级</li>
</ul>
<h1 id="u7EBF_u7A0B_u64CD_u7EB5_u51FD_u6570"><a href="#u7EBF_u7A0B_u64CD_u7EB5_u51FD_u6570" class="headerlink" title="线程操纵函数"></a>线程操纵函数</h1><h3 id="u521B_u5EFA_u7EBF_u7A0B"><a href="#u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="创建线程"></a>创建线程</h3><p>函数原型为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t *tid, pthread_attr_t *attr, void *(*func)(void *), void *arg);</span><br><span class="line"></span><br><span class="line">/× 成功返回0，否则返回正的Exxx值×/</span><br></pre></td></tr></table></figure>
<p>进程内的线程有一个线程ID标志，由tid返回。每个线程有许多属性：优先级、初始栈大小、是否应该成为一个守护进程等，若attr为NULL，则取默认值。线程的执行逻辑由func函数指针指定，函数接收一个void指针的<br>参数，第四个参数就是我们传递的参数，如果需要传递多个参数，把参数打包进一个结构指针即可。</p>
<h3 id="u7B49_u5F85_u7EBF_u7A0B_u7ED3_u675F"><a href="#u7B49_u5F85_u7EBF_u7A0B_u7ED3_u675F" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><p>利用pthread_join等待一个给定线程终止（是的，不能等待任意一个线程终止，如果需要，必须利用其他手段）。函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(pthread_t *tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>
<p>status通常是创建线程时func函数的返回值。</p>
<h3 id="u7EBF_u7A0B_u7EC8_u6B62"><a href="#u7EBF_u7A0B_u7EC8_u6B62" class="headerlink" title="线程终止"></a>线程终止</h3><p>让一个线程终止的方法之一是调用pthread_exit，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>
<p>status不能局限于要终止的线程的对象，因为当线程终止时，对象也将消失。如果该线程未曾脱离（下面会说到），它的线程ID和退出状态将一直留存到调用进程内的某个其他线程对它调用pthread_join。</p>
<p>让一个线程终止的另外的两个方法：</p>
<ul>
<li>启动线程的函数可以返回，其返回值就是相应线程的终止状态。</li>
<li>如果进程的main函数返回或者任何线程调用了exit，整个进程就终止，其中包括它的任何线程。</li>
</ul>
<h3 id="pthread_self_u4E0Epthread_detach_u51FD_u6570"><a href="#pthread_self_u4E0Epthread_detach_u51FD_u6570" class="headerlink" title="pthread_self与pthread_detach函数"></a>pthread_self与pthread_detach函数</h3><p>pthread_self返回进程内该线程的ID，pthread_detach后，线程像守护进程一样，当它们终止时，所有的资源都被释放，不需要某个其他进程调用pthread_join。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(pthread_t tid)</span></span>;        <span class="comment">/* 成功返回0，否则返回正的Exxx值 */</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，上述函数的调用情况是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure>
<p>以此，线程让自己脱离。</p>
<h1 id="u7EBF_u7A0B_u5B89_u5168_u51FD_u6570"><a href="#u7EBF_u7A0B_u5B89_u5168_u51FD_u6570" class="headerlink" title="线程安全函数"></a>线程安全函数</h1><p>当一个函数修改了全局变量，那么这个函数不是线程安全的，换句话说该函数不可重入。考虑以下的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		len = addrlen;</span><br><span class="line">		connfd = Accept(listenfd, cliaddr, &amp;len);</span><br><span class="line">		Pthread_create(&amp;tid, <span class="literal">NULL</span>, doit, &amp;connfd);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">doit</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> connfd;</span><br><span class="line">	</span><br><span class="line">	connfd = *((<span class="keyword">int</span> *)arg);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来上述代码是没有问题的，但是考虑这样一种情况：</p>
<ol>
<li>accept返回，主线程调用pthread_create创建一个新的线程</li>
<li>调度新创建的线程执行，但是并没有执行到给connfd赋值就被切换了。</li>
<li>另一个连接就绪，accept返回，返回的描述符存入connfd</li>
<li>先前切换的线程被调度执行，这时候它所得到的connfd却并不是第一个连接的描述符了。</li>
</ol>
<p>POSIX要求许多函数是线程安全的，即它们都是可重入的，这个要求通过对我们透明的库函数内部执行某种形式的同步达到，线程安全函数见UNP P542。</p>
<h1 id="u7EBF_u7A0B_u7279_u5B9A_u6570_u636E"><a href="#u7EBF_u7A0B_u7279_u5B9A_u6570_u636E" class="headerlink" title="线程特定数据"></a>线程特定数据</h1><p>把一个未线程化的程序转换成使用线程的版本时，有时会碰到因其中有函数使用静态变量而引起的一个常见变成错误。解决这样的错误有许多方法，这里我们介绍使用<code>线程特定数据</code>的方法。</p>
<p>每个系统支持优先数量的线程特定数据，POSIX要求这个限制不小于128.系统为每个进程维护一个我们称之为Key的结构数据，如图所示：</p>
<img src="/2016/09/21/用线程处理客户请求/key_tsd.png" alt="key_tsd.png" title="">
<p>flag表示该项是否被使用，析构函数用于线程终止时释放线程占用的数据内存，由编程人员指定。</p>
<p>这个Key是进程范围内的，即所有线程共享该数组。除此之外，系统还为每个线程维护特定于线程的Pthread结构，其部分内容是我们称之为pkey数据的128个元素的指针数组。如下所示：</p>
<img src="/2016/09/21/用线程处理客户请求/pkey_tsd.png" alt="pkey_tsd.png" title="">
<p>pkey数组的所有元素都被初始化为空指针，这128个指针和进程内的128个可能的Key是逐一关联的。</p>
<p>举一个例子来说明线程特定的数据如何使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> rl_key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> rl_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_destructor</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Pthread_key_create(&amp;rl_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> thread_readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen) &#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	pthread_once(&amp;rl_once, readline_once);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((ptr = pthread_getspecific(rl_key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ptr = Malloc(...);</span><br><span class="line">		pthread_setspecific(rl_key, ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* use values pointed to by ptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程内第一个线程调用thread_readline时，一个Key被创建，同时注册对应的析构函数。之后进程内线程的状态如下：</p>
<img src="/2016/09/21/用线程处理客户请求/thread_statues1.png" alt="thread_statues1.png" title="">
<p>这时候如果有另外一个线程调用thread_readline，那么pthread_once之前执行过一次，Key已经创建（这两次析构函数是一样的），线程取该Key对应的内存指针，返回为空，于是线程创建一个新的内存区域。进程内线程的状态变为如下所示：</p>
<img src="/2016/09/21/用线程处理客户请求/thread_statues2.png" alt="thread_statues2.png" title="">
<p>可以看到每一个线程有特定于线程自身的缓冲区域，这样就不会发生同步的问题。</p>
<p>可以给出用到的函数原型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include d.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_once(pthread_once_t *onceptr, void (*init)(void));</span><br><span class="line"></span><br><span class="line">int pthread_key_create(pthread_key_t *keyptr, void (*destructor) (void *));</span><br><span class="line"></span><br><span class="line">void *pthread_getspecific(pthread_key_t key);</span><br><span class="line"></span><br><span class="line">void *pthread_setspecific(pthread_key_t key, const void *value);</span><br></pre></td></tr></table></figure>
<p>注意pthread_once_t类型的变量在传入pthread_once函数之前，要初始化为PTHREAD_ONCE_INIT。</p>
<h1 id="u4F7F_u7528_u7EBF_u7A0B_u7279_u5B9A_u6570_u636E_u7684readline_u51FD_u6570"><a href="#u4F7F_u7528_u7EBF_u7A0B_u7279_u5B9A_u6570_u636E_u7684readline_u51FD_u6570" class="headerlink" title="使用线程特定数据的readline函数"></a>使用线程特定数据的readline函数</h1><p>这里给出一个具体的例子，该例子是修改过的readline函数，它是利用了线程的特定数据以做到线程安全。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unp.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unpthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> rl_key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> rl_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_destructor</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Pthread_key_create(&amp;rl_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> rl_cnt;</span><br><span class="line">    <span class="keyword">char</span> *rl_bufptr;</span><br><span class="line">    <span class="keyword">char</span> rl_buf[MAXLINE];</span><br><span class="line">&#125;Rline;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(Rline *tsd, <span class="keyword">int</span> fd, <span class="keyword">char</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tsd -&gt; rl_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* no data in buffer */</span></span><br><span class="line">    again:</span><br><span class="line">	<span class="keyword">if</span> ((tsd -&gt; rl_cnt = read(fd, tsd -&gt; rl_buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tsd -&gt; rl_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">/* EOF */</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    tsd -&gt; rl_bufptr = tsd -&gt; rl_buf;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tsd -&gt; rl_cnt--;</span><br><span class="line">    *ptr = *tsd -&gt; rl_bufptr++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> thread_readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen) &#123;</span><br><span class="line">    Rline *tsd;</span><br><span class="line">    <span class="keyword">size_t</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *ptr;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;rl_once, readline_once);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tsd = pthread_getspecific(rl_key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* alloc thread specific data */</span></span><br><span class="line">	tsd = Calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(Rline));</span><br><span class="line">	pthread_setspecific(rl_key, tsd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n&lt;maxlen; n++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((rc = my_read(tsd, fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">	    *ptr++ = c;</span><br><span class="line">	    <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">/* end of file */</span></span><br><span class="line">	    *ptr = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">/* error */</span></span><br><span class="line">	    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/IPv4与IPv6的户操作性/" itemprop="url">
                  IPv4与IPv6的户操作性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T00:00:00+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/19/IPv4与IPv6的户操作性/" class="leancloud_visitors" data-flag-title="IPv4与IPv6的户操作性">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IPv4_u6620_u5C04_u7684IPv6_u5730_u5740"><a href="#IPv4_u6620_u5C04_u7684IPv6_u5730_u5740" class="headerlink" title="IPv4映射的IPv6地址"></a>IPv4映射的IPv6地址</h1><p>IPv4映射的IPv6地址允许在因特网向IPv6过度时期让运行在双栈主机上的IPv6应用进程能够与只支持IPv4的主机通信。这些地址是IPv6应用进程查询某个只有IPv4地址的主机的IPv6地址时，DNS解析器按需自动创建的且不存在于任何DNS<br>数据文件中。在IPv6套接字上使用这种类型的地址导致往目的地IPv4主机发送IPv4数据报。</p>
<p>下图展示了一个IPv4映射的IPv6地址的格式：</p>
<img src="/2016/09/19/IPv4与IPv6的户操作性/mapped.png" alt="mapped.png" title="">
<h1 id="IPv4_u5BA2_u6237_u4E0EIPv6_u670D_u52A1_u5668"><a href="#IPv4_u5BA2_u6237_u4E0EIPv6_u670D_u52A1_u5668" class="headerlink" title="IPv4客户与IPv6服务器"></a>IPv4客户与IPv6服务器</h1><p>双栈主机的一个特性就是其上的IPv6服务器既可以处理IPv4客户，也可以处理IPv6客户。这是通过IPv4映射的IPv6地址实现的。下图是一个例子：</p>
<img src="/2016/09/19/IPv4与IPv6的户操作性/ipv4to6.png" alt="ipv4to6.png" title="">
<p>IPv4客户发送一个IPv4的SYN分节以期和服务器建立连接。来自IPv4客户的SYN分节在以太网中表现为一个以太网首部、一个IPv4首部、一个TCP部以及TCP数据。以太网首部中包含的类型字段为0x0800，表示它是一个IPv4帧数据。</p>
<p>接收数据链路通过查看以太网类型字段把每个帧数据发送给对应的IP模块。IPv4模块结合其上的TCP模块检测到IPv4数据报的目的段端口对应一个IPv4套接字，于是该数据报Ipv4首部中的源IPv4地址被转换成IPv4映射的IPv6地址，当<br>accept系统调用把这个已经接收的IPv4客户连接返回被服务器进程的时候，这个映射后的地址作为客户的IPv6地址返回到服务器的IPv6套接字。该连接上的其余数据同样都是IPv4数据报。服务器进程完全不知道它是在与一个IPv4客户机通信。</p>
<h1 id="IPv6_u5BA2_u6237_u4E0EIPv4_u670D_u52A1_u5668"><a href="#IPv6_u5BA2_u6237_u4E0EIPv4_u670D_u52A1_u5668" class="headerlink" title="IPv6客户与IPv4服务器"></a>IPv6客户与IPv4服务器</h1><p>在一个双栈主机上运行一个IPv6客户程序，其于一个IPv4服务器程序交互的流程如下：</p>
<ol>
<li>一个IPv4服务器在只支持IPv4的一个主机上启动后创建一个IPv4监听套接字。</li>
<li>IPv6客户启动后调用getaddrinfo单纯查找IPv6地址（请求AF_INET6地址，hints结构中设置了AI_V4MAPPED标志），最后只有得到只支持IPv4的服务器主机的A记录，那么返回给客户的就是IPv4映射之后的IPv6地址。</li>
<li>IPv6客户设置这个IPv4映射后的IPv6地址，调用connect，内核检测到这个映射的地址后自动发送一个IPv4的SYN分节到服务器。</li>
<li>服务器响应一个IPv4 SYN/ACK分节，连接于是用IPv4数据报建立。</li>
</ol>
<p>以后在以太网上传递的是IPv4数据报。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/系统服务——daemon/" itemprop="url">
                  系统服务——daemon
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T00:00:00+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/19/系统服务——daemon/" class="leancloud_visitors" data-flag-title="系统服务——daemon">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h1><h3 id="u4EC0_u4E48_u662Fdaemon"><a href="#u4EC0_u4E48_u662Fdaemon" class="headerlink" title="什么是daemon"></a>什么是daemon</h3><p>简单来说，系统为了某些功能必须提供一些服务，这个服务我们称之为<code>service</code>，但是service的提供需要进程的运行，所以实现这个service的程序我们称之为<code>daemon</code>。我们不必<br>区分daemon与service，或者说可以将他们视为等同的。因为没有daemon在后台运行就不会有这个serivce。daemon没有控制终端，所以当有事发生时，它们需要有消息输出的方法可用。<br><code>syslog</code>函数是输出这些消息的标准方法，它把这些消息发送给<code>syslogd</code>守护进程。</p>
<p>syslogd的函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *message, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>priority</code>由level和facility组成，具体可以查看UNP P288。</p>
<h3 id="daemon_u7684_u4E3B_u8981_u5206_u7C7B"><a href="#daemon_u7684_u4E3B_u8981_u5206_u7C7B" class="headerlink" title="daemon的主要分类"></a>daemon的主要分类</h3><p>如果按照启动与管理方式分类：</p>
<ul>
<li>stand alone：这种类型的daemon不必通过其他机制来管理，可以自行启动，一旦启动就常驻内存。其最大的优点是由于一直在内存内持续的提供服务，因此对于客户的请求响应较快。常见的<br>stand alone的daemon有ftp、httpd等。</li>
<li>super daemon：一个特殊的daemon来统一管理其他的daemon。这一种服务的启动方式通过同一个daemon来负责唤起服务。这个特殊的daemon被称为super daemon。早期的super daemon是inetd，现在<br>Linux下是xinetd。当客户没有请求时，对应的服务未启动，只有当客户有对应的请求来到时，super daemon才会唤醒相应的服务，当请求完成之后，被唤醒的这个服务也会关闭并释放资源。该机制的优点在于：１）super daemon<br>可以具有安全管控机制；２）服务在请求结束后就关闭，不会一直占用资源。缺点在于对于请求的响应较慢。</li>
</ul>
<p>如果按照工作形态分类：</p>
<ul>
<li>signal-control：这种daemon通过信号来管理，只要有任何客户端的请求进来，它就会立即启动取处理。</li>
<li>interval-control：这种daemon每隔一段时间就主动取执行某项工作。</li>
</ul>
<h3 id="u5C06_u4E00_u4E2A_u7A0B_u5E8F_u4F5C_u4E3Adaemon_u8FD0_u884C"><a href="#u5C06_u4E00_u4E2A_u7A0B_u5E8F_u4F5C_u4E3Adaemon_u8FD0_u884C" class="headerlink" title="将一个程序作为daemon运行"></a>将一个程序作为daemon运行</h3><p>Linux提供了<code>daemon</code>函数将一个普通进程转变为守护进程运行。它的原理和这里给出的<code>daemon_init</code>函数大同小异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pname, <span class="keyword">int</span> facility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child continues */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* become session leader */</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 必须忽略SIGHUP，否则当会话头进程终止时，会话中的所有进程都收到SIGHUP信号 */</span></span><br><span class="line">    Signal(SIGHUP, SIG_IGN);</span><br><span class="line">    <span class="comment">/* 再次Fork，使得进程不再是会话头 */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid)</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    daemon_proc = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXFD; i++)</span><br><span class="line">	close(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* redirec stdin, stdout and stderr to '/dev/null' */</span></span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDONLY);</span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    openlog(pname, LOG_PID, facility);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先是fork，在fork结束之后，父进程终止，子进程自动在后台运行。另外，由于子进程继承了父进程的进程组ID，这保证了子进程不是一个进程组的头进程，这为下面的setsid做了准备。</li>
<li>setsid，其用于创建一个新的会话，当前进程变为新的会话的会话头进程以及新进程组的进程组头进程，从而不再有控制终端。</li>
<li>忽略SIGHUP信号并再次fork，再次fork保证本守护进程不会是会话头进程，那么即使将来打开了一个终端设备，也不会自动获得控制终端。因为当没有控制终端的会话头进程打开一个终端设备时，该终端会自动成为<br>这个会话头进程的控制终端。忽略SIGHUP信号是因为当会话头进程终止时，其会话中的所有进程（再次fork产生的子进程）都收到SIGHUP信号。</li>
<li>将stdin、stdout以及stderr重定向到/dev/null，打开这些描述符的理由在于，守护进程调用的那些假设能从这三个描述符读写的库函数不会因为这些描述符未打开而失败。</li>
<li>调用syslog处理函数。</li>
</ol>
<p>既然守护进程在没有控制终端的环境下运行，那么它绝对不会收到来自内核的SIGHUP信号，许多守护进程因此把这个信号作为来自系统管理员的一个通知，表示其配置文件已经发生变化，守护进程应该重新读入配置文件。</p>
<h1 id="Linux_u4E0Bdaemon_u7684_u542F_u52A8_u811A_u672C_u548C_u542F_u52A8_u65B9_u5F0F"><a href="#Linux_u4E0Bdaemon_u7684_u542F_u52A8_u811A_u672C_u548C_u542F_u52A8_u65B9_u5F0F" class="headerlink" title="Linux下daemon的启动脚本和启动方式"></a>Linux下daemon的启动脚本和启动方式</h1><h3 id="u914D_u7F6E_u6587_u4EF6_u4F4D_u7F6E"><a href="#u914D_u7F6E_u6587_u4EF6_u4F4D_u7F6E" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><p>通常daemon的启动脚本放在/etc/init.d/目录下，启动脚本可以进程环境检测、配置文件分析、PID文件放置以及相关重要交换文件的锁操作。</p>
<p>super daemon的配置文件放置在/etc/xinetd.d/目录和/etc/xinetd.conf中。</p>
<p>在/etc/目录下还有各自服务的配置文件</p>
<p>/var/lib/目录下是一些会产生数据的服务放置产生的数据库的位置，数据库管理系统MySQL的数据库默认写入/var/lib/mysql。</p>
<p>/var/run/目录下存放各服务程序的PID记录。</p>
<p>对于stand alone的daemon，我们即可执行/etc/init.d/目录下的脚本来启动它，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ /etc/init.d/mysql start</span><br></pre></td></tr></table></figure>
<p>也可以利用service命令（实际上它也是一个stand alone的服务）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ service mysql start</span><br></pre></td></tr></table></figure>
<h3 id="super_daemon_u914D_u7F6E_u6587_u4EF6"><a href="#super_daemon_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="super daemon配置文件"></a>super daemon配置文件</h3><p>Linux下super daemon由xinetd这个进程实现，它不仅可以启动其他daemon，还可以进行安全性或者其他管理机制的控制。xinetd的默认配置存放在/etc/xinetd.conf中，由xinetd启动的服务程序的配置放置在/etc/xinetd.d目录下。<br>如果一个服务的配置文件没有xinetd.conf中指定的参数，那么该服务对应的参数就以xinetd.conf中的为准。具体的参数说明可以参加《鸟哥——基础篇》P559。一个简单的daytime服务配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mydaytime&#10;&#123;&#10;        disable         = no&#10;        socket_type     = stream&#10;        wait            = no&#10;        user            = root&#10;        server          = /home/zach41/Desktop/unp/unpv13e/inetd/daytimetcpsrv3&#10;        log_on_failure  = USERID&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这之后我们还需要修改/etc/services文件，分配一个端口来提供daytime服务。具体就是添加如下一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydaytime    9999/tcp</span><br></pre></td></tr></table></figure>
<p>这样配置之后，我们重启xinetd服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ service xinetd restart&#10;&#10140;  ~ sudo netstat -tnlp | grep 9999&#10;[sudo] password for zach41: &#10;tcp        0      0 0.0.0.0:9999            0.0.0.0:*               LISTEN      15914/xinetd</span><br></pre></td></tr></table></figure>
<p>可以看到xinetd进程在监听9999端口。</p>
<p>我们运行一个daytime客户端程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  names git:(master) &#10007; ./daytimetcpcli2 0.0.0.0 9999&#10;trying 0.0.0.0:9999&#10;Mon Sep 19 18:43:04 2016</span><br></pre></td></tr></table></figure>
<h3 id="daytime_daemon_u7A0B_u5E8F"><a href="#daytime_daemon_u7A0B_u5E8F" class="headerlink" title="daytime daemon程序"></a>daytime daemon程序</h3><p>最后这里给出daytimeserver的代码，这是由xinetd作为守护进程启动的时间获取服务器程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>	<span class="string">"unp.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>	<span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">socklen_t</span>		len;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr	*cliaddr;</span><br><span class="line">	<span class="keyword">char</span>			buff[MAXLINE];</span><br><span class="line">	<span class="keyword">time_t</span>			ticks;</span><br><span class="line"></span><br><span class="line">	daemon_inetd(argv[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cliaddr = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">	len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">	Getpeername(<span class="number">0</span>, cliaddr, &amp;len);</span><br><span class="line">	err_msg(<span class="string">"connection from %s"</span>, Sock_ntop(cliaddr, len));</span><br><span class="line"></span><br><span class="line">    ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">"%.24s\r\n"</span>, ctime(&amp;ticks));</span><br><span class="line">    Write(<span class="number">0</span>, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">	Close(<span class="number">0</span>);	<span class="comment">/* close TCP connection */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到所有套接字的创建代码(tcp_listen和accept的调用)都不见了，这些步骤都有xinetd执行，我们使用描述符0指代已由xinetd接受的TCP连接（套接字描述符被复制到描述符0, 1, 2）。daemon_init只是负责设置daemon_proc<br>标志以及调用openlog，从而发送日志信息给syslogd守护进程。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/套接字选项/" itemprop="url">
                  套接字选项
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T00:00:00+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/13/套接字选项/" class="leancloud_visitors" data-flag-title="套接字选项">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u4FEE_u6539_u5957_u63A5_u5B57_u9009_u9879"><a href="#u4FEE_u6539_u5957_u63A5_u5B57_u9009_u9879" class="headerlink" title="修改套接字选项"></a>修改套接字选项</h1><p>有几种方法来修改和获取套接字的选项：</p>
<ul>
<li>getsockopt &amp; setsockopt</li>
<li>fcntl</li>
<li>ioctl</li>
</ul>
<h3 id="getsockopt__26amp_3B_setsockopt"><a href="#getsockopt__26amp_3B_setsockopt" class="headerlink" title="getsockopt &amp; setsockopt"></a>getsockopt &amp; setsockopt</h3><p>这两个函数仅仅用于套接字。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, socklen_t *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, socklen_t optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sockfd必须指向一个已经打开的套接字，level指向系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码（如TCP、IPv4、IPv6或SCTP）。</p>
<p>optval指向某个变量，变量的大小由最后一个参数optlen指定，setsockopt从optval中取得待设置的新值，而getsockopt把获取到的值存入对应的地址中。</p>
<p>套接字选项粗分为两大基本类型：</p>
<ul>
<li>启用或禁止某个特性的标志选项(flag = 0禁止特性，flag = 1开启特性)</li>
<li>取得并返回我们可以设置或检查的特定值选项，即值选项。</li>
</ul>
<p>套接字选项可以参见UNP的P151</p>
<h1 id="u901A_u7528_u5957_u63A5_u5B57_u9009_u9879_uFF08_u90E8_u5206_uFF09"><a href="#u901A_u7528_u5957_u63A5_u5B57_u9009_u9879_uFF08_u90E8_u5206_uFF09" class="headerlink" title="通用套接字选项（部分）"></a>通用套接字选项（部分）</h1><p>这里仅仅列出部分的通用套接字选项，其实也就是挑了一些自己看得懂的选项记录下。</p>
<h3 id="SO_BROADCAST"><a href="#SO_BROADCAST" class="headerlink" title="SO_BROADCAST"></a>SO_BROADCAST</h3><p>开启或禁止进程发送广播消息的能力。只有数据报支持广播，并且还是在支持广播消息的网络上（以太网、令牌网络等）。</p>
<h3 id="SO_DEBUG"><a href="#SO_DEBUG" class="headerlink" title="SO_DEBUG"></a>SO_DEBUG</h3><p>仅由TCP支持，当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和接收的所有分组保留详细的跟踪信息，这些信息保存在内核的某个环形缓冲区中，并可使用trpt程序进行检查。</p>
<h3 id="SO_ERROR"><a href="#SO_ERROR" class="headerlink" title="SO_ERROR"></a>SO_ERROR</h3><p>当一个套接字上发生错误时，内核将套接字的名为so_error的变量设置为标准的Unix Exxx值中的一个，它被成为该套接字的待处理错误(pending error)，内核以以下方式通知进程这个错误：</p>
<ol>
<li>如果进程阻塞在套接字的select调用上，那么无论是检查可读条件还是可读可写条件，select均返回并设置其中一个或所有的条件。</li>
<li>如果进程使用信号驱动I/O模型，那么进程或进程组就会接收到内核产生的SIGIO信息。</li>
</ol>
<p>进程在被内核通知之后，可以通过访问SO_ERROR套接字选项获得so_error的值，由getsockopt返回的整数即待处理错误，随后so_error由内核复位成0。</p>
<p>这个套接字选项可以获取，但是不能设置。</p>
<h3 id="SO_KEEPALIVE"><a href="#SO_KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>给一个套接字设置保持存活(keep-alive)选项后，如果2小时内在该套接字的任意一个方向上没有数据交换，那么TCP就会自动给对端发送一个保持存活的探测分节(keep-alive probe)，这是一个对端必须响应的TCP分节，它<br>会导致以下三种情况之一：</p>
<ol>
<li>对端以期望的ACK响应，一切正常</li>
<li>对端以RST响应，对端已经崩溃并重启，套接字的待处理错误被置为ECONNRESET，套接字本身被关闭。</li>
<li>对端对保持存活的探测分节没有响应，TCP间隔一段时间再次发送探测分节，多次之后若还是没有响应，则放弃套接字的待处理错误被置为ETIMEOUT，如果收到一个ICMP错误作为某个探测分节的响应，就返回相应的错误，套接字本身被关闭。</li>
</ol>
<h3 id="SO_LINGER"><a href="#SO_LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><p>指定close函数对面向连接的协议(TCP和SCTP)如何操作。默认的行为是立即返回，如果这时候发送缓冲区有数据残留，系统会尝试把数据发送给对方。选项要求用户进程和内核间传递如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> linger &#123;</span><br><span class="line">	<span class="keyword">int</span> l_onoff;</span><br><span class="line">	<span class="keyword">int</span> l_linger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果l_onoff = 0，l_linger被忽略，选项关闭</li>
<li>l_onoff非0，<ul>
<li>l_linger = 0，那么TCP丢弃发送缓冲区内的任何数据，并发送一个RST给对端，不会再有四次挥手。</li>
<li>l_linger不为0，进程被阻塞，知道所有发送缓冲区的数据都发送完毕并被对方确认，或者是超过了l_linger指定的时间，如果超时，close返回EWOULDBLOCK错误。</li>
</ul>
</li>
</ol>
<p>假设客户在发送玩数据后调用了close函数，close可能在服务器读套接字接收缓冲区中的剩余数据之前就返回，在应用程序读数据之前服务器可能就会崩溃，而客户进程永远不会知道。<br>如果设置了SO_LINGER套接字，那么在调用close函数后，应用进程阻塞一段时间，等待数据全部发送并被对方确认（如图所示）。但是这里还有一个问题，延滞的时间可能不够，close仍然会返回EWOULDBLOCK错误，而且close的成功返回只是告诉我们先前发送的数据已经由对方确认，并不能告诉我们应用进程是否读取了数据。</p>
<img src="/2016/09/13/套接字选项/so_linger.png" alt="so_linger.png" title="">
<p>让客户进程知道服务器已经读取数据的一个方法是改用shutdown（设置SHUT_WR），改用之后的流程如下图：</p>
<img src="/2016/09/13/套接字选项/shutdown_linger.png" alt="shutdown_linger.png" title="">
<p>另外一个方法是应用程序自己做确认。客户在向服务器发送完数据后，调用read来读取一个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ack;</span><br><span class="line"></span><br><span class="line">Write(sockfd, data, nbytes);</span><br><span class="line">n = read(sockfd, &amp;ack, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>服务器读取来自客户端的数据后发回一个字节的ACK。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nbytes = Read(sockfd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"></span><br><span class="line">Write(sockfd, <span class="string">""</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="SO_RCVBUF__26amp_3B_SO_SNDBUF"><a href="#SO_RCVBUF__26amp_3B_SO_SNDBUF" class="headerlink" title="SO_RCVBUF &amp; SO_SNDBUF"></a>SO_RCVBUF &amp; SO_SNDBUF</h3><p>每一个套接字有一个发送和接收缓冲区，可以利用SO_RCVBUF和SO_SNDBUF选项来修改默认的缓冲区大小。需要注意的是，由于TCP的窗口规模是在建立连接时用SYN分节与对端呼唤a的都的。对于客户端，意味着<br>SO_RCVBUF必须在connect调用之前设置；对于服务端，该选项必须在调用Listen之前设置。</p>
<h3 id="SO_RCVLOWAT__26amp_3B_SO_SNDLOWAT"><a href="#SO_RCVLOWAT__26amp_3B_SO_SNDLOWAT" class="headerlink" title="SO_RCVLOWAT &amp; SO_SNDLOWAT"></a>SO_RCVLOWAT &amp; SO_SNDLOWAT</h3><p>每一个套接字还有一个接收和发送低水位标志，由select使用，用SO_RCVLOWAT和SO_SNDLOWAT可以修改低水位标志的值。</p>
<p>接收低水位标志是让select返回可读时套接字接收缓冲区所需要的最少的数据量。<br>发送低水位标志是让select返回可写是套接字发送缓冲区可存入的最少数据量。</p>
<p>两个低水位的默认值都为1</p>
<h3 id="SO_RCVTIMEO__26amp_3B_SO_SNDTIMEO"><a href="#SO_RCVTIMEO__26amp_3B_SO_SNDTIMEO" class="headerlink" title="SO_RCVTIMEO &amp; SO_SNDTIMEO"></a>SO_RCVTIMEO &amp; SO_SNDTIMEO</h3><p>这两个选项允许我们给套接字的接收和发送设置一个超时值。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/Linux文件与目录的默认、隐藏和特殊权限/" itemprop="url">
                  Linux文件与目录的默认、隐藏和特殊权限
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T00:00:00+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/12/Linux文件与目录的默认、隐藏和特殊权限/" class="leancloud_visitors" data-flag-title="Linux文件与目录的默认、隐藏和特殊权限">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u9ED8_u8BA4_u6743_u9650"><a href="#u9ED8_u8BA4_u6743_u9650" class="headerlink" title="默认权限"></a>默认权限</h1><p>在Linux下创建一个文件或者目录的默认权限和<code>umask</code>相关，umask指定“当前用户在创建文件或者目录时的权限默认值”。用umask来查看文件或目录的默认权限值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ umask&#10;002</span><br></pre></td></tr></table></figure>
<p>需要注意的是umask指定文件或目录的默认值应该减去的数值。而对于一个文件，默认值是“-rw-rw-rw”，对一个目录，默认值是“drwxrwxrwx”，举例来说，如果当前用户创建了一个文件，那么文件的权限默认值就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-rw-rw-rw-) - (--------w-) =&#62; -rw-rw-r--</span><br></pre></td></tr></table></figure>
<h1 id="u9690_u85CF_u5C5E_u6027"><a href="#u9690_u85CF_u5C5E_u6027" class="headerlink" title="隐藏属性"></a>隐藏属性</h1><p>可以利用<code>chattr</code>和<code>lsattr</code>来修改和查看文件或目录的隐藏属性。需要注意的是这两个命令只在Ext2/Ext3文件系统上有效。</p>
<p>命令使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [+-=] [ASacdistu] files...</span><br></pre></td></tr></table></figure>
<p>这里只说明两个参数，其余可以参见manual</p>
<ul>
<li>i: 让一个文件不能被删除、改名、设置连接、写入或添加数据。只有root才能设置该属性。</li>
<li>a: 设置a之后，这个文件只能添加数据，而不能删除也不能修改数据，只有root才能设置该属性。</li>
</ul>
<p>lsattr查看隐藏属性，用法简单，可以直接查看manual</p>
<h1 id="u6587_u4EF6_u7279_u6B8A_u6743_u9650"><a href="#u6587_u4EF6_u7279_u6B8A_u6743_u9650" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h1><p>Linux有三个特殊权限：</p>
<ul>
<li>SUID</li>
<li>SGID</li>
<li>SBIT</li>
</ul>
<h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><p>当s标志出现在文件所有者的x权限上时，此时就被成为<code>SET UID</code>，即SUID的特殊权限。</p>
<p>SUID有这样的功能和限制：</p>
<ol>
<li>仅仅对二进制程序有效</li>
<li>执行者对该程序具有科执行的权限</li>
<li>本权限仅仅在执行过程中有效</li>
<li>执行者将拥有该程序所有者的权限（仅在执行过程中）</li>
</ol>
<p>举例来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  ~ ls -l /usr/bin/passwd &#10;-rwsr-xr-x 1 root root 54256 3&#26376;  29 17:25 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p><code>passwd</code>是一个二进制程序，它的所有者是root，但是当我们用用户身份登入时一样可以执行该程序并修改自己的密码（这回修改/etc/shadow文件）。这是因为<code>passwd</code>拥有SUID权限。</p>
<h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><p>当s标志在用户组的x时，成为<code>SET GID</code>，即SGID。SGID可以作用于一个文件，也可以作用于一个目录。</p>
<p>当作用于一个文件时：</p>
<ol>
<li>SGID对二进制程序有效</li>
<li>程序执行者对该程序有执行的权限</li>
<li>执行者在执行的过程中可以得到程序所在用户组的权限。</li>
</ol>
<p>当作用于一个目录时：</p>
<ol>
<li>用户若对此目录有r和x的权限，该用户能够进入此目录（前提）</li>
<li>用户在目录下的有效用户组将会变成该目录的用户组</li>
<li>若用户在此目录下具有w的权限，则用户所创建的文件将与此目录的用户组相同。</li>
</ol>
<h3 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h3><p>SBIT（Sticky Bit）只对目录有效。它对目录的作用是：</p>
<ol>
<li>当用户对此目录有w和x的权限，即具有写入权限时（前提）</li>
<li>当用户在该目录下创建文件或目录时，仅自己与root才有权限删除该文件。</li>
</ol>
<p>如果一个目录D有SBIT权限，当用户A在D下只能对自己创建的文件或目录进程删除、重命名、移动等操作，而无法删除他人的文件。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/UIStackView初探/" itemprop="url">
                  UIStackView初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T00:00:00+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS9-Features/" itemprop="url" rel="index">
                    <span itemprop="name">iOS9 Features</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/11/UIStackView初探/" class="leancloud_visitors" data-flag-title="UIStackView初探">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h1><p>iOS9引入了<code>UIStackView</code>，Apple文档对UIStackView的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The UIStackView class provides a streamlined interface for laying out a collection of views in either a column or a row. &#10;Stack views let you leverage the power of Auto Layout, creating user interfaces that can dynamically adapt to the device&#8217;s &#10;screen size, and any changes in the available space</span><br></pre></td></tr></table></figure>
<p>即，利用<code>UIStackView</code>我们可以很方便地垂直或水平排列多个subview。</p>
<h1 id="u914D_u7F6EUIStackView"><a href="#u914D_u7F6EUIStackView" class="headerlink" title="配置UIStackView"></a>配置UIStackView</h1><p><code>UIStackView</code>有以下几个配置选项让我们来配置它：</p>
<ol>
<li><code>Axis</code>：表示水平排列还是垂直排列</li>
<li><code>Alignment</code>：控制subview的对齐方式</li>
<li><code>Distribution</code>：控制subview的分布方式</li>
<li><code>Spacing</code>：subview间的最小距离</li>
</ol>
<p><code>Alignment</code>因<code>Axis</code>而异，用图示说明更加形象。</p>
<h4 id="u6C34_u5E73_u6392_u5217"><a href="#u6C34_u5E73_u6392_u5217" class="headerlink" title="水平排列"></a>水平排列</h4><img src="/2016/09/11/UIStackView初探/align_h.png" alt="align_h.png" title="">
<h4 id="u5782_u76F4_u6392_u5217"><a href="#u5782_u76F4_u6392_u5217" class="headerlink" title="垂直排列"></a>垂直排列</h4><img src="/2016/09/11/UIStackView初探/align_v1.png" alt="align_v1.png" title="">
<img src="/2016/09/11/UIStackView初探/align_v2.png" alt="align_v2.png" title="">
<h4 id="u6CE8_u610F"><a href="#u6CE8_u610F" class="headerlink" title="注意"></a>注意</h4><p><code>UIStackView</code>会被当成一个Container View，它不会像其他UIView一样被渲染，所以类似与设置背景或者是重载drawRect方法都是没有任何效果的。</p>
<h1 id="u7BA1_u7406Subview"><a href="#u7BA1_u7406Subview" class="headerlink" title="管理Subview"></a>管理Subview</h1><p><code>UIStackView</code>有两个属性</p>
<ul>
<li>arrangedSubviews</li>
<li>subviews</li>
</ul>
<p>如果我们想添加一个subview让StackView来管理，只要调用<code>addArrangedSubview(_ view: UIView)</code>或者<code>insertArrangedSubview(_ view: UIView, at stackIndex: Int)</code>即可，但是如果要删除一个被StackView管理的subview，那么我们需要主注意到<br><code>removeArrangedSubview(_ view: UIView)</code>函数只是让对应的subview不让StackView来管理它的约束，它并没有从当前的视图层级从移除，如果要移除视图，我们需要显示调用<code>removeFromSuperview()</code>。</p>
<h1 id="u7B80_u5355_u7684_u4F8B_u5B50"><a href="#u7B80_u5355_u7684_u4F8B_u5B50" class="headerlink" title="简单的例子"></a>简单的例子</h1><p>参考</p>
<ul>
<li><a href="http://code.tutsplus.com/tutorials/ios-9-getting-started-with-uistackview--cms-24193" target="_blank" rel="external">iOS 9: Getting Started with UIStackView</a></li>
<li><a href="https://www.raywenderlich.com/114552/uistackview-tutorial-introducing-stack-views" target="_blank" rel="external">UIStackView-Tutorial-Introducing-Stack-Views</a></li>
</ul>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/09/TCP连接建立和终止/" itemprop="url">
                  TCP连接建立和终止
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-09T00:00:00+08:00" content="2016-09-09">
              2016-09-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/09/TCP连接建立和终止/" class="leancloud_visitors" data-flag-title="TCP连接建立和终止">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP_u8FDE_u63A5_u7684_u5EFA_u7ACB_u548C_u7EC8_u6B62"><a href="#TCP_u8FDE_u63A5_u7684_u5EFA_u7ACB_u548C_u7EC8_u6B62" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h1><h3 id="TCP_u8FDE_u63A5_u5EFA_u7ACB"><a href="#TCP_u8FDE_u63A5_u5EFA_u7ACB" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><p>建立一个TCP连接的过程图示如下（图片均来源于网络…）：</p>
<img src="/2016/09/09/TCP连接建立和终止/shakehand3.jpg" alt="shakehand3.jpg" title="">
<ol>
<li>服务器在连接建立之前必须准备好接收客户发来的连接，这一般通过创建套接字，绑定服务器地址、监听套接字来完成，即<code>socket</code>，<code>bind</code>，<code>listen</code>三个函数。这一个过程被成为被动打开。</li>
<li>客户通过<code>connect</code>函数发起主动打开，客户会发送一个SYN分节，它告诉服务器客户将在连接中发送的数据的初始序列号，通常该分节不带数据，其所在IP数据只含有一个IP首部、一个TCP首部以及可能的TCP选项。</li>
<li>服务器收到客户发来的SYN分节后，服务器必须确认该分节，同时服务器发送一个自己的SYN分节，它含有服务器将在该连接中发送的数据的初始序列号。</li>
<li>客户收到服务器发回的消息后，确认服务器的分节，连接建立。</li>
</ol>
<p>从图中可以看到ACK是SYN分节的序列号加１，类似的，FIN分节的ACK也是FIN分节的序列号加１。</p>
<h3 id="TCP_u8FDE_u63A5_u7EC8_u6B62"><a href="#TCP_u8FDE_u63A5_u7EC8_u6B62" class="headerlink" title="TCP连接终止"></a>TCP连接终止</h3><p>TCP终止一个连接需要４个分节。</p>
<p>终止一个连接的图示如下：</p>
<img src="/2016/09/09/TCP连接建立和终止/shakehand4.jpg" alt="shakehand4.jpg" title="">
<ol>
<li>某个应用首先调用close，该端主动关闭，发送一个FIN分节</li>
<li>接收到FIN分节的对端执行被动关闭，这个FIN由TCP确认，FIN分节的接收也作为一个文件结束符（EOF）传递给接收端应用进程。</li>
<li>一段时间之后，接收到这个文件结束符的引用进程将调用close关闭它的套接字，这会导致它也发送一个FIN分节。</li>
<li>接收这个最终FIN的对端发送一个ACK确认这个FIN分节。</li>
</ol>
<h3 id="u8FDE_u63A5_u548C_u7EC8_u6B62"><a href="#u8FDE_u63A5_u548C_u7EC8_u6B62" class="headerlink" title="连接和终止"></a>连接和终止</h3><p>一个完整的连接和终止的过程示意：</p>
<img src="/2016/09/09/TCP连接建立和终止/full_process.jpg" alt="full_process.jpg" title="">
<p>一个完整的TCP状态转换图：</p>
<img src="/2016/09/09/TCP连接建立和终止/state.jpg" alt="state.jpg" title="">
<h4 id="TIME_WAIT"><a href="#TIME_WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>TCP终止中，执行了主动关闭的那端在接收到对端发来的FIN分节和发送对应的ACK之后就进入了TIME_WAIT状态，该状态的持续时间是2个MSL（maximum segment lifetime）。它的存在有两个理由：</p>
<ol>
<li>可靠地实现TCP全双工连接的终止</li>
<li>允许老的重复分节在网络中消逝</li>
</ol>
<p>对于第一个理由，如果最后的ACK丢失了，那么服务器需要重发FIN，因此客户必须维护状态信息，以允许它发送最终的那个ACK，如果客户不维护状态信息，那么客户在收到服务器重传的FIN后将直接相应RST，这个分节将会被服务器解释为一个错误。</p>
<p>对于第二个理由，假设在一个连接被终止了马上又发起来一个相同IP和端口上的连接，后一个连接成为前一个连接的化身，TCP必须防止老的连接的分组在老连接结束之后再现，以防止其被误解为新的连接的分组。TCP不会让处于TIME_WAIT状态的连接发起新的化身，既然TIME_WAIT的时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL时间即被丢弃，另外一个方向上的应答最多存活MSL时间也被丢弃。通过这种方式，老的重复分组在网络中都已经消逝。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/09/IO模型/" itemprop="url">
                  I/O模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-09T00:00:00+08:00" content="2016-09-09">
              2016-09-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Unix/" itemprop="url" rel="index">
                    <span itemprop="name">Unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/09/IO模型/" class="leancloud_visitors" data-flag-title="I/O模型">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="I/O_u6A21_u578B_u7684_u79CD_u7C7B"><a href="#I/O_u6A21_u578B_u7684_u79CD_u7C7B" class="headerlink" title="I/O模型的种类"></a>I/O模型的种类</h1><p>Unix环境下可用的5种I/O模型分别为：</p>
<ul>
<li>阻塞式I/Ob</li>
<li>非阻塞式I/O</li>
<li>I/O复用（select和poll）</li>
<li>信号驱动I/O（SIGIO）</li>
<li>异步I/O（POSIX的aio_系列函数）</li>
</ul>
<p>一个输入操作的通常包括两个步骤：</p>
<ol>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ol>
<h2 id="u963B_u585E_u5F0FI/O_u6A21_u578B"><a href="#u963B_u585E_u5F0FI/O_u6A21_u578B" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h2><img src="/2016/09/09/IO模型/io_block.png" alt="io_block.png" title="">
<p>在图示中，进程调用<code>recvfrom</code>，其系统调用直到数据到达且被复制到应用进程的缓冲区中或者发生错误才返回，最常见的错误就是被信号中断。</p>
<h2 id="u975E_u963B_u585EI/O_u6A21_u578B"><a href="#u975E_u963B_u585EI/O_u6A21_u578B" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h2><img src="/2016/09/09/IO模型/io_nonblock.png" alt="io_nonblock.png" title="">
<p>从图示中我们可以看出，当recvfrom没有数据可返回时，内核立即返回一个<code>EWOULDBLOCK</code>错误；如果有数据准备好了，那么s内核开始将数据复制到应用进程缓冲区，于是recvfrom成功返回。</p>
<p>这样一种对一个非阻塞描述符循环调用recvfrom的方式，我们称之为<code>polling</code>。</p>
<h2 id="I/O_u590D_u7528_u6A21_u578B"><a href="#I/O_u590D_u7528_u6A21_u578B" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h2><img src="/2016/09/09/IO模型/io_multiplexing.png" alt="io_multiplexing.png" title="">
<p>I/O复用模型中，我们的进程阻塞于select或者poll函数，而不是阻塞在真正的I/O系统调用上，当某一个描述符数据准备好时，我们的进程被唤醒，从而可以处理数据，通过I/O复用模型，我们可以让应用进程等待多个I/O的操作完成，而不是单单阻塞于一个I/O操作。</p>
<h2 id="u4FE1_u53F7_u9A71_u52A8_u7684I/O_u6A21_u578B"><a href="#u4FE1_u53F7_u9A71_u52A8_u7684I/O_u6A21_u578B" class="headerlink" title="信号驱动的I/O模型"></a>信号驱动的I/O模型</h2><img src="/2016/09/09/IO模型/io_signal.png" alt="io_signal.png" title="">
<p>信号驱动模型在数据就绪时通过发送<code>SIGIO</code>通知应用进程，应用进程收到信号后可以在信号处理函数中调用recvfrom读取数据。这种模式的优势在于等待数据报到达期间，进程不会被阻塞，主循环可继续执行。但是在内核复制数据到应用进程缓冲区期间，应用进程被阻塞。</p>
<h2 id="u5F02_u6B65I/O_u6A21_u578B"><a href="#u5F02_u6B65I/O_u6A21_u578B" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h2>
<p>POSIX定义同步和异步I/O操作如下：</p>
<ol>
<li>同步I/O操作：导致请求进程阻塞，直到I/O操作完成（前面四个模型按照该定义都是同步I/O）</li>
<li>异步I/O操作：不导致请求进程阻塞。</li>
</ol>
<p>异步I/O由POSIX规范定义，它告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到应用进程的缓冲区）完成后通知我们。它于信号驱动的I/O模型相比，区别在于异步模型由内核通知我们什么时候I/O操作完成，而信号驱动模型由内核通知我们什么时候可以启动一个I/O操作。</p>
<h1 id="select_u51FD_u6570"><a href="#select_u51FD_u6570" class="headerlink" title="select函数"></a>select函数</h1><p>select函数允许进程指示等到多个时间中的任何一个发生，并只在有一个或者多个时间发生或经历一段指定时间后才唤醒它。</p>
<p>函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd1, fd_set *readset, fd_set *writeset, fd_set *excepset, <span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>中断三个参数<code>readset</code>，<code>writeset</code>，<code>exceptset</code>指定要让内核测试读、写和异常条件的描述符。<code>maxfd1</code>参数指定待测试的描述符的个数，它的值是待测试描述符的最大描述符加1。在函数返回后，描述符集内任何与未就绪描述符对应的位都会被清为0，为此，每次重新调用select函数时，我们都得再次把所有需要测试的描述符对应位置位。</p>
<p>一般来说，为了提升性能而引入缓冲机制会增加网络应用程序的复杂性。比如用fgets读取文本行，这转而会使得一可用的文本行被读入到stdio缓冲区中，然而fgets只返回1行，其余仍然在缓冲区中，当fgets完成任务后，select函数会被再次调用以等待新的工作，它不管stdio缓冲区中是否还有数据，究其原因是select不知道stdio使用了缓冲区，它只是从read系统调用的角度指出是否有数据可用。所以在混合使用stdio和select时需要格外小心。</p>
<h1 id="shutdown_u51FD_u6570"><a href="#shutdown_u51FD_u6570" class="headerlink" title="shutdown函数"></a>shutdown函数</h1><p>终止网络连接的通常方法是调用close函数，但是close函数有两个限制：</p>
<ol>
<li>close把描述符的引用计数见减1，仅仅在计数变为0时关闭套接字。</li>
<li>close终止读和写两个方向的数据传送。</li>
</ol>
<p>利用shutdown函数，可以避免这两个限制，shutdown函数可以不管引用计数就激发TCP的正常终止序列，也可以在我们发送完数据后，只关闭写半部，仍然等待远端数据接收（反之亦可）。</p>
<p>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span></span><br></pre></td></tr></table></figure>
<p>函数的行为依赖于<code>howto</code>参数：</p>
<ul>
<li>SHUT_RD：关闭读半部，套接字中不再有数据可以接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数，对一个TCP套接字这样调用shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后悄然丢弃。</li>
<li>SHUT_WR：关闭写半部，对于TCP套接字这称为半关闭。当前留在套接字发送缓冲区中的数据将被发送掉，之后发送TCP的FIN分节，不管套接字描述符引用是否为0，写半部关闭都会执行，进程不能再对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR：连接的读半部和写半部都关闭，这和调用两次shutdown等效。</li>
</ul>
<h1 id="u4E00_u4E2AI/O_u590D_u7528_u7684_u4F8B_u5B50"><a href="#u4E00_u4E2AI/O_u590D_u7528_u7684_u4F8B_u5B50" class="headerlink" title="一个I/O复用的例子"></a>一个I/O复用的例子</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_strcli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxfdp1, stdineof, n;</span><br><span class="line">    fd_set rset;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    stdineof = <span class="number">0</span>;</span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/* 每次select返回后，任何未就绪的描述符清0，所以每次都要置位*/</span></span><br><span class="line">		<span class="keyword">if</span> (stdineof == <span class="number">0</span>)</span><br><span class="line">			FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">		FD_SET(sockfd, &amp;rset);</span><br><span class="line">		maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">		n = select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"select error"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span>;	<span class="comment">/* terminated normally */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				err_quit(<span class="string">"str_cli: server terminated prematurelly"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			Write(fileno(<span class="built_in">stdout</span>), buf, n);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((n = Read(fileno(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">			stdineof = <span class="number">1</span>;</span><br><span class="line">			Shutdown(sockfd, SHUT_WR); <span class="comment">/* send FIN, still can read */</span></span><br><span class="line">			FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Writen(sockfd, buf, n);</span><br><span class="line">		&#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/08/Hexo博客同步/" itemprop="url">
                  Hexo博客同步
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-08T00:00:00+08:00" content="2016-09-08">
              2016-09-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Misc/" itemprop="url" rel="index">
                    <span itemprop="name">Misc</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/08/Hexo博客同步/" class="leancloud_visitors" data-flag-title="Hexo博客同步">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hexo_u5728_u591A_u8BBE_u5907_u95F4_u540C_u6B65"><a href="#Hexo_u5728_u591A_u8BBE_u5907_u95F4_u540C_u6B65" class="headerlink" title="Hexo在多设备间同步"></a>Hexo在多设备间同步</h1><p>最近使用的电脑在Mac和实验室的电脑之间不停的转换，就出现了想写博客，可是Mac不在身边没法写的情况，所以就折腾了一下如何让Hexo博客在多个设备间同步。</p>
<p>简单来说，在部署Hexo的时候，Github上的文件是编译过后的，而我们需要同步的往往是source目录下的源文件（markdown文件、图片等）。所以我们只要新创建一个仓库，然后把要备份的文件上传到仓库即可。<br>如果和我一样，不想太麻烦，直接备份整个hexo根目录下的文件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir &#60;Blog dir&#62;&#10;git init&#10;git add --all&#10;git commit -m &#39;first commit&#39;&#10;git remote add &#60;remote name&#62; &#60;remote addr&#62;&#10;git push -u &#60;remote name&#62; master</span><br></pre></td></tr></table></figure>
<p>然后在每次更新博客之后，即可更新远程仓库就可以了。</p>
<p>在一台新电脑上恢复博客也是很简单的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &#60;remote addr&#62;&#10;cd &#60;Blog dir&#62;&#10;npm install hexo&#10;npm install &#10;npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>这样就齐活儿了。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/Interaction Transition/" itemprop="url">
                  Interaction Transition
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T00:00:00+08:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2016/09/04/Interaction Transition/" class="leancloud_visitors" data-flag-title="Interaction Transition">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Interaction_Transition"><a href="#Interaction_Transition" class="headerlink" title="Interaction Transition"></a>Interaction Transition</h1><p>为了自定义交互式的过渡动画，<code>UIViewControllerTransitioningDelegate</code>对象必须实现对应的协议方法，<code>interactionControllerForPresentation(_:)</code>和<code>interactionControllerForDismissal(_:)</code>。交互控制根据用户的手势输入来更新自定义的过渡动画，<br>而自定的过度动画是实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象，关于该协议这里就不再说明了。</p>
<p>Apple提供了一个交互式控制器的具体实现<code>UIPercentDrivenInteractiveTransition</code>，在大多数情况下，我们的交互式控制器只要继承它，然后加入自己的手势交互就好了。</p>
<p>在我们的手势交互逻辑中，根据用户的输入，我们利用以下几个方法来实时更新动画：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">updateInteractiveTransition</span><span class="params">(<span class="number">_</span> percentComplete: CGFloat)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cancelInteractiveTransition</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">finishInteractiveTransition</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>一个简单的例子如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwipeInteractionController</span>: <span class="title">UIPercentDrivenInteractiveTransition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> interactionInProgress : <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> shouldCompleteTransition : <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> viewController : <span class="type">UIViewController</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">wireToViewController</span><span class="params">(viewController : UIViewController!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.viewController = viewController</span><br><span class="line">        prepareGestureRecognizerInView(viewController.view)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">handleGesture</span><span class="params">(gestureRecognizer : UIScreenEdgePanGestureRecognizer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> translation = gestureRecognizer.translationInView(gestureRecognizer.view!.superview)</span><br><span class="line">        <span class="keyword">var</span> progress = translation.x / <span class="number">200.0</span></span><br><span class="line">        progress = <span class="type">CGFloat</span>(fminf(fmaxf(<span class="type">Float</span>(progress), <span class="number">0.0</span>), <span class="number">1.0</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> gestureRecognizer.state &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Began</span>:</span><br><span class="line">            interactionInProgress = <span class="literal">true</span></span><br><span class="line">            viewController.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Changed</span>:</span><br><span class="line">            shouldCompleteTransition = progress &gt; <span class="number">0.5</span></span><br><span class="line">            updateInteractiveTransition(progress)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Cancelled</span>:</span><br><span class="line">            shouldCompleteTransition = <span class="literal">false</span></span><br><span class="line">            interactionInProgress = <span class="literal">false</span></span><br><span class="line">            cancelInteractiveTransition()</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ended</span>:</span><br><span class="line">            interactionInProgress = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> shouldCompleteTransition &#123;</span><br><span class="line">                finishInteractiveTransition()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cancelInteractiveTransition()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Unsupported"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MARK: private </span></span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareGestureRecognizerInView</span><span class="params">(view : UIView)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> edgeRecognizer = <span class="type">UIScreenEdgePanGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(handleGesture))</span><br><span class="line">        edgeRecognizer.edges = <span class="type">UIRectEdge</span>.<span class="type">Left</span></span><br><span class="line">        view.addGestureRecognizer(edgeRecognizer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了这个Animator之后，只要在另外一个对象（实现了UIViewControllerTransitioningDelegate协议）的<code>interactionControllerForDismissal(_:)</code>返回这个类的实例即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">interactionControllerForDismissal</span><span class="params">(animator: UIViewControllerAnimatedTransitioning)</span></span> -&gt; <span class="type">UIViewControllerInteractiveTransitioning</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> swipeAnimator.interactionInProgress ? swipeAnimator : <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.JPG"
               alt="Zach" />
          <p class="site-author-name" itemprop="name">Zach</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zach</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("ntwSG1Uc9Pv9VSd5ODUsFYkK-gzGzoHsz", "HoWAvsNTJHhdUmXFuqT6j4vp");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
